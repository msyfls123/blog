{"pages":[{"title":"about","text":"前端工程师，现就职于腾讯文档。 无锡人，喜甜食，不拒酸苦辣。 好读金庸武侠、郑渊洁童话，一个坚定的共产主义群众。 曾驯服前公司于豆瓣拥有 3w 粉丝的网红猫大蛋一只。 技术栈 TypeScript, Python, HTML5 GraphQL, RxJS, React, Webpack, CycleJS, Electron 了解 Rust, 对 Android, QT 等有粗浅认识 社区 JSConf China 2019 Speaker: 响应式编程使你看得更远 InfoQ 采访：掌控前端数据流，响应式编程让你看得更远 经历 2020.7 – 至今 腾讯文档前端开发工程师 See Eletron 跨端开发 2016.10 – 2020.7 豆瓣阅读前端工程师 See 在团队内推动了 GraphQL 的使用，初步引入 RxJS 处理并发异步操作 小程序开发，实现微信内图文混排阅读 日常功能的开发与维护，逐步将 web 书店和管理系统从后端模板迁移至 tsx 2016.3 - 2016.7 蜗牛数字前端开发实习 See VR、直播聚合 web 站点的研发 官网页面维护与活动 H5 页面的开发 其他 设计 See 交互 See Django 建站一例 See 烧饭 See","link":"/blog/about/index.html"}],"posts":[{"title":"方块日历","text":"大过年的水一篇。 这是 5 年前的一个问题：利用四个骰子组合出一年 12 个月共 365 天。虽然当时已经有解了，就是题图的这四个方块，但毕竟是想通过自己思路来解决。 一开始想的笨办法，穷举之，0101 —— 1231 这些都列出来，然后暴力组合，但进一步想就觉得不太现实。 小技巧首先可以确定的一点是 6 和 9 是可以互换的，这样我们就只需要考虑 0 —— 8 这 9 个数的排列了。 划分子问题然后想一想，月份一共就 12 个数，算是两个骰子排出一个月 31 天的子问题，所以先尝试一下两个骰子能排出多少天，不够的天数再用剩余俩骰子凑凑看。 用两枚骰子排出天数十位的数字也就 0 1 2 3 这 4 种，而且 3 还不常见，所以猜测每个骰子都会有 0、1、2 这三个数，剩下来还有 3、4、5 和 6、7、8，正好可以分布在两枚骰子上！ 解决了这样排出天数后，如法炮制就可得到月数，所以证明四枚骰子是完全可以排列出一年 12 个月 365 天的！等有空时写个 web 版的方块日历~","link":"/blog/2021/02/17/cube-calendar/"},{"title":"非主流 App GUI 框架 - Druid","text":"不会吧，不会吧，都 2021 年了还有人在写桌面端应用吗？不都是 Electron 一统江湖了吗？对，也不对，Electron 的确大大降低了 web 页面直接生成单个可执行桌面程序的难度，但因其依赖于 Chromium 内核，糟糕的启动速度和海量内存占用一直是广大网友所诟病之处。市面上还是有很多跨端 GUI 解决方案的，比如 Qt 和 GTK 等等，但既然是玩票嘛，就搞点新鲜的，本文就介绍一下当红炸子鸡语言 Rust 上的非主流 GUI 框架 - Druid。 先简单介绍下 Druid，它同样是一个数据驱动的原生框架，背后是同作者开发的 Piet 绘图库。在不同的系统上有着不同的实现，这里就不多提了，感兴趣的可以深入研究一下。目前 Druid 还处在较为早期的开发阶段（除此之外的 GUI 库也都差不多……），所以文档和示例都很不全。本文将基于 0.7.0 版本进行阐述，如后续有不兼容升级，以官方文档为准。 启动安装万事开头难，中间更难，最后最难。说实话，Rust 的包管理系统已经算是不错的了，在你装好了 Rust 环境之后，随便创建个 cargo bin 项目即可，把 druid 加到依赖里面，这里推荐装个 cargo-edit 的包，这样你就能得到以下几个 cargo 命令，后续就不需要手动改 Cargo.toml 文件了。 1234cargo-edit v0.7.0: cargo-add cargo-rm cargo-upgrade 第一个界面官网第一个 case 就让我们栽了跟头，这里的 log_to_console 和 ui_builder 都不太对劲，改成如下代码就可以跑出首个界面啦。 12345678910111213141516171819202122use druid::widget::{Button, Flex, Label};use druid::{AppLauncher, LocalizedString, PlatformError, Widget, WidgetExt, WindowDesc};fn main() -&gt; Result&lt;(), PlatformError&gt; { let main_window = WindowDesc::new(ui_builder); let data = 0_u32; AppLauncher::with_window(main_window) .use_simple_logger() .launch(data)}fn ui_builder() -&gt; impl Widget&lt;u32&gt; { // The label text will be computed dynamically based on the current locale and count let text = LocalizedString::new(&quot;hello-counter&quot;).with_arg(&quot;count&quot;, |data: &amp;u32, _env| (*data).into()); let label = Label::new(text).padding(5.0).center(); let button = Button::new(&quot;increment&quot;) .on_click(|_ctx, data, _env| *data += 1) .padding(5.0); Flex::column().with_child(label).with_child(button)} 麻雀虽小，五脏俱全，我们可以看到 ui_builder 就是界面相关的部分了，其中有文本和按钮，以 flex 布局，而这个函数被整个传递给了一个 WindowDesc 的构造函数，这就创建了一个窗口，然后这个窗口又被传递给了 AppLauncher，接着用 data 作为初始数据启动。整体逻辑还是比较清晰的。 数据虽然前面传入的数据只是一个 u32，但实际应用的数据状态肯定不止如此。Druid 提供了一套简单但够用的数据定义和处理模型，其核心是通过内部获取数据的可变引用直接修改数据本身，而外部通过消息传递给代理器统一更改数据，实现了灵活多样的数据操作。 类型定义首先是类型定义，Druid 提供了 Data 和 Lens 两个重要的 trait，它们分别提供了如何判断数据相等和如何从一大块数据中提取所需要数据的方式。 123456789use druid::{Data, Lens};use tokio::sync::mpsc::{UnboundedSender}[derive(Debug, Clone, Data, Lens)]pub struct State { pub day: u32, #[data(ignore)] pub dispatch: UnboundedSender&lt;u32&gt;,} 通常情形下，Date 和 Lens 可以被 derive 自动实现，但有些时候则需要一点小小的帮助，比如上图就需要忽略掉不可比较的 dispatch 字段，它只是一个消息发送器，无所谓变更，也不会变更。像 Lens 的用途就更大了，比如组合属性等，详情可见 LenExt。 事件与代理前面讲了事件处理的方式： 直接获取数据可变引用并修改 通过消息代理 先讲讲消息代理这种形式吧，毕竟从 React 过来的人都偏好单向数据流。 在 AppLauncher 真正 launch 之前可以通过 get_external_handle 获取一个 ExtEventSink，通过它可以向 Druid App 内发送消息，这玩意甚至可以跨线程传递。而接受消息同样在 AppLauncher 上，通过传入一个实现了 AppDelegate trait 的 struct 给 delegate 方法即可。 需要注意的是，发送的消息和接受的消息都需要以唯一的 Selector 识别，示例如下： 123456789101112131415161718use druid::{Selector, AppDelegate};const NEW_DAY: Selector&lt;String&gt; = Selector::new(&quot;new-day&quot;);impl AppDelegate&lt;State&gt; for AppDelegater { fn command( &amp;mut self, ctx: &amp;mut DelegateCtx, _target: Target, cmd: &amp;Command, data: &amp;mut State, _env: &amp;Env, ) -&gt; Handled { if let Some(day) = cmd.get(NEW_DAY) { data.days.push_back(day.to_string()); Handled::Yes } }} 控制器控制器即 Controller，它和 App 上的消息代理类似，但不同之处在于它往往是局部的，能提供针对某种 Event，组件生命周期和内外数据变化的精细控制。 例如，我们想要在窗口中实现一个右键菜单：每当用户操纵鼠标在窗口内右键单击时调用 make_demo_menu 创建一个菜单。 12345678910111213141516171819202122232425use druid::widget::{Controller};use druid::{Widget, Event, ContextMenu};use crate::components::menu::make_demo_menu;use crate::types::{State};pub struct WindowController;impl &lt;W: Widget&lt;State&gt;&gt; Controller&lt;State, W&gt; for WindowController { fn event( &amp;mut self, child: &amp;mut W, ctx: &amp;mut druid::EventCtx&lt;'_, '_&gt;, event: &amp;druid::Event, data: &amp;mut State, env: &amp;druid::Env ) { match event { Event::MouseDown(ref mouse) if mouse.button.is_right() =&gt; { let context_menu = ContextMenu::new(make_demo_menu(), mouse.pos); ctx.show_context_menu(context_menu); }, _ =&gt; child.event(ctx, event, data, env), } }} 需要注意的是没有处理的 Event 需要显式交给 child 继续处理，这与浏览器的 DOM 事件不同，是向下“冒泡”的。 环境变量这里的环境变量不是指系统的环境变量，而是 Druid App 组件相关的整体设定，例如窗口颜色和按钮尺寸等等。环境变量分两种：一种全局，一种局部。 全局的环境变量通过 launcher 的 configure_env 设置。 123456789launcher.use_simple_logger() .configure_env(|env, _| { env.set(theme::WINDOW_BACKGROUND_COLOR, Color::WHITE); env.set(theme::LABEL_COLOR, Color::AQUA); env.set(theme::BUTTON_LIGHT, Color::WHITE); env.set(theme::BUTTON_DARK, Color::WHITE); env.set(theme::BACKGROUND_DARK, Color::GRAY); env.set(theme::BACKGROUND_LIGHT, Color::WHITE); }) 而局部的环境变量则可以通过 EnvScope 来设置，就可以做到组件样式隔离。 123456EnvScope::new( |env, data| { env.set(theme::LABEL_COLOR, Color::WHITE); }, Label::new(&quot;White text!&quot;)) 界面所谓界面，就是窗口中显示的那部分东西，通常来说是布局和组件的有机结合，当然也可以自定义组件的展示和行为，只需定义好所需的更新方式、事件处理、生命周期等即可，这样就带来了更多的可扩展性。 组件最常见的组件莫过于文本块 Label 和按钮 Button 了。剩下的比如 Tab 栏、进度条、单选多选项、输入框等也是基本都有。展示一下基本的按钮和文本块的创建方法。 123456let button = Button::new(button_text) .on_click(|_ctx, data: &amp;mut State, _env| { data.count += 1; }) .padding(5.0);let label = Label::new(&quot;hello world&quot;); 布局1234567 -------non-flex----- -flex-----| child #1 | child #2 | ----flex------- ----flex-------| child #1 | child #2 | Druid 提供了 Flex 布局，熟悉 CSS 的同学一定很快就能理解，但类似以下这种命令式的创建方式还是让人皱眉头且怀念 CSS。 12345678use druid::widget::{Flex, FlexParams, Label, Slider, CrossAxisAlignment};let my_row = Flex::row() .cross_axis_alignment(CrossAxisAlignment::Center) .must_fill_main_axis(true) .with_child(Label::new(&quot;hello&quot;)) .with_default_spacer() .with_flex_child(Slider::new(), 1.0); 新建窗口光靠组件和布局，仅仅是在窗口之内操作肯定是不足以创建出足够具有动态的应用的，我们还需要动态创建窗口的能力！Druid 也提供了在 EventCtx 或 DelegateCtx 上创建窗口的能力。 比如我们可以在全局 AppDelegate 上注册新窗口的 Command。 1234567891011121314151617181920pub struct AppDelegater;impl AppDelegate&lt;State&gt; for AppDelegater { fn command( &amp;mut self, ctx: &amp;mut DelegateCtx, _target: Target, cmd: &amp;Command, data: &amp;mut State, _env: &amp;Env, ) -&gt; Handled { if let Some(_) = cmd.get(NEW_WINDOW) { ctx.new_window(WindowDesc::new(new_window_builder) .window_size((400.0, 300.0))); Handled::Yes } else { Handled::No } }} 图片 图片是个复杂的东东，目前看到 Druid 的处理方式是直接将图片的二进制数据编译进去，在运行时转变成像素进行渲染，需要安装 image 这个 crate 进行处理。后续 Druid 的版本会简化这一流程，但当前还是得这么写 …… 且图像会被变成黑白照片，不知道为啥，有知道的同学请不吝赐教。 12345678910111213141516171819202122use druid::widget::{Image, SizedBox};use druid::{Widget, ImageBuf, WidgetExt, Color};use druid::piet::{ImageFormat};use crate::types::State;pub fn make_image() -&gt; impl Widget&lt;State&gt; { let raw_image = include_bytes!(&quot;../../resources/image/example.jpg&quot;); let image_data = image::load_from_memory(raw_image).map_err(|e| e).unwrap(); let rgb_image = image_data.to_rgb8(); let size_of_image = rgb_image.dimensions(); let image_buf = ImageBuf::from_raw( rgb_image.to_vec(), ImageFormat::Rgb, size_of_image.0 as usize, size_of_image.1 as usize, ); SizedBox::new(Image::new(image_buf)) .fix_width(size_of_image.0 as f64 / 8.0) .fix_height(size_of_image.1 as f64 / 8.0) .border(Color::grey(0.6), 2.0).center().boxed()} 其他通常来说 GUI 程序拥有数据和界面就够了，这也就是典型的 MVC 架构，但实际上作为跨平台框架还需要考虑系统原生接口和国际化等问题，甚至包括富文本的处理。只有这些都面面俱到了，才能做到开发者无痛接入，一发入魂。 菜单与快捷键Windows 和 macOS 的菜单不太一样，Windows 是挂在每个窗口标题栏下，而 macOS 则是挂在屏幕边缘，实际上它们都是作为窗口的一部分存在的，所以在设计时也是统一在窗口初始化时传入。 1234let menu = MenuDesc::new(LocalizedString::new(&quot;start&quot;)) .append(make_file_menu()); .append(make_window_menu());let main_window = WindowDesc::new(ui_builder).menu(menu); 国际化 i18nDruid 的国际化是通过 LocalizedString 来实现的，例如在界面中有如下一段文本。 12let text = LocalizedString::new(&quot;hello-counter&quot;) .with_arg(&quot;count&quot;, |data: &amp;State, _env| data.count.into()); 则可以通过创建一个 resources/i18n/en-CN/builtin.ftl 的文件（具体以 Druid 启动时的输出语言为准），在其中写入对应 hello-counter，其中的 count 就会被替换成实际的数据。 12# resources/i18n/en-CN/builtin.ftlhello-counter = 现在的值是 { $count } 富文本渲染、编辑我们知道，经典物理学只是茫茫科学中限于低速宏观之中极小的一块研究区域，同理，一个简单的输入框也是富文本编辑的一个缩影。 完整的 text 模块包含了很多东西，但简单一点考虑，我们实现一个富文本编辑器只需要一个 Editor 和一个 RichText 的展示容器即可。 而 RichText 本质上是一串字符串与数个按索引设置的属性的数据集合。 12345pub fn generate_example_rich_data(text: &amp;str) -&gt; RichText { let attr = Attribute::TextColor(KeyOrValue::Concrete(Color::PURPLE)); RichText::new(text.into()) .with_attribute(6..=10, attr)} Druid 并不支持 WYSIWYG 所见即所得的编辑模式，所以编辑器和富文本内容是分离的，在数据中实际存储的应该是一段 raw 文本和数个属性的集合，在渲染时组成 RichText 传递给 RawLabel 进行渲染。 详情可见官方示例 - markdown_preview。 调试在万能的 VS Code 里调试 Rust 程序是比较方便的。在创建 Rust 项目后，VS Code 就会提示按照 llvm 相关组件以便启用 DEBUG 模式。 在 .vscode/launch.json 中添加 lldb 为目标的配置后，即可在调试侧边栏一键开启调试模式。 1234567891011121314151617181920212223{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;type&quot;: &quot;lldb&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Debug executable 'gui'&quot;, &quot;cargo&quot;: { &quot;args&quot;: [ &quot;build&quot;, &quot;--bin=gui&quot;, &quot;--package=gui&quot; ], &quot;filter&quot;: { &quot;name&quot;: &quot;gui&quot;, &quot;kind&quot;: &quot;bin&quot; } }, &quot;args&quot;: [], &quot;cwd&quot;: &quot;${workspaceFolder}&quot; } ]} 如图所示，断点处的变量、调用栈、上下文等信息一览无余。 结语本文简单介绍了 Rust GUI 框架 Druid 的基本架构和使用，通过笔者自行摸索解决了 Druid 实际运行版本和 Demo 及文档脱钩的问题，希望能对读者有所裨益。 后附笔者调试测试用的 Demo 仓库地址：https://github.com/msyfls123/rust-gui","link":"/blog/2021/05/18/druid-a-new-gui-framework/"},{"title":"Electron 踩坑","text":"来鹅厂做了俩常规项目（更新文件上传方式至 COS 及修改移动端顶部 UI）后参与了文档 App 的桌面 Electron App 开发，在 UI 层上又是一个坑接一个坑。主要有下述几点： 实现适应于内置 React 组件大小的 BrowserWindow，同时保证首次加载时页面不会错乱 使自定义弹窗可拖拽并且内部表单组件可使用 在 BrowserWindow 内弹出超出 Window 范围的菜单 跨端编译打包后发现 runtime 对不上 使 BrowserWindow 自适应 React 组件我们知道 Electron 的 BrowserWindow 的默认尺寸为 800 × 600，虽然可以初始化设置弹窗大小，但是并不知道弹窗内容尺寸呀！于是乎，需要先隐藏弹窗直至 compsnentDidMount 时获取到 dialog 内容尺寸再设置 BrowserWindow 的大小并显示。 123456789101112// main-process 打开弹窗import { ipcMain } from 'electron'export function openDialog() { const dialog = new BrowserWindow({ show: false }) ipcMain.once('dialog-did-mount', () =&gt; { dialog.show() })} 1234567891011121314151617// renderer 页面在组件加载后设置宽高并返回消息显示 windowimport React, { useEffect, useRef } from 'react'import { ipcRenderer, remote } from 'electron'export default function Dialog() { const dialogRef = useRef() useEffect(() =&gt; { const window = remote.getCurrentWindow() const { clientWidth, clientHeight } = dialogRef.current window.setSize(clientWidth, clientHeight, true/* animate */) window.center() ipcRenderer.send('dialog-did-mount') }) return &lt;div ref={dialogRef}&gt; contents... &lt;/div&gt;} 拖拽窗口官方解答遇到的坑是设置好 dialog 内部 button/input 的 no-drag 后发现 dui（某鹅厂组件库）会直接在 body 下生成 DOM 节点，哪怕设置上了 dui-* 这样的通配符都没用，在 Windows 上点击事件还是穿透了组件，只好给整个内容的区域都打上了 -webkit-app-region: no-drag。 弹出超出 Window 的菜单官方做法设计觉得 Windows 下不好看，于是要自定义 BrowserWindow。 1234567891011// main-process 打开弹窗import { BrowserWindow } from 'electron'function openMenu(x, y) { const menu = new BrowserWindow({ x, y }) menu.loadUrl(`file://${__dirname}/menu.html`) menu.on('did-finish-load', () =&gt; { menu.show() })}ipcMain.on('open-menu', (event, x, y) =&gt; openMenu(x, y)) 12345678910111213141516171819// renderer 渲染进程捕获触发元素import { remote } from 'eletron'import React, { useRef, useEffect } from 'react'export default function App() { const btnRef = useRef() useEffect(() =&gt; { const window = remote.getCurrentWindow() const { x: windowX, y: windowY } = window.getBounds() const { x: elX, y: elY, height } = btnRef.current.getBoundingClientRect() const x = windowX + elX const y = windowY + elY + height ipcRenderer.send('open-menu', x | 0, y | 0) }) return &lt;div&gt; content... &lt;button ref={btnRef}&gt;点我出菜单&lt;/button&gt; &lt;/div&gt;} 其中 1ipcRenderer.send('open-menu', x | 0, y | 0) 非常重要 😂 因为 Electron 打开 menu 的 x &amp; y 只认整型，而 getBoundingClientRect() 返回了浮点数，直接用就崩了…… 区分「开发时」「编译时」和「运行时」跨端开发的优势就是 Write Once, Run Everywhere。代码能贴近运行时判断就贴近运行时判断，不过为了开发和打包大小，有如下几个优化思路。 跨端开发 UI 需要调试查看其他端上的状态，所以会需要一个全局的样式开关，目前只区分了 macOS 和 Windows，写作12// constants/setting.tsconst useMacStyle = process.platform === 'darwin' 开发时只需要按需加 ! 取反就可以方便切换样式了，process.platform 是啥？这就是编译时了。 编译时需要确定目标对象，一般会写成不同脚本或者是一个脚本里根据 platform 分发并写入进程参数，为了锁死各种依赖关系，假设某处写了 process.platform === 'darwin 如果 platform 不符合就会直接剪枝掉后面的部分。 而运行时就广泛得多，比如关闭所有窗口时默认退出 App。1234567import os from 'os'import { app } from 'electron'app.on('window-all-closed', () =&gt; { if (os.platform() !== 'darwin') { app.quit() }}) 再比如根据系统类型开启不同的提示文本，这些都需要运行时判断，虽然也可以直接编译时判断，但终究不够灵活。 __结论__：类似于配置下发的流程，如果是偏开发侧的内容可以在一处统一管理，如果是偏向本地系统的功能可以根据实际运行环境开闭，做到尽量少依赖于编译时以求在多端最大化复用代码逻辑。 To be continued……","link":"/blog/2020/08/20/electron-eat-shit/"},{"title":"如何从前端到客户端","text":"我是如何从一个工作全部内容只是 HTML + CSS + JavaScript 的前端，转为一个依然基本靠着前端三板斧技能工作，但支撑起了”横跨三大操作系统 + 各种处理器架构 + 保持 web 同步迭代周期 + 复用了 web 95% 以上功能的桌面端产品“的伪客户端工程师？ 首先当仁不让地要祭出 Electron 这件大杀器，现在开发一个桌面端最最行之有效的方式仍然是 web 套壳，让 web 代码几乎不用改就可以直接运行在一个窗口里。如果采用别的技术方案，我曾不止一次地在前同事和当下 leader 等口中听到拿 C++/OC/Swift 之类的写界面要吐血三升之类的话语，理解各种 Window、Dialog、Layout、Signal &amp; Slot 就足够一个前端喝一壶了，而这些技术细节在 Electron 下都可以化繁为简成一个个普通的 Chrome 窗口，以及与之相关联的 Node.js 胶水逻辑。 Electron 更接近于 Hybrid 应用 虽然把页面展示出来只是客户端面临的众多问题之一，但这恰好是客户端做 UI 最复杂的那一部分。 使用 Electron 就是说我可以在不改变主要工作语言的前提下，尽可能快且大地延展自己的作业范围，以较低成本快速搭建起原型，这是前端选择其他语言或者框架进行客户端开发无法企及的优势。 那是不是只要上了 Electron，把 web 页面一封装就万事大吉了呢？倒也不是，客户端开发上接网络通讯、界面渲染，下至系统特性 API，它这个逻辑不是后端来一个 request 返回一个 response（简化模型），也不是前端从一个页面加载到脚本执行后进入等待 UI 交互的过程就结束了。客户端需要同时处理多个页面的展示、管理前后台进程、与服务器做通讯、主动存取数据至文件等。 角色 替身 后端 收银员/会计 前端 导购/客服 客户端 客户经理/维修人员 我更偏向从角色和现实生活中的替身角度认识各个端的分工，这个分工不是绝对的，彼此之间有交集。前端主要负责 UI 的展现，像是一个商店的导购小姐，根据用户喜欢安排不同的商品；客户端则是客户经理，向已经对此感兴趣的用户进一步演示商品的功能，并分析深层次用户需求；后端则是收银员兼会计，这时候用户已经拍板下单了，如何收钱，如何签订协议，如何发货和三保。之后可能还会有进一步交互，比如用户发现商品出了问题，继续通过网页上反馈过来，然后客户端需要更新版本，相当于以旧换新，完成持续交付。 下面我将从四个角度来阐述我对客户端开发的理解： 技术应用抛开具体使用的语言或者框架，不同的职位或者开发方向在解决用户需求和技术问题上有着不同的纵深，意味着“术业有专攻”。这一点很多时候属于给用户一把锤子，他就看啥都像钉子一样，由不得你，甚至还会倒逼你去一步步提升体验。 剪贴板既然都上了客户端，想必用户需要频繁操作的了，这就免不了要和键盘及鼠标事件打交道。常见的输入方式还好，就跟浏览器基本一致，只是遇到过 Mac 上无法通过快捷键复制粘贴的问题。说来都离谱，作为一个文本编辑软件，发布出去时竟然无法使用快捷键 Ctrl + C + Ctrl +Ｖ！还好我们很快就发布了版本修复了这个问题。 Shortcuts in Electron on Mac 而后我们又发现了右键菜单也得自己实现，不由感叹浏览器真是个复杂且贴心的玩意，给前端实现了如此多的功能。右键菜单部分同样是由 Electron 封装好了大量具体系统的 API，只需 JS 调用即可。 这些可能还是看得见的部分，看不见的部分，比如系统的剪贴板？如果我们想要模仿手机上长按复制文本至 App 内识别链接并打开对应页面的功能该如何操作呢？ 因为各系统的剪贴板实现都是不同的，Web 上早期使用 execCommand 来与剪贴板交互，现在则有 Clipboard API。看起来很美好，只是致命的是 clipboardchange 事件尚未被 Chrome 实现 …… 这里陷入了前端的盲区。 Async Clipboard API - clipboardchange event not fired 从前端角度走不通，可以看一看 Electron。Electron 本身自带了一个 Clipboard API，上面有各种读取文本、富文本数据、图像的方法。同时，发起检查剪贴板的请求倒是容易，再不济也可以用轮询。做得细一点可以用 RxJS 来订阅一个根据鼠标聚焦窗口事件 + 剪贴板文字 + 去重 + 抢占式的调度模型： 使用 RxJS 处理前端数据流 这里有个问题：当用户重复复制同一段文本进入到我们的客户端时如何判断出来呢？文本比较肯定是失效了，系统层面前面也了解过没有一致的剪贴板改变事件，所以只剩一条路，就是标记这段文本。 因为绝大部分程序只读 bookmark 里的 url 而不会去读 title，可以用 title 来标记这段文本已经被我们的客户端识别过了，当用户再次从任意地方复制了文本时会清除掉这个 bookmark，也就达到了我们标识已经过 App 识别链接的文本的目的了。 到这里我们发现，客户端的开发与前端正在趋同，两者都会深入系统提供的功能，又期望第三方库或者浏览器能提供标准的接口。 安装与更新作为前端开发，页面关闭或刷新时，整个页面所有的元素都被销毁了，重新载入就是一张全新的白纸。而客户端不一样，下载下来就在硬盘占据了几百 MB 的空间，那可是战战兢兢，指不定哪一天用户嫌体积大就给卸载了。怎么办？当然是与时俱进，网页的优势在于刷新就是新版本，而客户端就只能老老实实做一键安装与自动更新了。 本着用户价值最大化的原则，现在软件大多抛弃了争奇斗艳的安装界面，反正做得越花哨越像流氓软件，Electron 社区标配 electron-builder 打包时提供的默认安装功能就挺好。只不过有时候要考虑旧版本的卸载问题，因为客户端技术更新换代，总有技术断层的阶段，旧版本无法正常自动更新到新版。像 Mac 上软件都进到了全局唯一的软件目录，安装时可以由系统来提示，玩 Linux 的也都是大神，安装不上也会自己手动 remove，但最广大的 Windows 用户迫切需要一键卸载旧版本的功能。我找到了 electron-builder 所依赖的 NSIS 安装器，定制了其安装脚本，在检测到旧版本的卸载程序存在于注册表时，会直接调用这个卸载程序，并等待它成功返回后进行新版本的安装过程。 作为互联网产品，诱骗，啊不是，引导用户安装上客户端不是终点，需要推陈出新、高效迭代，这就需要自动更新了。自动更新的目的在于及时让用户用上新版本，仿佛是一句废话。但鉴于大部分用户都是既嫌你更新太勤，又嫌你下载耗费流量，还盼着你能给他一天天地带来体验优化的主，这个开发思路还就是和网页前端不一样。 系统 CPU 架构 安装包 自动更新包 Windows x32 / x64 / arm64 exe exe macOS x64 / arm64 dmg / pkg zip Linux x64 / arm64 deb / rpm - 首先不同的系统当然是不同的包，而根据 CPU 架构及包的用途，就能打出 10 多个不同的安装包来，总大小甚至超过了 2G …… 这在前端的角度看来真有些不可思议，究其原因还是因为 Electron 打包了 Chromium，这个东西就占据了每个安装包中至少 70% 的空间，而这一切都是为了能保证在不同机型上都有一致的浏览体验。 由于一开始开发时没有意料到 CPU 架构竟会如此迅速地扩展，所以现在只得以新版本逐渐刷量的方式来逐步替换成独立架构的客户端。这样做的好处是，后续更新时只需要下载对应架构的文件即可。 关于自动更新还有如何进行灰度配置下发更新信息，通过 CDN 进行版本管理，App 内如何完成更新等，可参见之前的文章： Electron 客户端自动更新 这还未到终点，更新一整个客户端接近 100M 的体积仍是过重了，还可以将 Electron 内核和不怎么修改的数据库部分都抽离出来，这样只需要与网页一样更新静态资源即可。 离线使用本身 Electron 就是可以离线使用的，只是加上了在线网页之后就需要网络才能工作。一种方案是和移动端一样拦截 HTTP 请求并转发到本地离线资源，但这样带来的问题是需要定义非常繁复的拦截规则，以及如何更新离线资源等。 我们可以将离线的数据和资源分离，数据可以同移动端走一套数据库接口，只不过需要将数据库编译成不同的平台的动态链接库。 初探 Node.js 原生扩展模块 然后是资源离线使用，或许很多人已经猜到了，那就是被称为 Electron 杀手的 PWA。 在看过了 PWA 所列出的种种好处后，我们发现其不可避免地仍是一个 web 应用。所以，一个大胆的假设，用 PWA 来加载客户端所需要的页面！这样既拥有了网页的便利，又拥有了可触达系统本身 API 的能力，可谓一石二鸟之计。 目前我们的腾讯文档桌面端离线功能正在紧锣密鼓地攻坚中，很快将于大家正式见面。 浏览器体验作为一个名为客户端，实际上是定制版 Chrome 的软件，向 Chrome 看齐永远是对的。 用户说页面字体太小，看不清，那就给他加缩放快捷键。 用户又说缩放了看不到当前比例很慌，那就给他加缩放比例的 tips。 这个用户满意了，那个用户说，哎呀我导出来了文档放在电脑上记不住了呀。 给他抄个 Chrome 的下载记录页面！ 如何存取页面缩放比例？如何在不同窗口间切换时共享一个 tips？鼠标悬浮移入移出 tips 显隐规则是怎样的？ 导出记录该如何跟文档一一对应？有很多天记录时该怎么设计数据结构？本地文档被删除了怎么办？ 不做不知道，一做吓一跳。原来一个浏览器不止看到的网页部分，周围的配套功能也有很多门道。 作为追赶者，有个好处是毕竟前方一直有领军者，永远有追赶的目标，但也总得想着如何积攒自己的优势，在属于自己的赛道上滑出自己的风采。 角色扮演前面提到的都是用户需要什么功能，但作为开发不仅仅是写出代码交给用户就完事了，同样重要的是进行多方合作，齐心协力将产品做好。这时就需要发挥主观能动性，在不同的情景下扮演不同的角色了。 测试者前面提到过，前端页面往往是单个页面完成单个任务，随用随走，所以其测试也主要针对在线数据。但客户端与之不同的在于有本地数据和系统 API 的差异，这也就决定了如果按照传统的人工测试，其成本是很高的。从效能上讲，如果只是编写的代码虽然可以在不同系统运行，但有多少系统就需要测多少遍，是不够经济的，同时测试人员也不一定完全理解设计意图。答案是得用自动化的测试进行覆盖，这就要求开发人员同时扮演测试者的角色。 如何改进呢？首先从技术上讲，应该把测试行为左移。 从设计阶段就应该埋入测试所需的常量或者数据，比如可供 UI 测试获取元素用的 CSS 选择器，一些数据的 mock 可以直接放在类型定义旁边，方便测试时直接引入。 而在编写代码时，则应注意拆分可测试的单元。如果一个功能很复杂，那可以分成若干个子模块来进行编写，同样的，如果一个模块无法便捷地被测试，那它也可以被拆成若干个可测试单元，这样可以在一旦出现问题时通过一系列测试用例，准确定位到具体的单元，而不是一遍遍运行完整的模块测试以查找蛛丝马迹。 在编写测试用例时，区分平台特性是很重要的，例如快捷键或是菜单，这是 mac 和 Windows 存在显著差异的部分，又或者说只支持某个平台的用例，这时就得将不同系统的用例集用不同的机器运行。 到了运行测试时，因为客户端测试往往需要漫长的启动初始化，运行测试，处理异常情况、退出销毁测试环境等过程，在将测试自动化的过程中仍需要缓存一些数据，以供多次运行测试，降低边际成本。 合作方作为客户端，前端和后端都是你的爸爸。为啥这么说呢？因为页面出了问题，得找前端修，接口出了问题，得找后端修，仿佛变成了 bug 路由器。 想要克服这些问题，需要做到两点： 做好日志当用户发现问题，找到你这边，如何优雅地甩锅 …… 哦不是 …… 定位问题呢？那就是在各种用户行为及接口返回时都做好日志以及进行参数校验，遵循宽入严出的准则。所谓害人之心不可有，防人之心不可无，把任何第三方业务都当成是不可信来源进行防范。同时日志也可以还原出用户操作轨迹，有时候出错的点并不是问题的根源，前几页日志里一行不起眼的 warning 才是真正的问题所在。 明确职责虽然仍然是直面用户的那一端，但团队协作讲究的是分工明确，不逾矩不代劳。客户端本来就是中枢站，如果把前后端的功能都挪到端上实现，必将牵一发而动全身，这就是重构原则里的“发散式变化”。笔者之前接受登录模块，模块里甚至直接存了用户的 token，这是非常敏感的数据，如果不经良好的加密手段，可能造成用户权限被盗用。如何解决这一点呢？答案是不要重复发明轮子，而要善于利用标准轮子。登录相关的标准存储轮子就是 cookie 了，而 cookie 是由 Chrome 直接管辖的，我们只需交给 Chrome 来鉴权，并且自己维护一个非敏感的用户登录状态即可。如果一段程序不知道其作用范围，那就不要写。 客服记得我刚毕业实习时问当时 leader，我们会有直面用户的机会吗？leader 微微一笑，肯定会有的。后来我发现，原来不用和用户打交道、安心写代码的日子，才是非常弥足珍贵的…… 有人说客服是性子最好的，因为需要每天应对用户各种刁难职责而不变色。当用户找上门来，通常都是丢失了数据、或者打不开应用闪退之类的问题，仿佛落水之人看到了救命稻草。这种情况下，如果不能给用户解决问题，是有很大心理压力的，而人有压力时就容易犯错。 如何降低犯错的概率和风险呢？一种方式是尽量减少操作的步骤。俗话说，less is more，能让用户一键完成的操作就不要让他点两次。 上图是一个打开崩溃日志目录的按钮，用户需要手动把该目录里的 log 文件提供给开发（因为没找到司内相关 native 日志服务）。在没有这个按钮之前，用户需要手动打开终端，输入一长串地址，然后才能到这个目录下，而这中间任何一步都可能阻塞住用户。只有最简单的操作流程，才能高效地解决问题。 但很多时候，用户的问题并不那么简单。看似是 A 除了问题，对比日志后发现 B 也有问题，在 debug B 的过程中发现其依赖于 C。甚至到最后发现这些统统都不是问题所在，用户使用的根本不是你这个软件！这里就陷入了用户给你制造的黑盒。怎么办呢？在现有工具无法保证筛选出正常的反馈时，就得通过作业流程来保证各种类型的 bug 在每个阶段就被精准定位并消灭了。 中医有望闻问切四种基本诊察疾病方法，在针对用户反馈时也可以这么做： 望：根据用户描述，大致判断问题是否属于所属产品，是网络问题还是应用问题。 闻：故障截图、上报日志，分析可能出错的模块，如若遇到误报情形，在这一步即可排除。 问：让用户参与调试，通过改变设置项、清理缓存等步骤以期快速恢复。 切：直接给用户换一个版本（客户端就这点好，不同用户可以用着不同版本），相当于做移植手术了。可以植入更多自定义日志上报功能，更全面地分析用户使用状态，以便根治问题。 知识储备前面讲到了技术应用方向和自我角色扮演，它们都属于外功，也就是技能部分，下面要讲的可说是内功心法。读过武侠小说的人都知道，内外兼修，德才兼备，方可成为一代大师。技巧永远是层出不穷的，只有透过日复一日，年复一年的基础积累，感受技术背后的脉搏，才能融会贯通，成为优秀的开发者。 IPC Node.js addons CI 流水线：蓝盾 Stream CI WebAssembly 模式：图、pub/sub Windows 注册表 心理建设采用最通用的技术，延长更迭周期 控制技术的复杂度 学习新技术的恐慌","link":"/blog/2022/02/10/from-f2e-to-client/"},{"title":"复盘一次 gulp &amp; webpack 构建优化","text":"接续前一篇《并行化密集型计算》，发现实际上线时 parallel terser 并没有提升速度。反而比单线程还要慢，这就有点不科学了。首先想本地跑起来没有出错，大概不是程序逻辑问题，再想想看，估计是配置问题，与 SA 进行了一波有力的交流。 原来 os.cpus() 拿到的是真实的计算机 CPU 核数，而 k8s 会限制容器的 CPU 使用量，所以我们应该手动将 NODE_ENV=production 时的并发数限制在 5 以内。 进一步思考这种 utility 和 business 代码混写在一起的方式极其耦合，想要更高效地发挥代码的作用必须分离它们，于是就借鉴了 terser-webpack-plugin 中对于 jest-worker 的应用改了一下，并将其应用于 webpack 的打包，取得了不错的效果。 1234567891011121314151617gulp.task('webpack', function() { const { result$, next, end } = parallelRunner( __filename, function(worker, configName) { return Promise.resolve( worker.compile( null, [configName] ) ) }, isProduction ? PRODUCTION_PARALLEL_NUMBER : true ) Object.keys(configNameToFileMap).forEach((name) =&gt; next(name)) end() return result$}) 但实际到了线上 webpack 依然花了将近 4 分钟，与此同时 gulp parallel terser 已经稳定在 1 分钟之内了。这时一段异常的日志引起了我的注意。 原来 webpack 里自带的 terser-webpack-plugin 会在 production mode 下自动开启，又是 48 线程 …… 4 * 48 = 192 线程，OMG，不跑崩让 SA 来请喝茶才怪了。但转念一想，好像后面我们还会对各种文件都 terser 一遍，在 webpack 里压缩似乎是没有必要的？于是乎直接禁用 optimization.minimize 就可以了。 期间又优化了一下 parallel-runner，处理了一下 stream/rxjs observable/worker 之间的 back pressure 问题。简单说就是当 rxjs mergeMap 把一个值传到 worker 里去处理时才算作 consumed，会继续向上游 pull 下一个数据，这样就把上下游的数据链接给建立起来了，而不是之前那样全部 pull 下来堆在 mergeMap 外面，容易形成 memory leak。 Call the callback function only when the current file (stream/buffer) is completely consumed. parallel-runner 把 data(vinyl File) 放到 worker 去处理标志该数据为 consumed（实际结果会在 result$ 里被 push 给下游的 writable stream），然后 stream 会根据是否 end 或者到达 highWaterMark 自动去 read(pull) 上游 readable stream 的下一个数据，也就是执行我们传入的 transform 方法。数据可能堆积在 mergeMap 外最多一个，因为那个数据不进入 mergeMap 就不会继续触发 consumed，之前是一口气全 read。 最后，规范化了一下 webpack 出错时向 main process 通报错误的方法，该出错就出错，不要静默失败到上线时出大问题。 1234567891011121314151617181920212223242526return new Promise((resolve, reject) =&gt; { webpack(configs, function(error, stats) { let errors if (stats) { log(stats.toString(Object.assign({ // https://webpack.js.org/configuration/stats/ chunks: false, colors: colors.supportsColor, }, configs[0].stats))) } if (error || stats.hasErrors()) { // errors should be serializable since it will go through processes errors = error ? error.toString() : stats.toJson().errors } if (callback) { callback(errors) } if (errors) { reject(errors) } else { resolve() } })}) 至此，这次优化 gulp &amp; webpack 打包构建流程的优化工作就算告一段落了，实际上大概处理了以下几个问题： 将重复性的任务放到多线程并行执行 提取公共代码转成 utilities 区分本地开发与生产环境，尊重基础设施对于计算资源的分配规则 剔除多余的步骤避免重复计算（侧面说明不要替用户预先做决定的重要性） 向官方推荐实现靠拢，以求符合标准融入开源库的生态环境 下面直接贴出了 parallel-runner 的代码，小弟手艺不佳，写得不好，各位如有需要可以在此基础上稍加改动以适应业务需要。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155// Inspired by terser-webpack-plugin.const os = require('os')const rx = require('rxjs')const rxOperators = require('rxjs/operators')const JestWorker = require('jest-worker').defaultconst through2 = require('through2')const log = require('fancy-log')const { Subject, from } = rxconst { mergeMap, share } = rxOperatorsfunction getAvailableNumberOfCores(parallel) { const cpus = os.cpus() || { length: 1 } return parallel === true ? cpus.length - 1 : Math.min(Number(parallel) || 0, cpus.length - 1)}function parallelRunner( module, taskCallback, parallel = true) { const availableNumberOfCores = getAvailableNumberOfCores(parallel) let concurrency = 1 // which means mergeMap will behave as concatMap let worker let total = 0 let completed = 0 let allScheduled = false log('Parallel Running: ', module) log('Available Number of Cores: ', availableNumberOfCores) // setup worker if (availableNumberOfCores &gt; 0) { const numWorkers = availableNumberOfCores concurrency = numWorkers log('Number of Workers: ', numWorkers) worker = new JestWorker(module, { numWorkers, enableWorkerThreads: true }) const workerStdout = worker.getStdout() if (workerStdout) { workerStdout.on('data', (chunk) =&gt; { return process.stdout.write(chunk) }) } const workerStderr = worker.getStderr() if (workerStderr) { workerStderr.on('data', (chunk) =&gt; { return process.stderr.write(chunk) }) } } // handle concurrency with rxjs const scheduled = new Subject() const consumed = new Subject() const result$ = scheduled.pipe( mergeMap((data) =&gt; { // data is actually consumed here consumed.next(null) // worker[methodName] can only be invoked with serializable data // and returned value could be just plain RESULT or Promise&lt;RESULT&gt; return from(taskCallback(worker || require(module), data)) }, concurrency), share() ) result$.subscribe({ complete: function() { if (worker) { worker.end() } }, next: function() { completed += 1 if (allScheduled &amp;&amp; completed === total) { scheduled.complete() } }, error: function(err) { throw err } }) return { result$, consumed$: consumed.asObservable(), next: (data) =&gt; { scheduled.next(data) total += 1 }, complete: () =&gt; { allScheduled = true } }}function gulpParallelRunner(module, taskCallback, parallel) { const { result$, consumed$, next, complete } = parallelRunner(module, taskCallback, parallel) let afterComplete, stream, afterConsume consumed$.subscribe(() =&gt; { // `afterComplete was defined` means there is no more data if (!afterComplete &amp;&amp; afterConsume) { afterConsume() } }) result$.subscribe({ complete: () =&gt; { if (afterComplete) { afterComplete() } }, next: (data) =&gt; { stream.push(data) // if returned value is false means stream ends or meets highWaterMark // but we don't care since we use rxjs to control concurrency } }) const flush = function(cb) { afterComplete = cb complete() } const transform = function(file, enc, afterTransform) { if (!stream) { stream = this } if (!afterConsume) { afterConsume = afterTransform } next(file) } return through2.obj(transform, flush)}// Staticng has CPU limit of 5 on k8s, so we can't use os.cpus().length which// reports the number of online CPUs, but running with 4 threads is fast enough.// https://github.com/nodejs/node/issues/28762#issuecomment-513730856const PRODUCTION_PARALLEL_NUMBER = 4module.exports = { parallelRunner, gulpParallelRunner, PRODUCTION_PARALLEL_NUMBER,} 实际应用于 terser 的代码 123456789101112131415161718function parallelTerser(needMangle) { const options = generateTerserOptions(needMangle) return gulpParallelRunner( require.resolve('terser'), function(worker, file) { return Promise.resolve(worker.minify({ [file.path]: file.contents.toString('utf-8') }, options)).then((result) =&gt; { if ('error' in result) { throw new Error(result.error.message) } file.contents = 'from' in Buffer ? Buffer.from(result.code) : new Buffer(result.code) return file }) }, isProduction ? PRODUCTION_PARALLEL_NUMBER : true )}","link":"/blog/2020/06/05/parallel-computing-review/"},{"title":"面试小结","text":"算法题全排列 实现二维数组的全排列 12345678910// 如输入[[1,2],[3,4],[5,6]]// 输出：// [ 1, 3, 5 ]// [ 1, 3, 6 ]// [ 1, 4, 5 ]// [ 1, 4, 6 ]// [ 2, 3, 5 ]// [ 2, 3, 6 ]// [ 2, 4, 5 ]// [ 2, 4, 6 ] 思路：最后需要得到一个二维数组，那基本都是 reduce 操作的话也应该是一个二维数组开头，每一次都把前一次结果得到的数组们尾部分别加上二维数组里的一项，也就是 m * n * [...prevResultList[i], list[j]]，其中 m 和 n 分别是 prevResultList 和 list 的项数，这样也就成功实现了 m × n 的项数膨胀，至于降维操作我们有 flatMap 这个神器。面试时用了很丑陋的 reduce + map 嵌套，甚至还忘了把数组摊平…… 12345function arrange(doubleList) { return doubleList.reduce((prevResultList, list) =&gt; { return prevResultList.flatMap((result) =&gt; list.map((v) =&gt; result.concat(v))) }, [[]])} 随机自然数组 1~1000 范围内生成长度为 1000 的随机不重复自然数数组，并验证 思路：这道题也是老生常谈了，直接暴力一点 sort(() =&gt; Math.random() &gt; 0.5) 解之，80% 的面试官都会眼前一愣，心想算了算了投机取巧的家伙，但有一个面试官对此质疑了很久，想了想也是，sort 的内部实现并不稳定，而且每次排出来结果不一致不知道性能有没有问题，还是要把随机数稳定下来。 1234567891011121314function generateRandomInter(n) { const list = Array(n).fill(0).map((v, i) =&gt; [i + 1, Math.random()]) list.sort((a, b) =&gt; a[1] - b[1]) return list.map((v) =&gt; v[0])}function validateResult(result, n) { const uniqList = Array.from(new Set(result)) return uniqList.length === n}const result = generateRandomInter(1000)console.log(result)console.log(validateResult(result, 1000)) 去重 用 es5 实现数组去重？[1, 2, 3, true, '2'] 思路：没啥思路，就老老实实遍历再挨个取 indexOf？最后面试官给出了 typeof 的解法，真是…… 123456789101112function unique(list) { const cacheMap = {} return list.reduce((acc, v) =&gt; { const key = typeof v + v if (cacheMap[key]) { return acc } else { cacheMap[key] = true return acc.concat(v) } }, [])} 合并有序数组（链表？）思路：简单来说维护两个 head，每次取一个值插入新数组后就步进一次，然后两者其中一个 head 到达底部后一次性将另一个数组剩余元素灌到新数组里。面试官问还有没有高效一点的方案，就用了 Symbol.iterator 理论上会高效一点？ 123456789101112131415161718192021222324252627function mergeList(list1, list2) { let result = [] const iterator1 = list1[Symbol.iterator]() const iterator2 = list2[Symbol.iterator]() let head1 = iterator1.next() let head2 = iterator2.next() while (!head1.done &amp;&amp; !head2.done) { const value1 = head1.value const value2 = head2.value if (value1 &lt;= value2) { result.push(value1) head1 = iterator1.next() } else { result.push(value2) head2 = iterator2.next() } } if (!head1.done) { result = [...result, head1.value, ...iterator1] } if (!head2.done) { result = [...result, head2.value, ...iterator2] } return result}console.log(mergeList([1, 2], [1, 2, 3])) 判断二叉树镜像 给定一个二叉树，判断是否为镜像 1 2 2 3 4 4 3 1 2 2 3 3 思路：跟判断两颗二叉树是否相同区别不大，面试时采用了简单粗暴的分层比较法，空间复杂度达到了 2 ** n …… 😂 1234567891011121314151617181920212223function checkMirror(roots) { const len = roots.length let isAllNull = true const doesRootsEqual = roots.every((root, i) =&gt; { if (root) { isAllNull = false } const oppositeRoot = roots[len - 1 - i] return (root &amp;&amp; root.val) === (oppositeRoot &amp;&amp; oppositeRoot.val) }) if (!doesRootsEqual) { return false } if (isAllNull) { return true } const nextRoots = roots.flatMap((r) =&gt; r ? [r.left, r.right] : [null, null]) return checkMirror(nextRoots)}const root = { val: 1, left: { val: 2, left: { val: 3}, right: { val: 4, left: { val: 2}}}, right: { val: 2, left: { val: 4, right: { val: 2}}, right: { val: 3}}}console.log(checkMirror([root])) 工程题控制 Promise 并发 [promise] 123dispatch(arr, n) { } 思路：肯定要用 Promise.race，然后如果要阻塞的话还需要是 async/await 写法。这道题其实还是算一般的，后面写个 Scheduler 就痛苦了。 1234567891011121314151617181920212223const promises = Array(10).fill(0).map((v, i) =&gt; ( new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(i), i * 1000 + 1000)).then(console.log)))async function dispatch(list, n) { const total = list.length let pending = [] let completed = 0 while(completed &lt; total &amp;&amp; list.length) { const moreCount = n - pending.length Array(moreCount).fill(0).forEach(() =&gt; { const p = list.shift() .catch(() =&gt; {}) .then(() =&gt; pending = pending.filter(v =&gt; v !== p)) pending.push(p) }) console.log('len: ', pending.length) await Promise.race(pending) completed += 1 }}dispatch(promises, 3) 实现异步调度器12345678910111213141516171819class Scheduler { async add(promiseFunc: () =&gt; Promise&lt;void&gt;): Promise&lt;void&gt; { }}const scheduler = new Scheduler()const timeout = (time) =&gt; { return new Promise(r =&gt; setTimeout(r, time))}const addTask = (time, order) =&gt; { scheduler.add(() =&gt; timeout(time)) .then(() =&gt; console.log(order))}addTask(1000, 1)addTask(500, 2)addTask(300, 3)addTask(400, 4)// log: 2 3 1 4 思路：一开始看到这题还有些欣喜，似曾相识的感觉，但实际一做发现不是这样，需要直接在 add 方法后返回一个 Promise，面试时没有写出有效解，事后想想还是能写出个解的，就是实现比较丑陋 …… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849type promiseFuncType = () =&gt; Promise&lt;void&gt;class Scheduler { pending: Array&lt;[promiseFuncType, () =&gt; void]&gt; running: Array&lt;Promise&lt;void&gt;&gt; CONCURRENCY = 2 constructor() { this.pending = [] this.running = [] } async add(promiseFunc: promiseFuncType): Promise&lt;void&gt; { const pending = new Promise&lt;void&gt;((r) =&gt; { this.pending.push([promiseFunc, r]) }) this.execute() return pending } execute = () =&gt; { let restNum = this.CONCURRENCY - this.running.length if (this.running.length === 0 &amp;&amp; this.pending.length === 0) { return } while (restNum &gt; 0 &amp;&amp; this.pending.length) { const [promiseFunc, callback] = this.pending.shift() const prom = promiseFunc().then(() =&gt; { this.running = this.running.filter(p =&gt; p !== prom) callback() }) this.running.push(prom) restNum -= 1 } Promise.race(this.running).then(this.execute) }}const scheduler = new Scheduler()const timeout: (number) =&gt; Promise&lt;void&gt; = (time) =&gt; { return new Promise(r =&gt; setTimeout(r, time))}const addTask = (time, order) =&gt; { scheduler.add(() =&gt; timeout(time)) .then(() =&gt; console.log(order))}addTask(1000, 1)addTask(500, 2)addTask(300, 3)addTask(400, 4) 实现 Observable思路：观察者和迭代器，需要理解 Observable 和 Observer，才疏学浅，没有 get 到精髓，此题仍为 WIP 状态。 12345678910111213141516171819202122232425262728293031323334353637383940const arr = [1, 2, 3]function Observable() { this.uid = 0 this.subscribers = {} this.onSubscribe = null}Observable.from = function(array) { const observable = new Observable() observable.onSubscribe = (observer) =&gt; { array.forEach((v) =&gt; observer.next(v)) observer.complete() } return observable}Observable.prototype.subscribe = function(observer) { const id = this.id++ this.subscribers[id] = observer if (this.onSubscribe) { this.onSubscribe(observer) } return { unsubscribe: () =&gt; { this.subscribers[id] = null console.log('unsubscribe') } }} const arr$ = Observable.from(arr)const subscriber = arr$.subscribe({ next: console.log, complete: () =&gt; console.log('complete'), error: console.error,})subscriber.unsubscribe() 口答知识点 HTML 一点都没问，CSS 就问了简单九宫格 header/nav/main 布局以及垂直居中等，说明组件化已经深入人心，高级前端基本没有写样式的部分了 简历里写到了 Gulp/Webpack 相关，所以被问了很多次 Webpack Loader/Plugin + Gulp plugin 开发 😂 像我这么水当然是只能扯扯从一个 File 到另一个 File 输出这样子的 TypeScript 和 GraphQL 也被问了很多次，TypeScript 如何实现类型推导（Pick, Omit)，interface 和 type 区别，GraphQL 解决什么问题 React 相关：hooks 生命周期，fiber 是啥，setState 到渲染发生了什么 …… 深拷贝也是问了无数次，直接 lodash.cloneDeep 它不香么 😂 当然有些比如循环引用，class instance 等也是要注意的 macroTask/microTask：一个 macroTask 多个 microTask，microTask-in-microTask 继续排队，Promise((r) =&gt; …) … 是 macroTask HTTPS 如何加密通讯过程、Server/Client Hello + 校验证书合法性 + 三次生成随机字符串 + RSA 非对称加密 + 约定密钥对称加密 / 浏览器缓存有哪些字段 / WebSocket 做了啥 / SSO：在第三方 Cookie 无法读取情形下怎么办？（OS：我也很无奈啊）/ script async defer 具体怎么 load 最复杂、最有挑战性的项目经历：复杂筛选器 + GraphQL 应用，小程序解析 nodes 图文混排，原生端通讯 + 跨端开发联调 最感兴趣的方向：富文本渲染与编辑、GIS 系统以及 WebAssembly 相关","link":"/blog/2020/06/24/interview-summary/"},{"title":"初探 Node.js 原生扩展模块","text":"最近因项目需要开始研究 Node.js 原生模块的实现，并尝试接入自研 C++ 模块。Node.js 因其具有良好的跨平台适配性和非阻塞事件循环的特点，受到了服务端开发者的关注，但 JavaScript 毕竟基于 GC 实现的数据结构，在高性能计算上有所不足；而且很多老代码或者扩展库都以 C++ 书写，也给移植编译带来了一定的困难。如何在性能、兼容性和开发效率上取得平衡，为了解决这些个问题，让我们开始书写第一个 Node.js C++ addon 吧！ C++ addons 的原理不管你看哪个教程（其实中文书也就一本，就是死月这本《Node.js：来一打 C++ 扩展》），提到 Node.js 一上来就是 V8 Isolate, Context, Handle, Scope 讲一堆，看完这两百页头已经晕了。这些都是非常基础的 V8 知识，但离实际运用还隔了很远。为了写出 C++ addons，我们只要抓住一点 ———— “JavaScript 对象就是一个个 V8 C++ 对象的映射”。 V8 上图是 JS 里一个简单 String 的继承关系，如何创建一个简单的字符串呢？String::NewFromUtf8(isolate, &quot;hello&quot;).ToLocalChecked()，是不是看了有些头大？如果告诉你这种继承关系随着 V8 的升级经常发生变化，是不是感觉血压都高了？ 没错，这就是上古时期 Node.js C++ addons 的开发方式，需要指定 Node.js 的版本进行编译，只有在指定 ABI 的版本下才能运行。 https://nodejs.org/api/addons.html#hello-world ，有兴趣的读者可以阅读下 Node.js 官网对于 C++ addons 的简易劝退教程，里面展示了不少早期 Node.js 开发者与 C++ 对象搏斗的真实记录。 兼容性在经历了刀耕火种的日子后，盼星星盼月亮终于迎来了 Node.js 的原生抽象 —— N-API。它利用宏封装了不同 V8 版本之间的 API 差异，统一暴露了多种识别、创建、修改 JS 对象的方法。让我们来看看如何创建一个字符串呢？ 1234#include &lt;node_api.h&gt;napi_value js_str;napi_create_string_utf8(env, &quot;hello&quot;, NAPI_AUTO_LENGTH, &amp;js_str); 哎~ 怎么看起来也不是很简单嘛？。。。 别骂了，别骂了，要知道 Node.js 为了兼容不同版本付出了多大的努力吗？相对来说上述的 API 调用算是很简单的了，最重要的是它很稳定，基本不随着 Node.js 和 V8 的版本更迭而变化。env 是执行的上下文，js_str 是创建出来的 JS 字符串，NAPI_AUTO_LENGTH 是自动计算的长度，这里还隐含了一个变量，就是 napi_create_string_utf8 的返回值 napi_status，这个值一般平平无奇，但万一要是出了 bug 就得靠它来甄别各处调用是否成功了。 C++ addons 实战前情铺垫结束，让我们拥抱改变吧。下面将带大家以一个简单的 Defer 模块的实现为例，走马观花式感受 C++ addons 的开发过程。 初始化项目首先你得有个 Node.js，版本呢最好能到 14、16 以上，因为 N-API 有些部分在 14 的时候才加入或者稳定下来。 然后你得准备个 C++ 编译环境，下面简单介绍下各个系统下是如何操作的。 macOS: xcode-select --install 基本可以解决，后面会用 llvm 进行编译。 Windows: 啥都别说了，VS 大法好。推荐装 2019 Community 即可，然后记得把 v142 工具集装了就成。因为 node-gyp 会写死 VS 的版本号，所以如果出了问题就使用 VS installer 继续安装缺失的组件即可。 Linux: apt-get install gcc. 这样就准备好正式编译我们的 C++ addons 了。 node-gyp通常情况下编译并链接 C++ 库是一件非常吃力不讨好的事，cmake 等工具的出现就是为了解决这个问题，而到了 Node.js 这一边，官方提供了同样的工具 node-gyp。只需 npm i node-gyp -g 即可，后续我们都将在 node-gyp 下操作。 VS Code 相关设置我们可以在 VS Code 中设置 C++ 环境，这会给开发带来不少的体验提升。https://code.visualstudio.com/docs/languages/cpp 这里是一份可参考的 .vscode/c_cpp_properties.json 示例： 123456789101112131415161718192021222324252627282930313233343536373839{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Mac&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot;, &quot;/usr/local/include/node&quot; ], &quot;defines&quot;: [], &quot;macFrameworkPath&quot;: [ &quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks&quot;, &quot;/System/Library/Frameworks&quot;, &quot;/Library/Frameworks&quot; ], &quot;compilerPath&quot;: &quot;/usr/bin/clang&quot;, &quot;cStandard&quot;: &quot;c17&quot;, &quot;cppStandard&quot;: &quot;c++14&quot;, &quot;intelliSenseMode&quot;: &quot;macos-clang-x63&quot; }, { &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot;, &quot;C:\\\\Users\\\\kimi\\\\AppData\\\\Local\\\\node-gyp\\\\Cache\\\\16.6.0\\\\include\\\\node&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;windowsSdkVersion&quot;: &quot;10.0.17763.0&quot;, &quot;compilerPath&quot;: &quot;C:/Program Files (x86)/Microsoft Visual Studio/2017/Community/VC/Tools/MSVC/14.16.27023/bin/Hostx64/x64/cl.exe&quot;, &quot;cStandard&quot;: &quot;c17&quot;, &quot;cppStandard&quot;: &quot;c++14&quot;, &quot;intelliSenseMode&quot;: &quot;windows-msvc-x64&quot; } ], &quot;version&quot;: 4} 这段 JSON 最重要的就是要指向 node 头文件的 includePath，上面分别提供了当前 Node.js 安装版本和 node-gyp 缓存的路径，以供参考。 Hello world凡事怎么少得了 hello world 呢？这里假设你已经装好了 node-gyp 了。 先创建一个 main.cpp，写入以下内容。 12345678910#include &lt;node_api.h&gt;napi_value Init(napi_env env, napi_value exports){ napi_value hello_str; napi_create_string_utf8(env, &quot;hello&quot;, NAPI_AUTO_LENGTH, &amp;hello_str); napi_set_property(env, exports, hello_str, hello_str); return exports;}NAPI_MODULE(NODE_GYP_MODULE_NAME, Init) 创建一个 binding.gyp，写入以下内容。 12345678{ &quot;targets&quot;: [ { &quot;target_name&quot;: &quot;native&quot;, &quot;sources&quot;: [&quot;./main.cpp&quot;], } ]} 然后执行 npx node-gyp configure build，不出意外的话会生成一个 build 目录，build/Release/native.node 就是我们所要的货了。 如何使用呢？很简单，打开 Node.js REPL，直接 require 就行。 1234Welcome to Node.js v16.6.0.Type &quot;.help&quot; for more information.&gt; require('./build/Release/native').hello&lt; 'hello' 大功告成！ 小试牛刀：开发一个简单的 Defer 模块在学习新知识点时，以熟悉的概念切入会更有学下去的动力。我们就小试牛刀，先实现一个非常非常简陋只支持一个 Promise 调用的 Defer 模块吧！ 先让我们看一下最终需要的调用方式，从 JS 侧看就是加载一个 *.node 的原生模块，然后 new 了一个对象出来，最后调用一下它的 run 方法。可能 JS 写起来 10 行都不到，但这次的目标是将 C++ 与 JS 联动，这中间的过程就有点让人摸不着头脑了。 别慌，遇事不决先确定接口类型，类型就是编程中的量纲，分析量纲就能得出解题思路。 JS 接口类型定义抛开语言的差异，来分析一下这个 Deferred 类，它的构造函数接受一个字符串进行初始化，然后有个 public 的 run 方法接受一个数字并返回一个 Promise，以这个数字所代表的毫秒数来延迟 resolve 所返回的 Promise。 1234class Deferred { constructor(private name: string) public run(delay: number): Promise&lt;string&gt;} 咦，这么简单吗？是的，JS 本就为了开发效率而生，但事情整到 C++ 层面可就不那么简单了 …… 但天下大事，必作于细，良好的职责划分有利于用不同的工具切准要害，逐个突破，我们接着往下看。 划分 C++ 与 JavaScript 职责 为了 OOP，我们将数据和行为都存放在一起，这会带来一些问题，就是数据该由谁持有？如果 JS 持有数据，将 C++ 作为一个无状态的服务，每次都将数据从 JS 传过来，计算完了传回去，但这样会造成序列化的开销。如果 C++ 持有数据，JS 侧就相当于一个代理，只是把用户请求代理到 C++ 这一边，计算完再转发给用户侧。 实际情况是，一旦涉及到原生调用，C++ 持有的数据很有可能是 JS 处理不了的不可序列化数据，比如二进制的文件，线程 / IO 信息等等，所以还是 C++ 做主导，JS 只做接口比较好。但这样就不可避免地要从 C++ CRUD 一些 JS 对象了，接着往下走。 创建 C++ 类激动的心，颤抖的手，终于开始写 C++ 代码了 …… 老规矩，还是先定义一个 class 吧。 1234567891011#include &lt;string&gt;#include &lt;functional&gt;#include &lt;node_api.h&gt;class NativeDeferred { public: NativeDeferred(char *str); void run(int milliseconds, std::function&lt;void(char *str)&gt; complete); private: char *_str;}; 看起来和 JS 侧的代码也很像嘛，只不过换成了 callback 的方式。如何使它能在 JS 侧使用呢？ 创建 JS class N-API 提供了各种直接创建 JS 对象的方法，包括字符串、数字、undefined 等基本量，也有函数和对象等等。擒贼先擒王，一上来就找到了用于创建 class 的 napi_define_class。读了一遍定义后，发现需要提供 napi_callback constructor 和 const napi_property_descriptor* properties 作为参数。又马不停蹄地找到了 napi_callback，这个函数是我们后面会经常遇到的。 napi_callback 接受一个 napi_env 和 napi_callback_info，前者是创建 JS 对象所必须的环境信息，而后者是 JS 传入的信息。 如何解读这些信息呢？有 napi_get_cb_info 这个方法。通过它可以读出包括 this 和各种 ArrayLike 的参数。 我们在讨论如何创建一个 JS 的 class 啊，这是不是绕太远了？等等，你提到了 this？有的面试题里会考如何手写一个 Object.create，难道这就是那里面默认的 this？你猜对了，这个 this 在通过 Function 创建时，在构造器里是用 v8 的 ObjectTemplate 来实例化一个 instance 的。（PS: 如果 napi_callback 是从 JS 侧调用，那它就是 JS 的那个 this。） 从 JS class 创建对象的话，这个 napi_callback 就是 JS 定义的 constructor，执行完返回 this 就行了，但既然是深度融合 C++ 的功能，我们当然还有别的事要做。 将 C++ 对象封装到 JS instance 上前面声明了一个非常简易的 C++ 对象 NativeDeferred，我们要将它封装到刚创建的 this 上，返回给 JS 侧。为啥要这样做？因为前面提到了，我们要用 C++ 对象持有一些数据和状态，这些不便于在 JS 和 C++ 来回传递的数据需要一个可追溯的容器来承载（即 NativeDeferred），我们可以假设这个容器有两种存储方式： 全局对象，也就是 V8 里的 global，然后生成一个 key 给 JS instance。 挂到 JS instance 上（N-API 支持这种操作）。 很明显第一种方法不仅污染了全局对象，也避免不了 JS instance 需要持有一个值，那还不如直接把 C++ 对象绑到它上面。 取出 C++ 对象的过程形成了 napi_callback -&gt; JS Deferred(this) -&gt; unwrap C++ NativeDeferred 这样一个线路，需要用到 napi_wrap 和 napi_unwrap 方法。 这里又有个坑，finalize_cb 是必须要赋值的，而且它应该去调用 NativeDeferred 的析构函数。 123456789101112131415static void Destructor(napi_env env, void *instance_ptr, void * /*finalize_hint*/){ reinterpret_cast&lt;NativeDeferred *&gt;(instance_ptr)-&gt;~NativeDeferred();}napi_value js_constructor(napi_env env, napi_callback_info info){ // 中间省略了获取 js_this 和 name 的步骤 NativeDeferred *deferred = new NativeDeferred(name); napi_wrap(env, js_this, reinterpret_cast&lt;void *&gt;(deferred), Destructor, nullptr, nullptr); return js_this;} 这样，我们就设置好了一个在 constructor 里会生成并自动绑定 C++ 对象的 JS class。 设置 JS class 上的调用方法数据只有实际被使用才能发挥其价值，对应到 JS Deferred 上面，就是要让 JS 侧 run 方法顺利地调用到 C++ 侧的 run，这里面又要经历前面所说的从 napi_callback 一直到拿到原生 NativeDeferred 的过程，但如何让这个 napi_callback 可以被 Deferred 实例后的对象应用呢？ 聪明的读者已经猜到了，就是将它设到 Deferred 这个类的原型链上，具体来说就是前面 napi_define_class 时的 const napi_property_descriptor* properties，我们来看一下它的定义。 napi_property_descriptor 上其他属性都比较常见，似乎跟 Object.defineProperty 有些相似，但 enumerable 和 configurable 这些值呢？。我们注意到了 napi_property_attributes 这个参数， 找到了找到了，这就是我们需要的属性了。 123456789#include&lt;node_api.h&gt;napi_property_descriptor runDesc = {&quot;run&quot;, 0, js_run, 0, 0, 0, napi_default_method, 0};napi_value js_class;napi_property_descriptor descs[1] = {runDesc};napi_define_class(env, &quot;Deferrered&quot;, NAPI_AUTO_LENGTH, js_constructor, nullptr, 1, descs, &amp;js_class); *js_run 会在下一节实现。 上面的 js_class 就是我们一开始定义的 JS Deferred 了，将他 napi_set_property 到 hello world 中的 exports 上就能被 Node.js 访问啦。 这里还有个坑，napi_default_method 有些版本下是被定义在 if 里的，需要我们预先 define NAPI_VERSION 或者 NAPI_EXPERIMENTAL。 让我们打开 binding.gyp，在 target 里加入以下内容，就可以啦。 123456{ &quot;defines&quot;: [ &quot;NAPI_EXPERIMENTAL&quot;, &quot;NAPI_VERSION=8&quot;, ],} C++ 回调 JS callback到现在我们已经实现了一个 class 所需要的一切能力，但有个小问题：这些方法都是单向的从 JS 侧传递给 C++ 侧，或者反之，没有双向交互的部分。可以想一想怎样算是“双向交互”呢？就是 Node.js 常见的 callback 啊，我们还没有涉及到如何从 C++ 调用 JS 函数。napi_call_function这个函数就是 napi_get_cb_info 的逆操作了，把参数按个数和数组传递给函数指针。 示例代码： 12345678910111213// 将这个函数 export 出去，使用时会以传入的第一个参数 args[0]，判定其为函数传入 42 作为唯一参数进行调用napi_value fire_js_callback(napi_env env, napi_callback_info info) { napi_value js_this; napi_value args[1]; size_t argc = 1; napi_get_cb_info(env, info, &amp;argc, args, &amp;js_this, nullptr); napi_value num; napi_create_int32(env, 42, &amp;num); napi_value res[1] = { num }; napi_call_function(env, js_this, args[0], 1, res, nullptr); return num;} 总结一下，我们目前总共实现了以下的 C++ addon 能力。 功能 实现 创建 JS class ✅ 给 JS class 添加 method ✅ 将 C++ 对象封装到 JS 对象上 ✅ 调用 JS 函数 ✅ 高级技巧读到这里的朋友可能发现了，前面提到的 Deferred 还有一环没有实现，就是延时调用。来想一下 C++ 里如何能延时呢？可以另外启动一个线程，将它 sleep，可以简单写下代码。 1234567891011121314151617181920212223242526#include &lt;node_api.h&gt;#include &lt;thread&gt;#include &lt;functional&gt;static void thread_run(std::function&lt;void()&gt; complete) { std::this_thread::sleep_for(std::chrono::milliseconds(1000)); complete();}napi_value fire_js_callback(napi_env env, napi_callback_info info) { napi_value js_this; napi_value args[1]; size_t argc = 1; napi_get_cb_info(env, info, &amp;argc, args, &amp;js_this, nullptr); napi_value num; napi_create_int32(env, 42, &amp;num); napi_value res[1] = { num }; std::function&lt;void()&gt; complete = [=]() { napi_call_function(env, js_this, args[0], 1, res, nullptr); }; std::thread runner(thread_run, complete); runner.detach(); return num;} 但实际调用时，等了很久也没有触发，这是为什么呢？ JavaScript functions can normally only be called from a native addon’s main thread. If an addon creates additional threads, then Node-API functions that require a napi_env, napi_value, or napi_ref must not be called from those threads. When an addon has additional threads and JavaScript functions need to be invoked based on the processing completed by those threads, those threads must communicate with the addon’s main thread so that the main thread can invoke the JavaScript function on their behalf. The thread-safe function APIs provide an easy way to do this. Asynchronous thread-safe function calls 原来跨线程之后 napi_env 就不是原来的那个它了，我们需要按照 N-API 的方式来包装一下异步调用的函数。 线程安全调用写到这里，笔者发现自己的功力已经不足以解释我所看到的文档了，直接上代码吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;node_api.h&gt;#include &lt;thread&gt;#include &lt;functional&gt;static void thread_run(std::function&lt;void()&gt; complete) { std::this_thread::sleep_for(std::chrono::milliseconds(1000)); complete();}static void thread_callback(napi_env env, napi_value js_callback, void* context, void* data) { napi_value js_this = reinterpret_cast&lt;napi_value&gt;(context); napi_value num; napi_create_int32(env, 42, &amp;num); napi_value res[1] = { num }; napi_call_function(env, js_this, js_callback, 1, res, nullptr);}napi_value fire_js_callback(napi_env env, napi_callback_info info) { napi_value js_this; napi_value args[1]; size_t argc = 1; napi_get_cb_info(env, info, &amp;argc, args, &amp;js_this, nullptr); napi_value async_resource_name; napi_create_string_utf8(env, &quot;foobar&quot;, NAPI_AUTO_LENGTH, &amp;async_resource_name); napi_threadsafe_function thread_complete; // 将 js 传来的 callback 调谐函数 thread_callback 一起传入生成线程安全的回调 napi_create_threadsafe_function( env, args[0], nullptr, async_resource_name, 0, 1, nullptr, nullptr, js_this, thread_callback, &amp;thread_complete); // 将线程安全的回调再包装成闭包 std::function&lt;void()&gt; complete = [=]() { napi_call_threadsafe_function(thread_complete, nullptr, napi_tsfn_blocking); }; // 真正放到另一个线程去执行 std::thread runner(thread_run, complete); runner.detach(); return js_this;}napi_value Init(napi_env env, napi_value exports){ napi_value fire_str; napi_create_string_utf8(env, &quot;fire&quot;, NAPI_AUTO_LENGTH, &amp;fire_str); napi_value fire; napi_create_function(env, &quot;fire&quot;, NAPI_AUTO_LENGTH, fire_js_callback, nullptr, &amp;fire); napi_set_property(env, exports, fire_str, fire); return exports;}NAPI_MODULE(NODE_GYP_MODULE_NAME, Init) 经过一番眼花缭乱的操作后，终于成功触发了 args[0] 处的 JS callback 函数，这就是简化版本的 js_run 了。 Promise 的实现既然实现了异步回调，我们再努力一把，实现 Promise 的返回值，这就比较简单了，N-API 将 napi_create_promise 设计为生成 napi_deferred* deferred 和 napi_value* promise，一式两份，一份直接返回给 JS，一份则留着在异步调用中将其 resolve。我们只需稍微改写一下前面的代码即可。 12345678910111213141516171819202122232425262728293031323334353637static void thread_callback(napi_env env, napi_value js_callback, void* context, void* data) { napi_deferred deferred = reinterpret_cast&lt;napi_deferred&gt;(data); napi_value num; napi_create_int32(env, 42, &amp;num); napi_resolve_deferred(env, deferred, num);}napi_value fire_js_callback(napi_env env, napi_callback_info info) { napi_value js_this; size_t argc = 0; napi_get_cb_info(env, info, &amp;argc, nullptr, &amp;js_this, nullptr); napi_value async_resource_name; napi_create_string_utf8(env, &quot;foobar&quot;, NAPI_AUTO_LENGTH, &amp;async_resource_name); napi_threadsafe_function thread_complete; // 将 js 传来的 callback 调谐函数 thread_callback 一起传入生成线程安全的回调 napi_create_threadsafe_function( env, nullptr, nullptr, async_resource_name, 0, 1, nullptr, nullptr, nullptr, thread_callback, &amp;thread_complete); napi_value promise; napi_deferred deferred; napi_create_promise(env, &amp;deferred, &amp;promise); // 将线程安全的回调再包装成闭包 std::function&lt;void()&gt; complete = [=]() { napi_call_threadsafe_function(thread_complete, deferred, napi_tsfn_blocking); }; // 真正放到另一个线程去执行 std::thread runner(thread_run, complete); runner.detach(); return promise;} 篇幅起见，只贴出关键的两个函数了。 完工事已至此，与 Deferred 这个类相关的代码已经基本介绍完了，完整的代码可以参见这个仓库：https://github.com/msyfls123/basin 启动工程应该只需要： 1234npm inpm run configurenpx node-gyp rebuild --debugnpm run basin C++ addons 调试与构建别看前面洋洋洒洒一堆操作，只写出了百来行代码，基本每行代码都踩过坑。这时候强有效的调试工具就显得非常重要了。 VSCode CodeLLDB 调试推荐大杀器 CodeLLDB，配合 launch.json 食用，可在 VSCode 中左侧 Run and Debug 里对 C++ 代码断点并显示变量信息。 简易 launch.json 12345678910111213{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;debug with build&quot;, &quot;type&quot;: &quot;lldb&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;preLaunchTask&quot;: &quot;npm: build&quot;, &quot;program&quot;: &quot;node&quot;, &quot;args&quot;: [&quot;${workspaceFolder}/index.js&quot;] }, ]} prebuildify 预构建包前面都是开发模式，如果是服务端使用的话，加上入口 js 文件后已经可以作为 npm 包发布了，安装时会自动执行 node-gyp rebuild 重新构建的。但如果是嵌入到某个 App，比如腾讯文档桌面端，或是 QQ 之类的客户端应用里，那就需要根据不同的系统和架构进行跨平台编译了。 常见架构有： Linux: x64, armv6, armv7, arm64 Windows: x32, x64, arm64 macOS: x64, arm64 竟然有这么多 …… 还好社区提供了跨平台编译的解决方案 ———— prebuild，但它需要在安装时下载对应的包，所以还需要将这些构建产物发布到服务器上，不与 npm 包放在一起。虽然在包体积很大的情况下的确有必要，这显然不是我们所追求的一键下载。 然后我就找到了 prebuildify。它是这么说的： With prebuildify, all prebuilt binaries are shipped inside the package that is published to npm, which means there’s no need for a separate download step like you find in prebuild. The irony of this approach is that it is faster to download all prebuilt binaries for every platform when they are bundled than it is to download a single prebuilt binary as an install script. Always use prebuildify –@mafintosh 有没有成功案例呢？有，那就是 Google 出品的 LevelDB 的 js 封装就是它做的， 我们项目里也应用了这个方案，参见 https://github.com/msyfls123/basin/blob/main/package.json#L16-L18。 与 CI 集成可是这虽然可以只在三个系统各执行一遍进行编译，但每次发布都得登录三台机器来执行吗？no, no, no, 我们当然可以将这一切集成到 CI 中自动运行。 这里展示一下业界标杆 ———— GitHub Actions 的配置: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051name: Buildon: pushjobs: build: runs-on: ${{ matrix.platform.runner }} env: CXX: g++ strategy: matrix: platform: [ { runner: &quot;windows-latest&quot;, command: &quot;build:windows&quot; }, { runner: &quot;macos-latest&quot;, command: &quot;build:mac&quot; }, { runner: &quot;ubuntu-latest&quot;, command: &quot;build:linux&quot; }, ] fail-fast: false steps: - name: Check out Git repository uses: actions/checkout@v2 - name: Set up GCC uses: egor-tensin/setup-gcc@v1 with: version: latest platform: x64 if: ${{ matrix.platform.runner == 'ubuntu-latest' }} - name: Install Node.js, NPM and Yarn uses: actions/setup-node@v2 with: node-version: &quot;16.6.1&quot; - name: Install Dependencies run: | npm i --ignore-scripts - name: Compile run: | npm run configure npm run ${{ matrix.platform.command }} - name: Archive debug artifacts uses: actions/upload-artifact@v2 with: name: build path: | index.js index.d.ts package.json prebuilds/ C++ addons 的展望至此，本文也要进入尾声了，期望能对想要提升 Node.js 程序性能或是拓展应用场景的你带来一些帮助！最后提两点展望吧： 无痛集成第三方库笔者看到项目里大部分第三方 C++ 库都是以源码形式引入的 …… 对于习惯 npm i 的人来说这肯定是像狗皮膏药一样贴在心上。听说 bazel 挺香，但其语法令人望而却步，似乎也不是一个依赖管理工具，这时有个叫 Conan 的货映入眼帘。 这里有篇文章讲述如何将 Conan 和你的 Node.js addons 结合，笔者试了一下确实可行，甚至都不需要 python 的 virtualenv，只是 libraries 需要小小的调整下： 123'libraries': [ &quot;-Wl,-rpath,@loader_path/&quot;] 编译目标：WebAssembly Interface？居安思危，笔者也思考了下 Node.js addons 的局限性，需要每个平台都编译一遍还是有点麻烦的，有没有什么办法可以 compile once, run everywhere 呢？ 有！那就是 WebAssembly，“那你为啥不用呢？”，这是个好问题。LevelDB 仓库内也有过类似的讨论，最后问题落到了性能和文件系统上，如果涉及到异步线程问题的话，会更复杂一点，因为 emcc 的 pthread 是基于 Web Worker 提供的，不清楚 Node.js 侧是否有 polyfill，以及在不同 Worker 运行，各种同步原语、Arc、Mutex 等是否都得到了支持，这些都是未知的。所以遇到一坨祖传下来打满了补丁的 C++ 代码，我们选择的稳妥方式依然是悄悄关上门，然后建座桥，把路直接修到它门口就跑，真刺激啊……","link":"/blog/2021/12/05/node-native-addons/"},{"title":"格式化与验证","text":"众所周知，前端很大程度上就是做数据的展示和收集工作，这时候用户看到的内容和服务端存储的数据中间就会有多层转换过程。 钱最重要的当然是 money 啦，相差一分钱都能让用户急得哇哇大叫。比如业务里有三种价格： fixed_price 原价 promotion_price 特价，一般为 fixed_price * promotion.discount vip_price 会员价，一般为 fixed_price * vip.discount，可能为空 经常出现的情形时既要显示折扣（discount）又要显示价格（promotion_price or vip_price），可不可以直接返回 fixed_price 和 discount 呢？不可以！细心的读者已经觉察到问题了 —— discount 为小数，fixed_price 与其相乘很可能不是一个整数（这里要插一句，一般情况下价格都是记录为 int，以 cent 作为单位）。比如臭名昭著的 JavaScript 浮点数相加问题。 1234&gt; 0.1 + 0.2&lt; 0.30000000000000004&gt; 0.1 + 0.2 === 0.3&lt; false 原因就是 float 在计算机里存了 32 位，1 位符号位 + 8 位指数位 + 23 位尾数，反正就是不精确就完事了。那我们即使不精确也要保证各处拿到的是一个值，这个值只能以后端为准。 123456789@propertydef promotion_price(self): promotion = self.get_active_promotion() if not promotion: return self.fixed_price if self.is_chapter: return int(self.fixed_price * self.column.promotion_discount) return promotion.price 这个值是惰性的，也就是说只有用到时才会计算值，返回的一定是一个整数。有一些应用场景： 直接展示价格：(price / 100).toFixed(2) =&gt; 0.99 很多章节合并购买，items.reduce((total, item) =&gt; total + item.price, 0) 注意这个值可能会不等于整本的定价，这时就要引导或劝说用户直接买整本更划算呀 满减活动，类似合并购买情形，只不过是有一些阈值情形12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061getMaxAvailableRebateAmountInGroup = (group) =&gt; { const total = this.getTotalPriceInGroup(group) let maxAmount = 0 if (!group.event) { return maxAmount } group.event.availablecouponGroups.some((coupon) =&gt; { if (total &gt; coupon[0]) { maxAmount = coupon[1] } return total &gt; coupon[0] }) return maxAmount}/** * Returns rebate threshold info. * @param {Object[]} couponGroups - Available coupons. * @param {number} couponGroups[][0] - The threshold of coupon. * @param {number} couponGroups[][1] - The amount of coupon, will be reduced from price when total meets threshold. * @param {numer} total - Total of prices. * @returns {[string, bool]} Description String, isMaxThresholdMet */// returned value: [descString, isMaxThresholdMet]getRebateThreshold = (couponGroups, total) =&gt; { const mf = moneyformatShort if (couponGroups.length === 0 ) { return ['本活动满减券已全部用完', true] } for (let i = 0, prev_threshold = 0, prev_amount = 0; i &lt; couponGroups.length; i++) { const [threshold, amount] = couponGroups[i] if (total &gt;= threshold) { if (i === 0) { return ['已购满 ' + mf(threshold) + '，已减 ' + mf(amount), true] } else { return ['已减 ' + mf(amount) + '，再购 ' + mf(prev_threshold - total) + ' 可减 ' + mf(prev_amount), false] } } else { if (i === couponGroups.length - 1) { return ['购满 ' + mf(threshold) + ' 可减 ' + mf(amount) + '，还差 ' + mf(threshold - total), false] } } [prev_threshold, prev_amount] = [threshold, amount] }}getTotalPriceInGroup = (group) =&gt; { return group.itemList.reduce((total, item) =&gt; { if (item.onSale &amp;&amp; item.selected) { total += item.salePrice } return total }, 0)} 钱的计算大概就是这样，涉及到第三方支付就更头疼了。 时间金钱是宝贵的，时间是更宝贵的。而我们需要根据不同场景甚至用户所在时区去显示不同的时间格式，有一种方案是 date-fns，项目里也有根据 timestamp 转换成用户可读格式的各种函数，但有时候只是想简简单单显示一个时间，同时考虑各种情况下的复用性。上 GraphQL！ 12345678910111213import timefrom libs.utils.date import mtimeformatfrom ..types import TimeFormatdef format_time(time_, format=TimeFormat.FULL_TIME.value): return { TimeFormat.FURTHER: mtimeformat(time_), TimeFormat.FULL_TIME: time_.strftime('%Y-%m-%d %H:%M:%S'), TimeFormat.FULL_DAY: time_.strftime('%Y-%m-%d'), TimeFormat.CHINESE_FULL_DAY: time_.strftime('%Y 年 %-m 月 %-d 日'), TimeFormat.ISO: time_.isoformat(), TimeFormat.TIMESTAMP: int(time.mktime(time_.timetuple()) * 1000), }[format] 其中 TimeFormat 是一个 GraphQL 的 enum 类型，mtimeformat 是一个可以根据相差时间来区别展示的函数，比如可以展示成「刚刚」「5 分钟前」这样的口语化格式。 表单表单的验证可以有很多实现，最简单的莫过于 maxlength 及 require 这种，直接交给浏览器，项目里也用到了一些 jQuery 的表单绑定，在提交之前一次性遍历表单项根据 data-* 来进行 check。 现实是 react 相关的表单验证有以下两个痛点： 异步验证所幸的是 formik 支持了 Promise 的验证结果 12345678910111213&lt;Field name={name} type=&quot;number&quot; validate={function(value) { return fetchAgent(value).then((res) =&gt; { if (res.agentExisted) { if (res.existed) { return `该作者经纪合同已经存在，负责人：${res.editorName}` } } else { return `'作者 ID' 为 ${value} 的用户不存在或不是作者身份` } }) }}/&gt; 依赖另一输入1234567891011121314import * as Yup from 'yup'const OTHER_NATIONALITY = '其他'export const validationSchema=Yup.object().shape({ nationality: Yup.string().nullable(true).required('请选择国家或地区'), otherNationality: Yup.string().test( 'need-other-nationality', '请填写其他国家或地区', function(value) { return this.parent.nationality !== OTHER_NATIONALITY || !!value } ),}) 路由异步鉴权路由 12345678910111213141516171819const PrivateRoute = ({ component: Component, ...rest }) =&gt; { const user = useSelector(state =&gt; selectors.user(state)) const isLoaded = useSelector(state =&gt; selectors.isLoaded(state)) return ( &lt;Route {...rest} render={(props) =&gt; !isLoaded ? ( &lt;&gt;&lt;/&gt; ) : user ? ( &lt;Component {...props} /&gt; ) : ( &lt;Redirect to='/404' /&gt; ) } /&gt; )}","link":"/blog/2020/06/27/format-and-validate/"},{"title":"我渲染故我在，Electron 窗口开发指北","text":"前情摘要在前一篇文章中笔者主要介绍了使用 Electron 进行开发过程中打包、构建、自动升级与文件关联相关的内容，细心的读者可能已经发现其中并没有提到与界面相关的话题。时隔一个月，中间又经历了一些需求迭代开发和代码维护，这篇文章将会尽可能详细地介绍 Electron 跨端开发中用户界面部分与平台及系统差异相关的注意点，并探索建立支持自定义多范式的窗口管理方式。 窗口开发基础我住长江头，君住长江尾，日日思君不见君，共饮长江水。 —— 李之仪 通信方式我们知道所有 Electron 自定义的窗口界面都是跑在渲染进程里的，而讲到渲染进程则不得不提到主进程。《卜算子》这首小令非常形象地道出了同一个应用里不同渲染进程和主进程之间的关系：一个应用实例只有一个主进程，而会有多个渲染进程。渲染进程之间是无法直接通信的，他们必须要通过主进程这条”长江”来通讯。 一个渲染进程就是管理一个 Window 的进程，通常意义上总是这样。它可以用 IPC 消息和主进程通讯，而主进程通常情况下是作为调度器来衔接各个渲染进程的，只能在收到消息后进行回复。但其实渲染进程和实际展示的网页还是有所不同的，下图简单梳理了一下「主进程 - 渲染进程 - 窗口」直接通信的方式。 上图中，ipcMain 和 webContents 都存在在主进程里，它们之间可以无缝直接调用，每个 webContents 管理一个窗口，一一对应浏览器里的 window 对象，而每个 window 对象里通过打开 nodeIntegration 开关赋予调用 Electron 的 ipcRenderer 模块发送异步或同步消息则是进程间通信的关键点。 这里有几个注意点，理清它们才能更好地规划应用的架构： ipcRenderer 通常是通信的发起者，ipcMain 只能作为通信的接受者，而 webContents 则作为中间枢纽，代理了部分 ipc 消息（如 send 或者 sendSync 消息可以直接被 webContents 截获并处理）。 ipcMain 只有在接受消息时才知晓渲染进程的存在，本身应该作为一个全局的无状态的服务器。 webContents 作为既存在于主进程又可以直接对应到单个 window 的对象，有效地隔离了 ipc 消息的作用域。 通常情形下，我们应该尽可能直接使用 webContents 和 ipcRenderer 之间的通讯，只有涉及到全局事件时才通过 ipcMain 进行调度。 窗口结构Electron 提供了基于 Chromium 的丰富多彩的窗口能力，注意它是基于 Chromium，所以在 Electron 里看到的几乎所有窗口（有些文件选择弹窗之类的是系统原生实现）都是一个个浏览器。这些窗口都有很丰富的选项和能力，比如最强大的 nodeIntegration 可以在浏览器环境下使用 Node.js 的能力。 一个简单的弹窗 一个 DUI 的 Snackbar 一个复杂的多 Tab 应用 它们都是 BrowserWindow。这时问题就产生了，如何有序地管理这些窗口？Electron 是一个客户端应用，但它跑在 Node.js 上，而 Node.js 最出色的特性比如 stream 和 Event Loop 和它似乎都没啥关系。那就看看我们所熟知的 Web 应用是如何管理”多任务”的吧：在服务端，我们有基于 MVC 的路由，根据 url 转发到不同的 view 进行处理并返回，在客户端，我们也有前端路由，同样根据 url，不过是渲染成不同的 DOM 节点。 可见，任务组织结构与实际节点的物理/逻辑拓扑关系是息息相关的，任何组织结构都是服务于节点间更好地进行沟通交流，以及根节点对子节点有效的管理。所以，我们可以得出一个简单的结论： 如果是抽象关联节点的话，可以用哈希表（如 Map）来对应单个窗口 如果是具象关联节点的话，可以用树状结构（如 XML）来对应单个窗口 但这时有一个问题，窗口内加载的仍是 web 页面，本质是一个个 HTML 文件，而我们知道 HTML 并不能互相嵌套 …… 虽然曾有过 HTML Imports，但其在 MDN docs 上已被标记为过时且不建议使用，我们仍然需要一个组合 HTML 的机制否则我们的页面文件随着需求的增加就会变成一个冗长的 entry 列表。 代码风格 “Imperative programming is like how you do something, and declarative programming is more like what you do.” 我们知道代码风格有命令式和声明式两种，命令式编程意味着你告诉计算机每一步应该做什么，而声明式则更多关心计算机执行的最后结果，即告诉计算机要什么，怎么做到我不管。 上面两段代码估计早期前端开发都曾写过，第一个函数的作用是将数组的每一项乘以 2 并返回所得的新数组，第二个函数是求数组内所有项的和。 这一段代码在上一段代码基础上利用 Array.prototype 上的 map 和 reduce 高阶函数对迭代操作进行了封装，可以注意到函数的行数明显下降了，并且读者并不用关注具体迭代过程是怎么样的，也不用关注这些计算过程。 阅读代码的人只需要知道： 将 arr 的每一项都映射到这一项取值的 2 倍 设置初始值为 0，将 arr 的每一项加上初始值之后赋值给初始值 具体每一项是如何取值的，又是如何赋值的，写代码和阅读代码的人都不必关注。可能 map 和 reduce 的例子还不够充分，sort 这个方法是诠释声明式编程最好的例子。 123arr.sort((a, b) =&gt; { return a - b;}) 如上图，如果 a - b &lt; 0，则将 a 放在 b 的左边，如果 a - b === 0 则保留两者位置不变，如果 a - b &gt; 0，则将 a 放到 b 的右边，简单朴素地说明了排序的基本原则，而具体排序是用什么方式，时间复杂度和空间复杂度都不要用户去关注（如果想要进一步了解 Array.sort 的实现可参见这篇 StackOverflow 的回答）。 理清了上面这一点我们可以通过一个更进一步的例子来说明为什么声明式编程更适合 UI 开发？ 这个例子是一个初学 jQuery 的学徒都可以轻松写出的代码，逻辑也比较清晰，但做的事情已经开始混杂了： highlight 这个 class 与文本的对应关系不明，需要更多上下文或者结合 HTML 考虑。 “Add Highlight” 被重复写了两遍，并且以 DOM 文本属性作为状态有点违背 Model View 分离的原则。 上图则是 React 中表达一个 Btn 组件的方式，可以看到 highlight 存在于 this.state 之上，成为脱离 UI 的状态，并且 onToggleHighlight 将调用关系绑定给 handleToggleHighlight，而 highlight 属性则是绑定给了 state 里的同名值。用通俗的话讲就是将数据状态和 UI 给串联起来了，盘活了。一旦数据状态发生变化就会自动映射到 UI 上，而 UI 上接受到事件也可以对数据做出相应改变，一个数据状态就对应了一个 UI 状态，童叟无欺。 这正是我们需要的组合 Web UI 的最佳形式。 窗口管理器综上所述，我们需要一个数据即 UI，惰性更新窗口样式以及生命周期能够被主进程统一管理的窗口管理器，它应该具有以下几个功能： 提供包含组件及函数方法等多种创建销毁更新组件的方式 将数据与 UI 绑定，无需一一手动设置窗口样式 组件生则窗口生，组件卸载则窗口关闭 主进程与窗口可以进行直接或间接的通讯，交换数据 Electron 及 React 相关 API 解析 说好了不讲具体 API 的，摔！但不理解这些 API 就很难开发一个高效的窗口管理系统，遇到了具体问题也会找不着北，所以还是忍住睡意看一下会用到哪些神奇的API 吧~ BrowserWindow首先是 Electron 的窗口类，这是我们与窗口外观打交道的主要途径了，在它上面有从窗口尺寸位置到标题栏样式乃至窗口内包括 JavaScript 和各种 Web API 是否开启等设置项，可以说就是一个定制版的小 Chrome。下面列出比较重要的几项： frame: 窗口边框 titleBarStyle: 标题栏样式，包括 macOS 的红绿灯样式 webPreferences: web 相关设置 nodeIntegration: 是否在内部浏览器开启 Node.js 环境 preload: 预加载脚本 enableRemoteModule: 启用远程模块，例如在浏览器中访问只属于主进程的 app 对象等 nativeWindowOpen: 是否支持原生打开窗口，这个属性非常重要，是实现跨窗口通讯的基础，当前工作窗口必须设置为 true webContentswebContent 是 BrowserWindow 下面具体管理 web 页面的一个对象，它同时也是一个 EventEmitter。我们只关心它上面关于创建窗口最重要的一个事件：**’new-window’**。 1234567891011121314151617181920212223const window = new BrowserWindow({ webPreferences: { nativeWindowOpen: true, },});window.webContents.on('new-window', (event, url, frameName, disposition, windowOptions) =&gt; { if (frameName.startsWith('windowPortal')) { event.preventDefault() const options: BrowserWindowConstructorOptions = { ...windowOptions, frame: false, titleBarStyle: 'default', skipTaskbar: true, show: false, width: 0, height: 0, } const newWindow = new BrowserWindow(options) event.newGuest = newWindow }}) 上面这段代码的最终结果是将创建新窗口的过程的控制权交给 Electron 这边，比如设置无边框、默认标题栏样式、宽高都为 0 并且不显示，最后将这个完全为空的窗口交给 event.newGuest 交还给 window.opener。 React关于 React 的教程网上也是汗牛充栋了，我们这里同样弱水三千，只取一瓢。 1ReactDOM.createPortal(child, container) createPortal API 相信大家都用过，但大部分用途应该都只是将 React 组件渲染到 body 上变成模态框之类的，但如果我们将整个桌面看做一个 body，而其中的某个窗口看做一个 div 容器呢？答案是这样做可行！！！ 我们可以将 React 的组件直接 createPortal 到上面新生成的 window 里去，这样就走通了 React 组件化开发并管理 Electron 窗口的关键链路。 窗口管理器实践我们已经拥有了在渲染进程里动态创建一个 Electron 窗口的全部知识，下面话不多说直接贴代码，手把手教你玩转 **Electron 'Portal'**！ React + Electron我们需要拷贝样式至新窗口，在网上找到了如下一段代码，可以将外部样式表 link 和内联样式表 style 统统拷贝到新打开的 document 里。 123456789101112131415161718192021222324export function copyStyles(sourceDoc: Document, targetDoc: Document) { const documentFragment = sourceDoc.createDocumentFragment(); Array.from(sourceDoc.styleSheets).forEach((styleSheet) =&gt; { // for &lt;style&gt; elements if (styleSheet.cssRules) { const newStyleEl = sourceDoc.createElement('style'); Array.from(styleSheet.cssRules).forEach((cssRule) =&gt; { // write the text of each rule into the body of the style element newStyleEl.appendChild(sourceDoc.createTextNode(cssRule.cssText)); }); documentFragment.appendChild(newStyleEl); } else if (styleSheet.href) { // for &lt;link&gt; elements loading CSS from a URL const newLinkEl = sourceDoc.createElement('link'); newLinkEl.rel = 'stylesheet'; newLinkEl.href = styleSheet.href; documentFragment.appendChild(newLinkEl); } }); targetDoc.head.appendChild(documentFragment);} 下面是实现 Portal 的关键代码，关于其实现有以下几个技术要点： 通过 forwardRef 暴露 getSize 等获取实际渲染元素的状态信息方法，因为这些也是命令式的方法，正好契合了 useImperativeHandle 的名字，可以被父组件用 ref 来缓存后用于计算多个组件的位置关系。 在 useEffect 中返回关闭 window 的方法以便销毁窗口。 封装 getWorkArea 方法以便适配多显示器。 初次显示窗口时切记要先 show 一个 0×0 的窗口，将它移动到指定位置再扩张尺寸使其显示，如果 show 放在最后的话，在 macOS 全屏模式下会另起一个全屏窗口，这不是我们所需要的。 巧用 useEffect 的 dependency 监测 props 里位置信息的改变，自动映射到窗口上去。 灵活提供 mountNode 参数给子组件，以便一些原本挂载到 document.body 上的全局组件（如 Modal 和 Toast）渲染到指定位置，仿佛它们是挂载到了 desktop.body 上一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const Portal = ({ children, x, y, horizontalCenter, verticalCenter, inactive, alwaysOnTop,}, ref) =&gt; { const [mountNode, setMountNode] = useState(null); const windowRef = useRef(); useImperativeHandle(ref, () =&gt; ({ getSize: () =&gt; { if (mountNode) { const { clientWidth, clientHeight } = mountNode; return [clientWidth, clientHeight]; } return null; }, })); // 创建窗口和 mountNode useEffect(() =&gt; { const div = document.createElement('div'); div.style.display = 'inline-block'; const win = window.open('about:blank', `${WINDOW_PORTAL}-${String(new Date().getTime())}`); if (!win.document) return; copyStyles(document, win.document); win.document.body.appendChild(div); windowRef.current = win; setMountNode(div); return () =&gt; { if (windowRef.current) { windowRef.current.close(); } }; }, []); // 获取工作窗口的位置尺寸 const getWorkArea = useCallback(() =&gt; { if (windowRef.current) { const { remote } = windowRef.current.require('electron'); return remote.screen.getDisplayNearestPoint(remote.screen.getCursorScreenPoint()).workArea; } }, [windowRef.current]); const getPosition = useCallback(() =&gt; { const workArea = getWorkArea(); const xPos = (horizontalCenter ? (workArea.width / 2) - (mountNode.clientWidth / 2) : x) | 0; const yPos = (verticalCenter ? (workArea.height / 2) - (mountNode.clientHeight / 2) : y) | 0; return [workArea.x + xPos, workArea.y + yPos]; }, [getWorkArea, x, y, horizontalCenter, verticalCenter]); // 初始化窗口 useEffect(() =&gt; { if (mountNode &amp;&amp; windowRef.current) { const win = windowRef.current; const { clientWidth, clientHeight } = mountNode; const { remote } = win.require('electron'); const browserWindow = remote.getCurrentWindow(); if (inactive) { browserWindow.showInactive(); } else { browserWindow.show(); } if (alwaysOnTop) { browserWindow.setAlwaysOnTop(true); } browserWindow.setPosition(...getPosition()); browserWindow.setSize(clientWidth, clientHeight); } }, [mountNode, windowRef.current]); // 位移 useEffect(() =&gt; { if (windowRef.current &amp;&amp; mountNode) { const win = windowRef.current; const { remote } = win.require('electron'); remote.getCurrentWindow().setPosition(...getPosition(), true); } }, [mountNode, windowRef.current, getPosition]); return mountNode &amp;&amp; createPortal( children instanceof Function ? children({ mountNode }) : children, mountNode, );}export default forwardRef(Portal); Svelte + Electron如果一种范式只有一种实现方式，那说明它还不够通用。为了证明这种管理 web 窗口的方式真的有意义，笔者尝试用 Svelte 实现了同样的功能。这里先向不了解Svelte 框架的同学安利一下这个神奇的框架，它一开始的口号是”消失的框架”，什么意思呢？它不像 React、Vue 之类的打包后还需要一个运行时的 lib 提供各种工具函数，比如 React.createElement 方法，它是完全的编译时框架，编译后只有组件代码即可运行。所以在只需要渲染一两个动态组件时，其体积和性能优势非常明显，尤其是配合其作者开发的 Rollup 时。由于 Electron 对其内 web 浏览器具有完全的操控权，我们可以放心地交付 ES6+ 的代码，不必过多 care 兼容性。下面给出试用 Svelte 写的 Portal 组件代码，感兴趣的同学可以尝试下哈，感受下别样的框架风情~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;div bind:this={portal} class=&quot;portal&quot;&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;&lt;style&gt; .portal { display: inline-block; }&lt;/style&gt;&lt;script context=&quot;module&quot; lang=&quot;ts&quot;&gt; function copyStyles(sourceDoc: Document, targetDoc: Document) { Array.from(sourceDoc.styleSheets).forEach(styleSheet =&gt; { if (styleSheet.cssRules) { // for &lt;style&gt; elements const newStyleEl = sourceDoc.createElement('style'); Array.from(styleSheet.cssRules).forEach(cssRule =&gt; { // write the text of each rule into the body of the style element newStyleEl.appendChild(sourceDoc.createTextNode(cssRule.cssText)); }); targetDoc.head.appendChild(newStyleEl); } else if (styleSheet.href) { // for &lt;link&gt; elements loading CSS from a URL const newLinkEl = sourceDoc.createElement('link'); newLinkEl.rel = 'stylesheet'; newLinkEl.href = styleSheet.href; targetDoc.head.appendChild(newLinkEl); } }); }&lt;/script&gt;&lt;script lang=&quot;ts&quot;&gt; import { onMount, onDestroy } from 'svelte' import type Electron from 'electron' type PortalWindow = Window &amp; { require: (...args: any) =&gt; { remote: Electron.Remote } } let windowRef: PortalWindow let portal: HTMLDivElement onMount(() =&gt; { windowRef = window.open('about:blank', 'windowPortal') as unknown as PortalWindow copyStyles(document, windowRef.document) windowRef.document.body.appendChild(portal) const { clientWidth, clientHeight } = portal windowRef.requestAnimationFrame(() =&gt; { const { remote } = windowRef.require('electron') const win = remote.getCurrentWindow() const workArea = remote.screen.getDisplayNearestPoint(remote.screen.getCursorScreenPoint()).bounds win.showInactive(); win.setPosition(workArea.x + 50, workArea.y + 50); win.setSize(clientWidth, clientHeight); }) }) onDestroy(() =&gt; { if (windowRef) { windowRef.close() } }) &lt;/script&gt; 对 Svelte 和 Electron 结合感兴趣的同学还可以移步我的个人项目地址：https://github.com/msyfls123/diablo2-wiki “中央处理器”The last but not the least. 前面我们从一个带有 nativeWindowOpen 的 BrowserWindow 开始，经过 React.createPortal 创建新的 BrowserWindow 并将其交还给 React 渲染组件，并通过一系列的 effect 和 ref 方法使其得到了良好的管理，但实际上这个”窗口管理器”只存在渲染进程中，它与外界的通讯必须通过最开始那个 BrowserWindow 进行。我们需要将它封装成一个”中央处理器”，以便处理更加多样的调用。 这里不再赘述如何去用代码实现一个 WebUI 的类，因为它是全局唯一的，所以需要单例模式。在主进程入口，创建一个上面提到的用于承载各种窗口的 BrowserWindow，将这个 Window 通过 WebUI 的 init 方法注入到实例上，后续就可以通过公共的方法来调用这个中央处理器了。 1234567891011121314class WebUI { init(window) { this.window = window; this.window.webContents.on('ipc-message', this.handleIpcMessage); } showDialog(type, payload) { if (this.window) { this.window.webContents.send('show-dialog', type, payload); } } handleIpcMessage(event, channel, payload) { ... }} 主进程中使用只需要直接调用单例的方法，如果需要暴露给渲染进程则可以如法炮制一个 ipcServer 转发来自其他渲染进程的消息。 意义首先是声明式渲染 vs 命令式渲染，声明式责任在自己，命令式责任在对方。为啥呢？从 Electron 加载页面的方式就可以看出来了，加载一个 GitHub 的首页，只要网页一变，必然需要调用方处理相关的改动，且是被动处理。 改为声明式渲染则可以把主动权把握在自己手里。因为不存在 URL，所以无需考虑跳转之类的问题，仅需考虑最大程度复用组件，可做到比 SPA 更进一步。但这里存在一个小小的问题，没有 URL 也意味着相对路径引用的文件资源统统不可用了，比如 ‘./images/a.png’ 这样简单的引用图片的方式是无法做到的，只能变成绝对路径或者是 dataURL 内联，后续将进一步探索更合适的资源加载方案。 然后是这种后台常驻一个渲染服务进程看似和市面上常见的预加载 + 显示隐藏窗口提升性能的方案大同小异，其实不然，那种方式本质上还是多对多地维护”窗口缓存”，数量上去了一样很卡。但这套方案后台渲染进程恒为 1，做到了 O(1) 空间复杂度，并且在页面加载上完全无需考虑 DOM 解析和 JavaScript 加载（因为根本就不需要，Portal 的渲染都在已经加载完成的那个窗口进行），做到了最小化资源占用。像 Serverless 追求的也是快速热启动，既然我们已知用户所有的操作路径，又有最高效的窗口管理方式，何乐而不为呢。 还有一点是，通过 Portal 可以实现任意渲染窗口不借助主进程独立创建并管理一个新的渲染窗口，这一点给了 Electron 更多新的玩法，比如自定义右键菜单、常驻任务栏等都可以借此实现，直接脱离原 DOM 树，给予更多的 UI 操作自由和想象空间。 注意事项编译时与运行时区分因为是跨端开发，所以一套代码会运行在多个平台上，需要区分编译时和运行时。 编译时可以确定的值应该使用 webpack.DefinePlugin 替换成常量，如 process.env.NODE_ENV，这些是一旦打包以后再也不会发生改变了。 运行时确定的值应该尽可能使用 os.platform 动态判断，原因是如果某一平台不支持某些属性，而开发时为了 debug 将功能开启，却忘了删 debug 开关，上线即造成这一平台的用户体验 crash 套餐。 参考 https://ui.dev/imperative-vs-declarative-programming/ https://www.electronjs.org/docs/api/browser-window https://medium.com/hackernoon/using-a-react-16-portal-to-do-something-cool-2a2d627b0202","link":"/blog/2020/12/01/rendering-cause-me-to-exist/"},{"title":"逛公园才是正经事","text":"一晃在帝都都呆了四年多了，逛过的公园也不少，今日忽有友人问起周末闲时去处，也罢，将这些年逛过的公园一一道来。那几个耳熟能详的，比如故宫、天坛、颐和园和圆明园等就不表了。 东边朝阳公园在北京四年，在朝阳区就有三年半，朝阳公园作为朝阳区的扛把子，自然是头把交椅。 美丽的朝阳公园坐落于北京东三环与东四环之间，是我逛过单体最大的公园之一。大约是 2017 年某一个周日，闲得实在蛋疼，就买了张票去了朝阳公园，逛了一圈，逛到脚酸。 公园是很典型的以水域为中心，按功能划分区域的结构，中心区域为综合游乐场，东南侧为运动场地，有户外拓展、足球篮球棒球各种运动场地，北侧则基本以植被覆盖。整个公园坡度较小，适合慢跑等运动，据说住在周边的很多明星会来这里晨跑。 夏季的朝阳公园有荷花莲叶，冬季有人工滑雪场，总的来说游玩价值很高。和前女友在一起的时候甚至考虑过在这里的婚礼堂办婚礼，但她没给我求婚的机会。 公园西北角是蓝色港湾，建得不错，也有蛮多吃的。但我最钟意的是外面好运街的东吴面馆，虽然这家分店的面不如南方分店的好，价格也高出很多，但毕竟是家乡的口味。有几次特意坐车过来吃，除了有关河鲜的浇头不咋滴之外，其他的面都算差强人意。 朝阳公园西边是富人区，那房子建得一看就是打几辈子工都买不起的，我骑车路过时常常想里面的人有好好欣赏这片风景的时间吗？ 面对如此美景，甚至还手涂了几幅渣渣写生。 朝阳公园门票常年 5 块钱（2021 年春节之后全年免费开放了），如果月末经济拮据掏不起可以出南门左转过马路找小门去红领巾公园，那儿免费，并且麻雀虽小一应俱全，什么游乐场运动场打坐散步区域都有，靠近湖边还经常有老年乐队萨克斯手风琴演奏。 奥林匹克森林公园奥森我去的次数不算多，但公园的体量摆在那，去个一次抵别的公园两三次……而且风景确实很好，有个山包，坐落在帝都中轴线上，可以从北向南俯瞰笼罩在雾霾中的北京城。公园主线就是绕园一周的环园路，所以随大流总是能看到无穷无尽的人，那些运动 or 减肥协会也挺喜欢在这办活动，经常能看到穿统一服装的，高矮胖瘦都有，在健步如飞或踌躇前行。 推荐在秋天或者春天去逛奥森，秋天可以看满山枫叶，足够黄。春天可以到北园看三生三世十里桃花，足够骚。 将府公园这个公园没啥名气，也没啥特色，但却是离我刚来北京时住的地方最近的一个，公园里有条废弃的铁路，然后就是各种横平竖直规划好的树林以及屈指可数的游乐运动场，还记得是有个啥点将台的仿古建筑来着，所以这地儿叫”将台”。 记得从将台往这公园走是要过个铁路的，对于从小在铁路旁长大，但与铁路渐行渐远的我来说还挺怀念。顺便说一句，五道口现在也不是道口了，旁边铁路也没了。真是沧海桑田。 四得公园又一个半点名气的没有的公园，哪”四得”呢？据百度百科，办园宗旨是”使游人能够得到自然清新的乐趣，得到身心的锻炼，得到一定的植物知识，得到健康长寿”，答案竟然如此浅显，真是令人吃惊。但这个公园见证了我足足减掉了 15 斤肥肉的艰苦历程 …… 绕园一周 900 米，我那时经常早上跑 4 圈走 1 圈，晚上跑 3 圈走 2 圈，爆燃脂。然后挺着湿漉漉的大肚子，走过将台西路那一大片露天烧烤店，在满大街吃客面前耀武扬威得像个犯傻的二愣子，回到我那乌漆嘛黑的家。 早上跑步时能偶尔能看到小猫咪，一黄一灰，后来就不见了，估计是被人打死了。夏天晚上跑步能闻到夜来香还不知是玉兰香，野花挺多。我每次跑到撑不下去时就瞅瞅有没有好身材的妹子，想像追到她就能跟她嘿嘿哈哈，那就有动力了。 望和公园我搬到望京之后，又想跑两步了，就找了个附近的公园，但这里其实大大小小足有三四个公园，每个都差不多，刚来的人都可能分不清。但我很快就放弃了在这边跑步的想法，因为这里的跑道不仅抓地性有问题，下过雨之后竟然是软的，还有一个极陡的上下坡，加上住 21 层等电梯也不容易，这些都成了跑步的阻碍。后来我买了个瑜伽球 + 垫，照着油管上一个 UP 主分享的动作（大约是平板支撑 + 手脚传球 + 卷腹等）练腰腹力量，辅以一两周一次的 Keepland H.I.T.T. 减脂效果还可以。 这公园的湖边景致还有点意思，像是精心打理过的，如下图的云雾缭绕效果，宛如仙境一般。 望京公园虽然名字挺响亮，但实际挺小挺荒凉，从酒仙桥路向北到快要转弯到望京去的地方往东北侧，大约 500 米就是。这个公园连湖都没有，全是树，树都很高，有种无边落木萧萧下的感觉。去过一次，总觉得像是拍那种带凶杀案的文艺片取景地。 太阳宫公园有同学住在附近，来逛过两三次，没啥特色，门口有个大广场，里面各种树木一看就是人工产物。在外面四环路看过去倒是能看到一些大型盆栽啥的，但似乎不是一家，在公园内就看不到了。 地坛公园99.9 % 的人看到地坛这两个字都会联想到史铁生，2017 年春节前我在附近逗留时去逛了一圈，发现地坛公园确实挺好的 …… 因为是皇家园林，布局工工整整，树木修剪得也不错，西北侧有个寺庙，东北侧一些供人憩息的院落，中心位置路挺宽，适合办庙会。有两次花了额外的钱上到了坛上，和天坛一比就显得接地气了很多。 中轴景山公园讲完了东边的公园，来讲讲皇城根下的景山公园。出了故宫神武门正对着的就是，门票应该是 3 元，景山最著名的当属大明朝崇祯爷自缢那棵歪脖子树了，可惨了，说殓尸时思宗皇帝光着左脚，右脚穿着一只红鞋。但人已逝，树非树，都成了坊间趣谈。 从景山顶上可以望见故宫中轴线，也就是北京城的中轴线。 那次去景山还看到了一个老者吹萨克斯，演奏的曲目是《追梦人》。 北海公园北海公园在景山旁边，基本也就是个湖，湖中间有个岛。有趣的一点是，你从北门进去就有两条路，一条往西，一条往东，你选了一条走到头之后发现到不了另一条路上，这时咋办呢，只能掏腰包买船票坐船到湖中心再往另一头去，不得不说还是挺精明的。 和同学逛北海公园时，同学说他和他老婆第一次约会就在北海公园，他老婆看到如此良辰美景就开始吟诗作赋了，而他应不上来，只得干笑，想到这场面就忍俊不禁。 北海公园边上有个北海幼儿园，我第一次看到就惊呆了，有副对联讲得好，”拳打南山敬老院，脚踢北海幼儿园”，网上搜了搜，南山敬老院在昌平，有点远，所以给这对联配上俩图的愿望一直搁浅着。 陶然亭公园这大概是我最早逛的公园之一了 ，那是一个雾霾天，前一周连写了三个线上 bug 的我决定去庙里烧柱香祈求佛祖保佑永无 bug。先是到了法源寺，看到了一院子的猫，还有几位老和尚在和女施主手把手促膝长谈。然后出门走到牛街买了仨牛肉包子啃了，接着向南就走到了陶然亭。估计是因为地处南城，都是各种老头老太在锻炼身体，过去太久也找不到照片，依稀记得是有个挺大的亭子，门口有些假山假石，园里好像还有个滑滑梯啥的。正值冬季，似乎还有冰雪嘉年华。随便放个网上的照片吧。 西边玉渊潭公园有一年春天去的，人超级多，绕着湖走了一大圈，湖中间有个堤可以通行，北侧有游廊。记得是为了看樱花，但樱花质量也就寥寥，不甘落后的商家还出了樱花特款棒冰。地理位置还是很好的，旁边就是中华世纪坛和各种国家单位，真的是人来人往。抛开人多这一项之外，风景还算不错。 紫竹院公园紫竹院公园过去曾经是北京市知名的女同性恋者聚集场所，后来女同性恋者则主要在专门的餐馆、酒吧聚集。男同性恋者则选择东单公园、元大都城垣遗址公园等处聚集。 北京有俗话称”要想成陶然亭，要想散紫竹院。”指男女朋友若同去陶然亭公园则会谈成，若同去紫竹院公园则会分手。也有说法是”成不成，陶然亭；散不散，紫竹院。 紫竹院公园在国家图书馆南边，旁边都是舞蹈学院艺术馆啥的，人文气息浓郁。既然叫紫竹院，园内自然以竹子为主，错落以假山假水啥的。也像模像样修了各种亭台楼阁。与陶然亭一样也有冰雪嘉年华啥的，毕竟北方人冬天不管下不下雪都得有个玩雪的地方。 园中循湖面往西南望去，可以看到玉渊潭边上的中央电视塔。 百望山森林公园这是目前离我最近的公园了，我们领导几乎每周都会去这儿爬个山。听名字就知道这是个山，坐落在京城西北角，相传北宋杨六郎与辽兵在此山下鏖战，佘太君登山观阵助威，此山因而得名。山顶有佘太君雕像，迎风伫立，俯瞰众生。[百望]{.ul}山曾是平西抗日游击队诞生地，现有黑山扈抗日战斗纪念碑等。还有个圣母院和一个传教士 PIERRE WILLIEMS 之墓，蛮好奇在他的祖国荷兰，他会被认为是和东渡日本的鉴真和尚一样的宗教人物吗？ 天气好的时候可以一览北京的天际线，望京那一排高楼、奥林匹克七星塔、盘古酒店、擎天柱一样的中国樽和中央电视塔，近处的就是颐和园和圆明园了。 北京植物园植物园是我去过最偏僻的公园之一了，坐落在香山脚底下。大冬天去的，没啥植物，里面有俩景点有点意思，一个是梁启超墓，由其子 —— 著名建筑学家梁思成亲自操刀，整个墓园安静祥和，西侧有个亭子，说是打算立个铜像，因财力不足而作罢。 另一个就有意思了，说是一退休老教师返回祖宅生活，搬动床柜时擦破了墙皮，露出来其中的诗文，考证发现竟是曹雪芹故居。于是政府就依样画葫芦给复原了一个故居出来。故居里详细介绍了曹雪芹家因被贬而辗转北京各处居住的故事，结合北京当时燕京八景等景致。猜测先生当时是如何在北国寒风中忆甜思苦，怀想金陵时极致奢靡的上流生活，写出那部不朽的传世之作《红楼梦》。 从故居出来往山上走，一路溪流蜿蜒，实际上是都结成冰了，有穿古装的小主在冰上拍照，颇有几分像贾府众女眷踏雪寻梅的景致。溯源至尽头，有一巨石，呈元宝状，相传这就是女娲娘娘补天剩下的那块奇石——红楼故事的一切就从这里开始。 北京园博园讲到这里也就差不多了，第一次去园博园还是 2013 年来北京领个奖时和老师一起去的，那时的园博园刚修好，地铁也刚通到那，里面的园子开得还是挺齐的，中间的锦绣谷虽说不上花团锦簇，但还是有几分姿色。一晃过了 7 年了，2020 年和我妈又去了一趟，真是相当惨淡了。几个特色展馆全部歇业，什么东南亚、非洲、台湾馆全部都关门了，连吃饭地方都只剩吉祥馄饨一家黑店，要不然就只能吃方便面自热米饭啥的。整个园博园到处一副颓败气息，唯一还能参观打量的三个园子分别是北京园、江苏园和广东园，大致与 GDP 财力相符。 西北处有个永定塔，气势恢宏，我妈说拍塔不要站在塔脚底下仰拍，这样就会被塔镇住不得翻身。 后记这里只列出中心城区方便寻找到的公园，像还有些什么雁栖湖公园之类的因为太远没有列举必要，不过雁栖湖作为会议度假疗养胜地，风景倒还可以，跟十三陵水库有的一拼。下一为雁栖湖，下二三为十三陵水库。 像故宫、颐和园和圆明园啥的，偶尔也会去去，就觉得这几个地儿吧，随着游客纷至沓来，越来越像个现代景点，越来越不是皇家园林那味儿了。","link":"/blog/2021/02/06/travels-of-beijing-parks/"},{"title":"Electron 开发实践","text":"前言首先介绍一下腾讯文档桌面端应用，以下简称桌面端，其通过嵌入 web 端腾讯文档应用并利用 Electron 封装本地系统接口的能力实现了独立分发的桌面端 App，兼顾了 macOS 和 Windows 两大操作系统，借此实现了腾讯文档的全端覆盖。 两大平台，一个月时间，我们是如何做到从技术选型到项目上线的呢？ 这也太标题党了，跟市面上流传甚广的 21 天精通 C++ 简直一模一样。 我们都知道罗马不是一天建成的，如果把软件开发比作建一座城市的话，我们的的确确在一个月时间内造出了腾讯文档桌面端应用。肯定有人要问了，为何是一个月时间呢？为什么不是半个月，三个月亦或是半年时间？ 事实上，这也是我们一开始进行技术选型和开发规划时所考虑的问题，因为选择了使用 JavaScript 及 Web 技术开发客户端，就注定了与 web 开发息息相关，包括迭代周期和开发顺序等方面，web 端腾讯文档的发布周期是一周两次发布，在一个月时间内差不多可以交付一系列完整的 API，这样可以做到桌面端与 web 端并行开发，最终整合成一个整体。如果等到半年时间才交付了桌面端，这时 web 端应用的 API 和 JSBridge 等接口规范都可能随之发生改变，容易造成返工甚至二次开发。 下面，我们将从四个方面介绍腾讯文档桌面端开发实践内容：技术选型、DevOps 工程化实践、混合式开发基础建设和跨端统一用户体验。 技术选型竞技场耸立，罗马屹立不倒；竞技场倒塌，罗马倒塌；罗马倒塌，整个世界都会崩溃。 ——圣徒比德 技术选型与古罗马的竞技的核心并无二致，都在于选优拔萃。而我们做技术选型的目的则不在于观赏，在于为了今后的开发找到正确的方向。 首先是总体的开发框架选择，结果是没有疑问的，我们选择了 Electron，实际上 NW.js 前身 node-webkit 和 Electron 的开发团队具有继承关系，而 NW.js 的特点是以 html 作为启动文件，在窗口里直接调用 Node.js，但我们知道能力越大责任越大，同时风险系数也越高。Electron 的主进程是跑在 Node.js 环境下的，可以无缝使用 Node.js 能力，而单独的窗口，即渲染进程，需要显式地打开开关才能使用，这样就一定程度上降低窗口中的页面滥用 Node.js 能力对系统造成危害或者频繁调用 Node.js 能力对性能产生影响的可能性。在插件、第三方包、社区生态和搜索热度上， Electron 都完胜于 NW.js，所以我们就放心地使用 Electron 进行开发吧。 社区优质实践既然选定了 Electron 作为开发框架，先来看一看业界基于 Electron 的优质实践，首当其冲的是宇宙第一 IDE 的 Visual Studio 的 …… 挂名弟弟 …… Visual Studio Code，同样是微软出品，现已成为 web 开发事实上的标准 IDE。 然后是 Github 出品的 Atom 编辑器，这里插一句题外话，Electron 原名”Atom Shell”，后来随着框架的进一步抽离和沉淀，改名为”Electron”，这点非常符合国外技术圈觉得”工具不好用就发明一个趁手的工具”的思路。以及同样是 GitHub 出品的 GitHub Desktop 客户端，其他知名的基于 Electron 开发的桌面软件还有协作办公软件 Slack、 IM 即时通讯软件 WhatsApp 和 知识协作软件 Notion 等。 构建工具我们做桌面端应用与 web 端应用差异最大的在于分发方式不同，web 端应用打开页面浏览即为分发成功，而桌面端应用则必须要下载到本地安装后使用，所以提升下载与安装体验对用户增长率提升至关重要。而提到安装包，就不得不提一下 electron-builder，它不仅做到了轻配置快速构建，也带给了桌面端应用非常多的额外能力，例如系统级别的文件关联，自动签名认证功能，制品管理和安装流程定制等，这些都与后面讲到的工程化建设和跨端体验一致性密切相关。通过一套配置，即可构建出包括自动更新、App Store 发布包在内的多个制品。 单测框架如果说安装包是团队给用户的交付物的话，代码就是开发给团队的交付物。好的代码应该是可测试、可维护和承上启下的，要做到这些的最佳实践形式就是编写测试。而多种多样的测试里最方便快速的就是单元测试了，针对 Electron 的测试方式与常见 web 端测试不同，也可以认为是分别在 JSDOM 和 Node.js 两种环境下进行测试。经过调研，我们引入了 @jest-runner/electron 作为我们的单测框架，它的优势是一套配置，根据文件目录分发到两种执行环境下运行，也就是前面提到的主进程和渲染进程。并且具有代码无侵入，配置简单，速度飞快等特点。 从下面的图可以看到，运行全部 200 多个用例仅耗时不到 30s，方便开发时快速验证功能完备性。 DevOps 工程化实践 然后是我们的 DevOps 实践。为什么要协作呢？一个团队单打独斗不舒服吗？因为不同团队不同开发人员间基础能力有差异，倒不一定是体现在技术能力，而是技术侧重点不一样。DevOps 则提供了平台赋能，将各个能力项拉齐到统一水准。就像罗马士兵拥有了统一的装备，将人变成了战士。 同时要注意到的是选择协作工具时不仅仅要考虑当下，也要考虑系统的伸缩性，为未来的发展壮大留有余量。 最终实现了”把控代码质量”，”托管构建过程”和”运行时保障”这三大目标。 把控代码质量： 静态代码分析、ESLint 扫描、圈复杂度扫描、重复代码扫描、单元测试、自动化测试 托管构建过程： 自动构建托管、自动签名认证、自动发布、自动转工单 运行时保障： 配置下发、灰度开关、自动化故障上报、日志监控、性能监控 混合式开发基础建设前面讲到的都是外在条件，但文档内在是 web 项目。我们需要设想一下，对于一个 web 项目而言，包括 HTML、CSS、JavaScript 和其他媒体文件等等都是外部资源，如何建设好应用在于如何利用好外部资源。 如果说将 web 应用改造成桌面端应用是建一座城的话，那么将外部的能力引入到应用内的混合式开发基础建设就像是建造罗马水道一样。将水源从山脉中引流到城市里供人饮用、灌溉农田菜圃，再将污水输送出城市，完成城市的资源循环。 让我们先来看看这里都有哪些系统和外界网络提供的能力呢？比如本地的原生数据库，文件系统里存储的数据文件，服务器的计算资源和静态文件 CDN 等。 本地资源：数据库、文件 IO 和 JSBridge 首先是本地的资源，我们经过反复比较，最终选择了最高效的 LevelDB 作为底层数据库实现，它是由 Google 开发的 KV 数据库，具有很高的随机写，顺序读/写性能，同时原生数据库也给于客户端程序更多的操控权。我们在其上封装了包括多库多用户管理，请求指令封装、分发日志上报等能力，通过 electron 提供的基于 scheme 的渲染进程 URL 请求拦截，以及主进程 webContents 通过 executeJavaScript 向渲染进程执行脚本，实现了 JSBridge，将包括上面提到的 LevelDB 以及 electron-store 等存储能力引入到了 web 端，同时通过 Node.js 自带的 fs 模块将文件 IO 能力提供给桌面端应用。 外部资源然后要提到的是外界网络能力，包括服务器和静态文件 CDN 等。 这两种能力都是通过 web 技术实现的，腾讯文档目前 web 上已经实现了有限的离线编辑能力，比如自动缓存增量编辑操作，进行版本冲突处理和提交等，在静态文件上正在开发基于 PWA 的离线缓存方案。同时因为是桌面端，前面提到的 LevelDB 是通过拷贝二进制可执行文件到发布资源中来实现分发的，所产生的问题是对不同系统需要分发不同的二进制文件，或带来工序上的复杂和计算资源的浪费，未来对类似需求可能考虑 WebAssembly Interface 来做跨端分发可执行文件。 跨端统一用户体验 既然是应用开发，用户体验是重中之重。如何在跨端情况下保证用户体验的统一性，需要我们制定一系列的规范，像同时期的罗马和秦帝国一样，立国之初就统一了包括法典、文字度量衡等规范，这大大地有利于内部进行交流协作，在处理差异性问题时有据可循。 弹窗 以简单的一个系统设置弹窗为例，在设计规范中 Windows 和 macOS 上样式实现是不一致的，弹框的边框则是都采用了系统样式，但 Windows 同时需要定义标题和关闭按钮，而 macOS 则沿用了系统的红绿灯样式，同时考虑到代码一致性手动实现了标题部分。在内容部分，macOS 考虑到与系统 UI 一致，手动实现了弹窗内 tab 切换，主体内容则是基于 DUI 实现两端共用。这里带来的问题是，开发往往只会在一台机器上开发，如果开发需要每次都打包分发到另一个平台看效果也太麻烦了，可以通过加开关的形式进行调试。在完成对弹窗的封装以后，我们可以基于 BrowserWindow 和 React 对其进行统一的生命周期管理，保证同一类型弹窗只显示一个。 安装与升级 然后是安装与升级，Windows 是覆盖安装，mac 是拖拽安装，Windows 可自定义安装前后行为，例如安装完写入注册表，卸载后清理用户数据，mac 版则利用了系统的静默升级。而 electron-updater 则让两者都实现了自动下载并一键升级的功能。 更多桌面平台特性我们在开发过程中还遇到了更多的桌面特性，比较顺利的是 Electron 和 electron-builder 帮助实现了非常多的系统功能如：文件打开方式关联，QQ 消息链接自动打开 App 并打开文档，监测剪贴板链接自动打开在线文档等等。而其中不方便实现的则是全局的 Web UI 容器，因为 Electron 自带的系统 UI 控件非常少，也大多不符合 UI 规范，需要自定义 UI 界面只能通过打开渲染窗口并加载 HTML 文件的方式。如图所示的全局 toast 在项目中应用非常广泛，如何将其与 React DUI 组件进行共用呢？ 命令式创建 Web UI 组件 首先要明确的是我们肯定是通过打开 BrowserWindow 窗口加载 html 来展示 UI。一种比较常见的思路是命令式创建 web UI 组件，比如创建 DialogManager 来统一管理多个 dialog，但这里的问题是有多少个 dialog 就需要多少个 dialog.html 文件，因为它们都是编译时就确定的，即使通过 url 分发，也必须至少创建一个 dialog 文件才能打开窗口。 声明式创建 Web UI 组件 React 提供了声明式创建组件的方式，我们可否通过其创建组件呢？通过调研，我们发现了 React 的 createPortal 函数是可以将 React 组件挂载到新创建的 window 里去的，那么我们只需要定制新创建 window 的参数就可以实现无边框窗口加载 React DUI 组件的功能。即实现了利用 React 管理窗口的生命周期。 window.open 并通过 Electron 拦截定义新创建 Chromium 窗口 React.createPortal 将组件（如 ） 挂载到新创建的窗口内 利用 React 管理窗口的生命周期 这样可以把唤起 Web UI 的职责交给常驻后台的隐藏渲染窗口 webComponent，在其中自定义组合各种各样丰富的 React DUI，通过 React 进行统一管理，后续可以几乎零边际成本增添新组件，同时在组件与进程频繁交互时也方便通过组件树找出对应关系进行维护。","link":"/blog/2020/12/06/tencent-docs-desktop-practice/"},{"title":"为什么我们要打包源代码","text":"盘古开天之际，我们是不需要打包代码的，直接执行即可…… 咳咳，走错片场了。但道理是一样的，当计算机还是由纸带驱动时，什么程序和数据都是混杂在一个个空洞之上，像挂面一样，没法打包，或者说压缩。直到区分了处理器和存储器，才有了汇编指令，程序才变得像意大利面一样曲曲折折，千转百回。 今天我们组的实习生突然提到了 B/S 架构，突然联想到之前的单体发布应用，加上目前对于 WebAssembly 等胶水层和大大小小各种容器技术的理解，想对编译打包这个过程做一点分析。任何产品，哪怕是数字产品，所追求的永远是多快好省，在更新频率要求很低的 90 年代，发放软件的方式可以是光盘💿甚至软盘💾，每次更新升级都需要插入磁盘驱动执行更新程序，这在当下点一点就能升级的体验是天壤之别了。用户的体验升级也意味着开发模式的进步，从复杂的单体架构(dll -&gt; exe)，变成了松散分布的依赖包共同组织成一个完整的应用(npm -&gt; exe)。甚至无代码开发的时候，某些重型库或包的大小已经超出了一般的应用程序，这时如何将它们有机地组合在一起，将不多也不少刚刚好的应用交付给用户，就成了开发人员需要解决的难题。 熟悉前端的朋友应该知道，JavaScript 的加载经历了纯 script 引用加载 - AMD 异步依赖的刀耕火种时期，直到 2012 年 Webpack 横空出世，才解决了打开一个页面需要加载成千上百个 js 文件的困境。这是 HTTP 1.x 的弊病所导致的，当然这个时期 JavaScript 的作用大多限于提升页面丰富度，随着 node.js 的应用，越来越多的与系统相关的包进入 npm，它们活跃在 node.js 层，却无法被浏览器使用，怎么办呢？一个办法是在浏览器里模拟操作系统，就是虚拟机，这个肯定性能有问题，pass，或者就是把系统相关的接口阉割掉，只保留计算部分，这就是 WebAssembly：将程序编译成字节码在浏览器里以汇编运行，实现了浏览器编译能力的升华；另一个办法，是把浏览器和 node.js 环境捆绑打包起来，这就是 Electron！ 个人觉得 Electron 最精髓的应用不在于可以把网页打包成桌面应用，当然也是赋予了它很多桌面应用才有的功能，比如数据库以及和系统交互的能力。最重要的是引入了 B/S 架构以后，代码的打包阶段可以被分块分层，从而使开发和构建过程各取所需，一个预想的未来是可以基于 Electron 做下一代编辑器（Visual Studio Code++ …… 大误，逃）集成了从服务端到浏览器端的全链路。当然目前比较有用的是可以选择性地不打包一些库。 开发时工具不用打包用于开发时自动重启的 electron-connect 是不用打包到生产环境的。可通过配置 1234// main-process/windowif (process.env.NODE_ENV === 'development') { require('electron-connect').client.create(window)} 123456789101112131415// rollup.configimport replace from '@rollup/plugin-replace'const config = { plugins: [ replace({ 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV) }), ... ], external: [ 'electron', 'electron-connect', ], ...} 来避免打包，在开发环境里用 node_modules 里的就好啦。 重型依赖只在生产环境下打包像 RxJS 这种重型依赖，编译打包一遍耗时巨大，我们可以把它也排除在外，具体配置如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// rollup.configimport html from 'rollup-plugin-html2'import copy from 'rollup-plugin-copy'const useBundledRx = process.env.NODE_ENV === 'development'const rendererConfig = { ...common, plugins: [ ...common.plugins, html({ externals: [ ...(useBundledRx ? [{ type: 'js', file: &quot;../assets/rxjs.umd.min.js&quot;, pos: 'before' }] : []), ] }), ], output: { globals: { electron: &quot;require('electron')&quot;, ...(useBundledRx ? { rxjs: 'rxjs', 'rxjs/operators': 'rxjs.operators', } : {}), }, }, external: [ 'electron', ...(useBundledRx ? ['rxjs', 'rxjs/operators'] : []), ],}const mainConfig = { plugins: [ copy({ targets: [ ...(useBundledRx ? [{ src: path.join(projectDir, 'node_modules/rxjs/bundles/rxjs.umd.min.js'), dest: path.join(outDir, 'assets'), }]: []) ], }) ],} 开发环境打包流程如下： copy node_modules 下的 rxjs umd 文件至输出目录 渲染进程打包文件，排除掉 rxjs，并设置其为全局依赖（window.rxjs） 在 html 中引入拷贝过去的 umd 文件 避免无谓的打包，把优化用在刀刃上这样以后，开发环境将不在打包 rxjs，而生产环境下做 tree-shaking 之后直接和业务代码合成一块，在本机加载的基础上更进一步缩小体积，利于解析。实际上，Electron 将大部分的包都直接打进 exe 文件都不会太大影响，只是为了项目目录整洁，我们还是选择尽可能多的用 bundle 过的包，无论是 npm 打包的还是我们自己 bundle 的。","link":"/blog/2020/10/10/why-we-should-bundle-source-code/"},{"title":"使用 RxJS 处理前端数据流","text":"在前端开发中，虽然大部分时间都是在”接受用户操作数据将它们发送给服务器，再从服务器拉取数据展示成 UI 给用户“，但偶尔还是会有一些操作和显示不同步的情形，例如用户不停地在搜索框输入文字，那么在用户输入的时候其实是不希望一直去网络请求“建议搜索项”的，一方面会闪烁很厉害，一方面也会发出不必要的请求，可以用防抖 debounce 和节流 throttle 函数优化输入体验。 单个组件也许只需要加个 lodash 的纯函数即可，但遇到更复杂的输入情形会是如何呢？ 实际问题问题 1：简单识别 URL 如上图所示，左侧是一个 window，从其他地方将一个带有超链接的文本复制到剪贴板之后切换到这个 window，我们希望在 window 的 focus 事件发出时能够识别到这个链接并打开。 第一版代码可能非常简单，只需要用正则表达式判断一下即可。 1234567891011121314// window.jsconst URL_REG = /(?:(?:https|http):\\/\\/)?docs\\.qq\\.com\\/\\w+/;function handleClipboardText(text) { const matched = text.match(URL_REG); if (matched) { openUrl(matched[0]) }}thisWindow.on('focus', () =&gt; { const text = clipboard.getText(); handleClipboardText(text);}) 问题 2：记忆已识别的文本 如果有多个窗口呢？希望能只在一个窗口触发一次，那就需要一个中心化的缓存值，缓存之前处理过的文本。 12345678910// main.jslet memorizedText = null;export function checkIsMemorizedText(text) { if (text !== memorizedText) { memorizedText = text; return false; } return true;} 而相应的处理单个 window 的地方需要改成这样 123456789101112// window.js+ import { checkIsMemorizedText } from 'main';const URL_REG = /(?:(?:https|http):\\/\\/)?docs\\.qq\\.com\\/\\w+/;function handleClipboardText(text) {+ const checked = checkIsMemorizedText(text);+ if (checked) return; const matched = text.match(URL_REG); if (matched) { openUrl(matched[0]) }} 进阶问题：通过 HTTP 请求获取详细数据这时产品觉得只拿到 URL 信息展示给用户没有太大的价值，要求展示成带有丰富信息的卡片格式，问题一下子变得复杂起来。 当然还是可以直接在每个 window 下去发起并接受 HTTP 请求，但这样代码就会变得越来越臃肿，该怎么办呢？ RxJS 实现数据流这时就不满足于只是能简单处理时间间隔的 lodash 的 debounce 和 throttle 函数了，我们需要可以随时掌控数据流向和速率，并且具有终止重试合并等高级功能的工具。 RxJS 作为反应式编程的翘楚映入我们的眼帘，这里简单引用一下官网的介绍。 RxJS is a library for composing asynchronous and event-based programs by using observable sequences. It provides one core type, the Observable, satellite types (Observer, Schedulers, Subjects) and operators inspired by Array#extras (map, filter, reduce, every, etc) to allow handling asynchronous events as collections. “Think of RxJS as Lodash for events.” 具体教程和 API 文档可参见官网，https://rxjs.dev/guide/overview。以及本人严重推荐程墨老师的这本《深入浅出RxJS》，可以说把基础知识和实践应用讲透了。 下面的内容需要读者对 RxJS 有基本的了解。 创建数据流我们创建了一条最基本的数据流 textInClipboard，它是所有后续操作的源头。从技术角度讲，它是一个 Subject，也就是作为触发器接受数据，也能够作为 Observable 向 Observer 发送数据。 123456789const textInClipboard = new Subject();export function checkUrlInClipboard(windowId) { const text = clipboard.getText(); textInClipboard.next({ text, windowId, });} 上面的代码创建了 textInClipboard Subject，并创建 checkUrlInClipboard 函数，在其中将当前剪贴板里的值传递给 textInClipboard，这样在 window 侧只需要调用这个方法就可以触发后面的一系列数据操作了。 12345thisWindow.on('focus', () =&gt; { const text = clipboard.getText();- handleClipboardText(text);+ checkUrlInClipboard(text);}) 数据去重创建完了接受用户操作的数据流之后，就需要对输入做去重，连续触发多次（例如用户在多个窗口间切换并不会连续识别 URL，而是只识别不同的第一个。 这在 RxJS 中非常容易实现，可以使用 distinctUntilKeyChanged 运算符。 加上常用的 filter 和 map，我们就组合出了一套简易过滤有效 URL的管道，将上面的 textInClipboard 灌进去试一试。 12345678910111213141516171819import { map, filter, distinctUntilKeyChanged } from 'rxjs/operators';const URL_REG = /(?:(?:https|http):\\/\\/)?docs\\.qq\\.com\\/\\w+/;const filteredUrlInClipboard$ = textInClipboard.pipe( distinctUntilKeyChanged('text'), map(({ text, ...rest }) =&gt; { const matched = text.match(URL_REG); if (matched) { return { url: matched[0], ...rest, } } }), filter(Boolean(e?.url)),);filteredUrlInClipboard$.subscribe(console.log); 演示一下。 发送 HTTP 请求处理完了重复的文本，下面就该将筛选出的 URL 通过 HTTP 请求去获取详细信息了。 现在前端通常使用 fetch 直接发起 HTTP 请求，得到的是一个 Promise，如何将 fetch 与 RxJS 有机结合起来？RxJS 自身提供了 from 创建符，将一个 Promise 转变成 Observable 是非常容易的。 123import { from } from 'rxjs';const fetch$ = from(fetch(someUrl)); 但这里我们对程序的可维护性和健壮性提出了更高的要求： 同时支持多个 HTTP 请求，并且将它们放在一个 Observable 里处理。 支持 HTTP 请求的错误重试及 log 功能。 mergeMap 拍平请求 针对第一个要求，可以使用 mergeMap 来将 URL 一一映射成 fetch 得到的 Observable，因为是在一个 Observable 里创建出的 Observable，所以是高阶 Observable，再将这些高阶 Observable 收集起来变成 Observable 吐出的一个个值，就成为了 docInfo$ 的新 Observable，其中每一个值都是从 HTTP 请求返回的文档信息。 12345678910import { from } from 'rxjs';import { mergeMap } from 'rxjs/operators';const CGI_URL = 'example.com/get-info';const docInfo$ = filteredUrlInClipboard$.pipe( mergeMap(url =&gt; from( fetch(`${CGI_URL}?url=${encodeURIComponent(url)}`) ))); 其实 mergeMap 原来叫做 flatMap，是不是更有拍平摊开的意味？ 带有重试功能的请求 RxJS 里的 Observable 如果出错了，默认是直接在当前 Observable 发出 error，并且终止，意味着一次失败的请求后面的请求将永远不会被发出了，这肯定不是我们希望看到的。首先我们得接住这个爆出来的 error，可以用 catchError 操作符。接下来考虑网络不稳定的情形，添加自动重试逻辑，这里会用到比较多的操作符，先将示例代码展示在这里，感兴趣的同学可以自行研究 RxJS 的重试机制，相信会大有裨益。 123456789101112131415161718192021222324import { defer, timer, NEVER, throwError } from 'rxjs';import { retryWhen, concatMap, mergeMap, catchError } from 'rxjs/operators';const CGI_URL = 'example.com/get-info';const retryThreeTimesWith500msDelay = retryWhen(errors =&gt; ( // &lt;-- projector errors.pipe(concatMap((e, i) =&gt; { console.error(`第 ${i + 1} 次失败`, e.toString()); return i &gt;= 3 ? throwError(e) : timer(500); }))));const docInfo$ = filteredUrlInClipboard$.pipe( mergeMap(url =&gt; ( defer(() =&gt; fetch(`${CGI_URL}?url=${encodeURIComponent(url)}`)).pipe( retryThreeTimesWith500msDelay, catchError((error) =&gt; { console.error(`获取 url=${url} 的信息失败`, error.toString()); return NEVER; }) ) ))); 这段代码做了很多事情，retryThreeTimesWith500msDelay 里的 retryWhen 接受一个 projector 函数，传入的 errors 是一个 Observable，它在上游每次报错时吐出一个值 e，这里可以拿到 e 和索引 i，而这个 projector 返回的 Observable 一旦发出值就会重新 subscribe 上游 Observable（相当于再来一次），而当它报错时，这个错误将会抛给上游 Observable 并完结，是不是听的一头雾水？看看 GIF 图吧。 然后特别需要重点注意的是，这里替换掉了 from 创建符，而使用 defer 代替，为什么？ 因为 from 是 hot observable，也就是无论有么有被订阅都会自顾自发出值，并且再次订阅后也不会重复发出已有值，就像直播一样。而 defer 则像是点播，它是 cold observable，每次被订阅都会重新走一遍流程。 这点非常重要，所以在需要重复操作的地方还是需要 defer 来重复创建可利用的 Observable。 而在最后我们 catchError 里，处理掉错误信息并打 log 后，直接返回 NEVER，也就意味着这个错误将消失在漫漫长河里，不会对下游造成影响。 接受 HTTP 请求的结果一般而言，订阅一个 Observable 只需要 subscribe 即可，但这里出了一点小小的问题，还记得上面传入 checkUrlInClipboard 的参数 windowId 吗？我们需要给不同的 window 订阅不同的 URL 检查结果。如果同时 subscribe 一个 Observable 多次会发生什么？ 答案是 subscribe 几次中间的 pipe 过程会走几次，这与我们所期望的不一致啊，总不能为了每个 window 发一次 HTTP 请求？ 甚至可能出现多个请求返回结果不一致的情形，那就乱套了。 事实上前面所用的 RxJS 操作符都是单播，也就是一对一，如果要一对多的话需要用到 multicast，但其实还有先后订阅的问题，这里就不展开了，可以参见这篇文章。我们直接使用 share 来共享这里的 HTTP 请求。 12345678910111213+ import { share } from 'rxjs/operators';const docInfo$ = filteredUrlInClipboard$.pipe( mergeMap(url =&gt; ( defer(() =&gt; fetch(`${CGI_URL}?url=${encodeURIComponent(url)}`)).pipe( retryThreeTimesWith500msDelay, catchError((error) =&gt; { console.error(`获取 url=${url} 的信息失败`, error.toString()); return NEVER; }) ) )),+ share(),); 加完以后可以清楚地发现 HTTP 请求只发送了一次！至此我们已经完美地按照产品的需求完成了「多 window 并发检查剪贴板中 URL 数据」的开发，整个流程使用 RxJS 划分地整整齐齐。在 window 调用处只需要简单地调用 checkUrlInClipboard 并订阅相应的 docInfo$ 即可轻松接入剪贴板监听功能，so easy。 12345678910thisWindow.on('focus', () =&gt; { const text = clipboard.getText(); checkUrlInClipboard(text);});docInfo$.subscribe((info) =&gt; { if (info.windowId === thisWindow.id) { openDialog(info); }}); 拓展边界如果这时产品经理告诉你又有新功能了，需要支持进程间共享剪贴板状态，WTF!如果平时可能就骂娘了，但 RxJS 基于流和操作符的特性拯救了所有的不开心，因为肯定有个 master 进程，只需要在 master 存一份检查过的 URL 文本就可以啦。 1234567891011121314151617const filteredUrlInClipboard$ = textInClipboard.pipe(- distinctUntilKeyChanged('text'),+ mergeMap((payload) =&gt; (+ from(checkIfUrlChangedInMaster(payload.url)).then(isChanged =&gt; isChanged ? payload : null)+ )),+ filter(Boolean), map(({ text, ...rest }) =&gt; { const matched = text.match(URL_REG); if (matched) { return { url: matched[0], ...rest, } } }), filter(Boolean(e?.url)),); checkIfUrlChangedInMaster 是与 master 通讯的异步方法，如果检查与前一次不同则返回 true，否则返回 false。 RxJS 的意义这里给出上面各种操作的示例代码，可以实际修改并操作感受下 RxJS 的魅力。 https://stackblitz.com/edit/rxjs-check-clipboard-demo?file=index.ts RxJS 单向数据流的设计符合函数式编程、纯函数单一输入输出无副作用的趋势，其强大的根据时间参数操作变量的能力给予了前端在处理并发事件时从容不迫的信心。 最后放张老图~","link":"/blog/2021/04/11/use-rxjs-to-handle-data-flows/"},{"title":"前端文件打包优化","text":"前端开发除了 HTML 模板外最重要的就是 JS/CSS 文件了，现今开发者都是本地书写 ES6/Stylus/Sass 然后经打包发布至 CDN 等环境，于此带来的问题是一些不需要的代码被打包了进来，甚至更严重的是一份代码被打包几遍。当然，Webpack 这样的工具出现就是为了解决这些问题，不过考虑到打包过程是一次性的编译，运行时代码的区别仍然需要开发者手动对待。 JavaScript1. 重复打包了类库文件 上图中可以看到 vendor 和 setup 里都有 backbone、underscore 和 zepto 等库文件，这是为什么呢？ 原因是当我们引入 splitChunksPlugin 时仅将 /node_modules/ 下的文件纳入 vendor 范围，但在 entry 处又定义了包含通过 bower 安装的 backbone、underscore 等类库的 vendor，见下面两图。 如图所示将 /public/js/lib 写入 optimization.splitChunks.cacheGroups.vendor.test 就可以了，结果如下图。 2. 类库文件无法自动剔除无用代码像 date-fns 和 RxJS 这样 battle tested 的库，从早期原型链（prototype）实现到现在拥抱函数式的历史进程中无可避免地引入了很多历史负担，比如下图中 date-fns/esm 就非常巨大，里面很多都是我们暂时不需要的功能。 好在它们文档都比较全： RxJS Pipeable Operators date-fns ECMAScript-Modules 如下图一顿修改。 见证奇迹的时刻！ 3. 运行时才能确认使用的重依赖模块 一个 React App 内竟然出现了 jQuery 依赖 …… 一定是哪里出了问题，经过不懈的努力，终于找到了是在 web 和 mobile 公用的组件里用了微信支付的 module，而这个 module 开头就直接引入了 backbone/underscore/zepto 三大金刚 …… Webpack 编译时并不能知道运行时究竟在不在手机环境，怎么办呢？我们可以通过 webpack require AMD 模式 来拆分代码。 其实这个打出来的 34 号包永远也不会被 import …… CSS1. 重复 CSS Variables 定义开发小王接到了一个任务，改进项目 css 代码以支持当下新出的黑夜模式（Dare Mode），小王犯了愁，一个个颜色变量替换也太苦逼了，小王挠挠头想出了一个在 source 文件定义 CSS Variables 的方法。 看起来非常完美，但不足之处是这堆 CSS Variables 每次 import 都会被定义一遍，结果就是有多少 stylus 文件就被重复定义了多少遍 …… 不要问我为什么要用 import 而不是 require …… 我们知道 Stylus 是一种 css 的预编译器，它的变量和 CSS Variables 是不一样的，CSS Variables 是会编译到生成的 CSS 文件里，而 Stylus 变量则会在编译中承担一次桥梁的作用之后悄悄消失。可以通过比对 Stylus 变量是否已经赋值 var(--css-variable) 来判断是否需要定义 CSS Variables。 成果就是从有多少 stylus 文件就有多少次 CSS Variables 定义缩减到入口文件那么多个数的定义，足足降低了一个数量级，打开 Chrome DevTools &gt; Elements &gt; Styles 终于不卡了！","link":"/blog/2019/12/03/%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/"},{"title":"丝般顺滑的 Electron 跨端开发体验","text":"简介减化软件开发复杂度的核心奥义是分层与抽象，汇编语言抹平了不同 CPU 实现的差异，做到了”中央处理器”的抽象，而操作系统则是抽象了各种计算机硬件，对应用程序暴露了系统层的接口，让应用程序不需要一对一地对接硬件。 回到这篇文章的标题，目前主流的桌面端主要为 Windows、macOS 和 Linux 三种，考虑覆盖人群，实际做到覆盖前两端即可覆盖绝大多数用户。或许有同学就要问了，都 2020 年了还有必要开发桌面端应用吗？？Web 它不香吗？答案是：香，但它还不够香。网页因为各种安全方面的限制，现在还无法很好地和系统进行交互，比如文件读写（实际已经有了 Native File System [https://web.dev/file-system-access/）和更改各种系统配置的能力，这些往往是处于安全和兼容性的考虑。如果想强行在 Web 里做到这些部分也不是不可以，但相对普通 Web 开发，成本就显得过高了点，这点先按下不表。 俗话讲”酒香不怕巷子深”，Web 在富 UI 应用的场景下已经一枝独秀遥遥领先于其他 GUI 方案，像早期 Qt、GTK 等跨端 GUI 开发方案已经几乎绝迹（PyQt 还过得比较滋润，主要是 Python 胶水语言的特性编写简单界面比较灵活），随着移动端浪潮的袭来以及 Node.js 的崛起，更多开发者选择 JavaScript （包括附属于其上的语言和框架）进行跨桌面、移动端和 Web 的混合开发，像 Ionic、Cordova(PhoneGap) 等框架在 2011 年以后如雨后春笋般冒了出来，当然随着 Facebook 和 Google 发布 React Native 和 Flutter，广大 Web 开发者终于可以喘口气，看到了只学一种框架就用上五年的曙光。 移动端的竞争如此激烈，但桌面端则目前只有一个王者，那就是 Electron。我们来看看它究竟是什么? 这个问题的答案很简单，Electron 就是 Chromium（Chrome 内核）、Node.js 和系统原生 API 的结合。它做的事情很简单，整个应用跑在一个 main process（主进程） 上，需要提供 GUI 界面时则创建一个 renderer process（渲染进程）去开启一个 Chromium 里的 BrowserWindow/BrowserView，实际就像是 Chrome 的一个窗口或者 Tab 页一样，而其中展示的既可以是本地网页也可以是线上网页，主进程和渲染进程间通过 IPC 进行通讯，主进程可以自由地调用 Electron 提供的系统 API 以及 Node.js 模块，可以控制其所辖渲染进程的生命周期。 Electron 做到了系统进程和展示界面的分离，类似于 Chrome或小程序的实现，这样的分层有利于多窗口应用的开发，天然地形成了 MVC架构。这里仅对其工作原理做大致介绍，并不会详尽阐述如何启动一个 Electron App 乃至创建 BrowserWindow 并与之通讯等，相反，本系列文章将着重于介绍适合 Web 开发者在编码之余需要关注的代码层次、测试、构建发布相关内容，以「腾讯文档桌面端」开发过程作为示例，阅读完本系列将使读者初步了解一个 Electron 从开发到上线所需经历的常见流程。 在这里，笔者将着重介绍与读者探讨以下几个 Electron 开发相关方面的激动人心的主题： 我只有一台 MacBook，可以用 Electron 开发出适用于其他平台的 App 吗？ 我需要为不同平台分发不同的版本吗？它们的依赖关系如何？ 如何让用户觉得我开发的应用是可信任的和被稳定维护的？ 我想让用户在”更多场景”下使用我的应用，我该怎么做？ 我是一个 Web 开发者，Electron 看起来是 C/S 架构，应该如何设计消息传递机制？ 用 Electron 开发的 App 可测试性如何，可以在同一套测试配置下运行吗？ 不用担心，以上问题的回答都是”Yes，Electron 都能做到”。下面我们就进入第一个主题吧，如何构建你的 Electron 应用。 打包应用首先我们假定你已经创建了一个 main.js 的文件，同时创建了一个名叫 renderer.html 的文件用于展示渲染内容，这时候你就可以直接将这个文件夹压缩后发给你的用户了，请用 Terminal 切换到该文件夹下，键入 electron . 并回车即可运行应用，全文完！撒花 ✿✿ヽ(°▽°)ノ✿ 当然不是这样简单，我们需要交付的是一个完整的独立运行的 App，至少我们得把代码和 Electron 的可执行文件都打包进去。但首先第一步是，既然用户是下载了一个大几十 M 的 App，我们是不是可以直接在 App 里 serve 源码了？简而言之，是的，你可以将你的源文件连同 node_modules 一起发给用户，但是 —— 巨巨…… 怕了怕了，并且直接 server 源代码也可能会将一些敏感信息或者你写得不咋滴的代码直接暴露给用户，带来不必要的安全风险。这里介绍一下使用 Webpack 和 Rollup 打包 Electron App 的关键代码： 使用 Webpack 打包用 Webpack 打包还是相对简单的，只需要将 config.target 设置成 ‘electron-main’ 或者 ‘electron-renderer’ 即可 1234// webpack.config.jsconst config = { target: 'electron-main' | 'electron-renderer'} 其原理是对不仅包括 Node.js 原生模块，同时也包括 Electron 相关模块都不打包了，交给 Electron 自己在运行时解决依赖，见链接：webpack/ElectronTargetPlugin.js#L24-L64 使用 Rollup 打包既然实际项目中都是拿 Webpack 打包的，何不尝试下新的方式呢，Rollup 作为打包 npm 模块的最佳工具，想必也是能打包 Electron 应用的吧…… 但 Rollup 就没有这么简便的配置方式了，需要做一番小小的手脚： 1234567891011121314151617181920// rollup.config.jsexport default [ { input: 'src/main-process/main.ts', output: { format: 'cjs', }, external: ['electron'], }, { input: 'src/renderer/index.tsx', output: { format: 'iife', globals: { electron: &quot;require('electron')&quot;, }, }, external: ['electron'], },] 解释一下，format 为 ‘cjs’ 或 ‘iife’ 是表明适用于 Node.js 环境的 commonjs 或者是浏览器环境的立即执行格式，而他们同样都需要将 electron 设置为外部依赖，同时在渲染进程里还需要指定 electron = require('electron');。等等，这里竟然在 window 下直接 require？？？是的，通过创建 BrowserWindow 时设置 nodeIntergration: true 即可在打开的网页里使用 Node.js 的各种功能，但能力越大所承担的风险也越大，所以是得禁止给在线网页开启这个属性的。 这里还有个类似的属性 enableRemoteModule。 它的含义是是否开启远程模块，这样就能直接从渲染进程调用主进程的一些东西，但这样做同样有包括[性能损耗在内的一系列问题]{.ul}，所以 Electron 10.x 以后已经默认关闭了这个开关，手动开启同样需要慎重。 不进行打包的依赖虽然 node_modules 确实很大，但因为是桌面应用，总有些库或者包里的内容是不需要或者说没法去打包的，这时候就要将他们拷贝到生成文件夹里去，比如项目里用到的 levelDB 针对 Windows 32 位和 64 位以及 macOS 都有不同的预编译文件，这时将它们直接拷贝过去就好啦。 构建完成后，我们的应用已经有了直接 electron . 跑起来的能力，离可发布的 MVP 只差打包成可执行文件这一步了！ 构建可执行文件将代码打包成可执行文件同样需要市面上的第三方解决方案，有 electron-packager 和 electron-builder 可选，实际比较下来 electron-builder 提供了包括安装和更新在内的一系列流程，体验极好，所以只以其作为构建工具作介绍。 electron-builder 也是一个对开发代码无侵入的打包构建工具，它只需要指定好各种路径以及需要构建的目标配置即可一键完成打包构建、签名、认证等一系列流程。 electron-builder 是具有同时打包出多个平台 App 的能力的，具体在 Mac 上是通过 Wine 这个兼容层来实现的，Wine 是 Wine Is Not an Emulator 的缩写，从名字里强调它不是一个模拟器，它是对 Windows API 的抽象。打包后的应用与 Windows 上构建的应用没有区别，但构建时的 process.platform 会被锁在 ‘darwin’ 即 macOS，这是个看起来微不足道，但实则遇到会让人抓耳挠腮的情形，后面会详细展开。 但 Windows 就没有这么好运气了，笔者并没有找到可以在 Windows 上打包出 macOS 可用执行文件的方式，所以上面的同时出两个平台可执行文件的方式亲测还是只能给 macOS 用的。 自动升级electron-builder 提供了生成自动升级文件的能力，配置好对应平台的 publish 字段后会同步生成升级 yml 文件，将它们和安装包一起上传到 CDN 并配置 electron-updater 即可以实现自动升级。 配置 electron-updater 需要注意以下三点： electron-builder 会在应用打包时偷偷塞进去一个 app-update.yml，本地开发时没有读到相似的开发配置会无法调试，需要手动复制一份并重命名成 dev-app-update.yml 放到开发目录下才能继续升级，但最后一定会自动升级失败，因为开发时的代码没有签名。 electron-updater 会去读 package.json 文件的 version 字段，如果是主目录和 App 目录不相同的开发模式的话，需要手动指定 autoUpdater.currentVersion。同样需要手动指定的还有 autoUpdater.channel，这里有个 bug，mac 虽然用的是 latest-mac.yml 文件但 channel 却要设置成 latest，electron-updater 似乎会自动补上 -mac 字样。 与 macOS 静默升级不同，nsis 包的 Windows 升级动静很大，所以如果用户不是想立马升级的话最好将 autoInstallOnQuit 设置成 false，否则用户就会惊奇地发现哪怕取消了自动安装还是在退出后立马更新了。 123autoUpdater.currentVersion = APP_VERSION;autoUpdater.autoInstallOnAppQuit = false;autoUpdater.channel = os.platform() === 'darwin' ? 'latest' : 'latest-win32'; 文件关联在移动端 App 大杀四方，Web 大行其道，小程序蠢蠢欲动的当下，一个桌面应用的生存空间是极其狭小的，通常都不需要什么竞争对手，可能自身产品的其他端就把自己给分流耗竭而亡了……我们提到桌面端，不得不提的就是文件系统了，如果 iPhone &amp; Android 都有便捷好用的文件管理系统，那感觉桌面端的黄昏真的就来到了。 但这里首先还是看一看 electron-builder 可以给我们带来什么能力吧。 系统关联文件类型这就是文件右键菜单里的打开方式了，设置方式也很简单，通过设置 electron-builder config 里的 fileAssocaitions 字段即可。 12345const config = { fileAssociations: { ext: ['doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'pdf', 'txt', 'csv'], }} QQ AIO 结构化消息打开应用（Windows）QQ 通过唤起写入注册表里的腾讯文档地址来打开腾讯文档 App 同时带上了 –url=https://docs.qq.com/xxx 的参数，继而打开对应的文档。 electron-builder 配置 nsis.include 参数带上 nsh 脚本，写入如下设置（注：该配置并不完全）即可帮助 QQ 定位已安装的腾讯文档应用。 1WriteRegStr HKLM &quot;SOFTWARE\\Tencent\\TencentDocs&quot; &quot;Install&quot; &quot;$INSTDIR&quot; NSIS 脚本还可以做很多事情，比如卸载 App 后清理数据或者检查是否安装了老版本等，具体可参见其官方文档。 12Delete &quot;$APPDATA\\TDAppDesktop\\*.*&quot;RMDIR /r &quot;$APPDATA\\TDAppDesktop&quot; 在 QQ 发起消息后，文档这边需要支持解析所带的参数，从进程参数中解出相关信息再打开对应 Tab 页面。 1234const args = process.argv;if (argv.length &gt; 1) { handleCommandArguments(argv.slice(1));} 小结本文简述了通过 Electron 构建应用过程中采用不同方式和配置打包文件、使用 electron-builder 构建可执行文件，同时用其提供的功能实现自动升级与文件关联，完成了在单个平台（macOS）开发并构建出跨端应用的任务。笔者接触 Electron 开发时间较短，行文中多是开发中所见所闻所感，如有错误纰漏之处，还望读者不吝包涵指正。后续文章将介绍在跨端开发中处理兼容性时遇到的问题，以及如何优雅地在产品设计和功能间进行取舍。","link":"/blog/2020/11/02/%E4%B8%9D%E8%88%AC%E9%A1%BA%E6%BB%91%E7%9A%84Electron%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C/"},{"title":"Electron 客户端自动更新","text":"随着科技的进步，啊不，是网络通信技术的提升，客户端用户不再受限于拨号上网那样的小水管，百兆宽带触手可达，随时随地自动更新版本成为了标配。作为跨端框架的翘楚，Electron 自然也是内置了自动更新功能，但查阅其官网发现其提供的 autoUpdater 并无明确的操作路径可言，读完仍是一头雾水，尤其是还需要私有 CDN 部署时更是两眼一抹黑。 让我们从零开始，更新逻辑其实很简单，每次发版时将更新文件分发到 CDN 上，客户端通过检查 CDN 上有无更新文件继而下载文件并安装即可完成更新。抛开上传下载这种技术问题不谈，要解决两点： 什么版本可以更新 可以更新到什么版本 说人话就是从哪儿来，要到哪儿去。本文将要为你解答的就是如何通过一系列配置服务及本地设置，完成包含灰度更新、强制更新、静默更新以及 GUI 更新过程展示在内的可操纵动态更新策略。 发布与更新首先确定一点，我们依然用的是 Electron 提供的更新功能，但主要用了 electron-builder 封装后的 electron-updater。这里的文档和 Electron 官方文档比较类似，有点啰嗦，下面就使用自定义 CDN 这条路提纲挈领地给大家梳理关键步骤。 生成制品信息这里假定你一定是通过 electron-builder 进行打包了，需要在 electron-builder-config 中加入如下字段（详细字段配置） 12345678const config = { ...others, publish: { provider: 'generic', channel: 'latest-win32', url: 'https://your.cdn/update-path', },} 这里假设你的更新文件会被放在 https://your.cdn/update-path 目录下，通过这个配置打出来的安装文件就会多出一个 latest-win32.yml 文件，这个文件长下面这样子。 这里面主要包含了版本号、更新资源文件的文件名及校验 hash 及发布日期等关键信息，对于后续步骤最重要的就是资源的文件名了。 将安装包与 yml 文件一起上传到 CDN 的 https://your.cdn/update-path 目录下就完成了生成制品信息的这一步。 配置自动更新信息来到这一步需要保证 https://your.cdn/update-path/latest-win32.yml 已经是可以访问到的了，后面就是如何在端内把 electron-updater 支棱起来。 首先安装 electron-updater: npm i electron-updater。这里作者实操中有个问题，electron-updater 打包后失效了，暂未明确原因，故在 webpack 中将其设为 externals 并在最终由 electron-builder 打包的目录 projectDir 里安装了 electron-updater。 接下来，为了开发调试我们需要做一点骚操作，在下图所示目录中有 app-update.yml 文件。这个文件里面内容是这样的，将它复制到项目根目录下并改名叫 dev-app-update.yml，后面就能调试更新了。 需要说明的是，macOS 上自动更新只有在签名后的 App 上才能进行，在后续步骤的退出并安装前会校验签名，校验失败时会报错。 自动更新进入激动人心的代码环节！ 12345678910111213import { autoUpdater } from 'electron-updater';// 设置为指定发布版本，以防错读为 Electron 版本autoUpdater.currentVersion = APP_VERSION;autoUpdater.setFeedURL({ provider: 'generic', channel: os.platform() === 'darwin' ? 'latest' : 'latest-win32', url: `https://your.cdn/update-path`,});autoUpdater.checkForUpdates();autoUpdater.on('update-downloaded', () =&gt; { autoUpdater.quitAndInstall();}); 对，就是这么简单，一旦下载更新完成立即以迅雷不及掩耳之势退出 App 进行更新并重启。这是不是太快了点？都没留给用户反应的时间了。别着急，可以通过 autoUpdater 上的各种事件，参考这篇文章做一个漂亮的更新界面出来。https://blog.csdn.net/Wonder233/article/details/80563236 autoUpdater 事件： error checking-for-update update-available update-not-available download-progress update-downloaded 精细化更新静默更新如果把上面的退出更新步骤去掉，离静默更新就只差一步了。 1234+ autoUpdater.autoInstallOnAppQuit = true;- autoUpdater.on('update-downloaded', () =&gt; {- autoUpdater.quitAndInstall();- }); 至这一步为止，你已经做完了一个不断更新到最新版本的 Electron App 所需要的一切了。 强制更新即使你设置了每次都会自动更新，依然免不了有用户不肯买账，或者说会在各种网络差的情况下没法及时更新到最新版本，我们可以通过下发一个配置文件，来控制一些有废弃 API 或者有严重 bug 的版本被继续使用。 例如在配置系统上生成一个如下的配置，其中 force_update_version_list 就是一串 semver 规范的版本范围。 在使用时只需要判断一下 APP_VERSION 是否在这些个区间内即可。 123456import * as semver from 'semver';const config = await fetchUpdateConfig(key);const forceUpdateVersions = config.force_update_version_list;const shouldForceUpdate = forceUpdateVersions.length &amp;&amp; semver.satisfies(APP_VERSION, forceUpdateVersions.join('||')); 这里在发出拉取更新配置请求时出现了一个 key，这个 key 提供了本地去决定使用哪个配置组的能力，比如测试就填 Test，线上默认为 Production，方便测试。 灰度更新强制更新解决了哪些版本必须更新的问题，如果我们只想让某些版本或是用户更新到指定版本呢？这也就是通常所说的金丝雀发布、A/B 测试之类的了。同样可以用从网络拉取一个配置文件来解决，正好内网配置平台也满足我们的这种需要。 配置下发首先配置系统支持根据 uin、ip 等进行灰度发布，我们选择了将 uid 后两位截取为 uin 上传到灰度名单，配置系统拿到上传的 uin 后根据灰度规则（上图配的是 30% 的比例）下发最新更改的配置项。 直至 100% 比例后，可以进一步替换官网链接，完成全量发布。 更新路径划分聪明的读者已经发现了，在发布与更新中，我们设置了统一的更新目录 https://your.cdn/update-path，如果有不同的更新版本，我们就需要设置不同的文件或是目录来控制。该用哪一种呢？ 版本排布方式 优势 劣势 按目录 一个目录一个版本 无统一更新地址 按文件 目录层级扁平 文件混杂难分清 综合考虑后，我们选择了按目录划分版本的方式。 在上面的自动更新代码中替换如下内容即可享受精细控制的灰度更新功能。 12345678910111213141516import { autoUpdater } from 'electron-updater';+ const config = await fetchUpdateConfig(key);// 设置为指定发布版本，以防错读为 Electron 版本autoUpdater.currentVersion = APP_VERSION;autoUpdater.setFeedURL({ provider: 'generic', channel: os.platform() === 'darwin' ? 'latest' : 'latest-win32',- url: `https://your.cdn/update-path`,+ url: `https://your.cdn/update-path/${config.version}`,});autoUpdater.checkForUpdates();autoUpdater.on('update-downloaded', () =&gt; { autoUpdater.quitAndInstall();}); 尾声按渠道分发更新和下载一样是为了分发，当我们有了更多渠道时也可能需要考虑渠道间的差异性。渠道包可以通过配置文件进行区分，更新时只更新资源而不更新配置文件，这样就可以做到不同的安装渠道在同一更新下保持自身渠道特殊性。 永远递增你的版本号The lastest, the best.","link":"/blog/2021/09/16/electron-update/"},{"title":"再谈业务逻辑","text":"我面试过一些岗位，也面试过很多人，基础的岗位问的最多的大概就是对框架的理解，对语言基础的掌握等等，但如果是高级岗位往往问到对市场大环境的感悟和对业务逻辑的理解，体现了工具的应用必然是为完成目的服务的标准。 实际开发中，由于前后端现在工种的分离，业务逻辑的归属是很大的问题。 后端面向数据库和第三方服务集成，数据库总是以最小业务模型为基准，考虑扩展性进行建模，而第三方服务与领域模型融合则需要对业务逻辑进行抽象化，比如支付接口需要考虑本身提供的商品种类和第三方支付的种类进行分别编码并抽取公共逻辑，常见的形式有 Adapter（适配器模式）等。 前端当下也很复杂，虽然有了一些基础组件，但随着业务的深入，组件上难免多出很多随着各种特殊使用场景分别配置的参数，甚至一个组件接受几十个参数来配置，可能也有同学一看这不行啊，感觉封装了几个配置好的组件供业务使用，但上面的过程多了以后，组件变得又深又长，深体现在封装层级上，长体现在单个组件的长度上，比如封装一个电子书的展示列表。 图片 -&gt; 封面 -&gt; 带标签的封面 -&gt; 电子书 -&gt; 书籍列表 -&gt; 可无限加载的书籍列表 这时如果要把「图片的尺寸」或者「可点击与否」传递给最内部的组件，就需要一层层从上面传下来，React 有 context 方法来在组件间传递参数，但这毕竟是不可见的，需要自己去 useContext 来得到。ES6 中提供了 Reflect 对象，比如 Reflect.getMetadata('design:paramtypes', target) 可以得到在参数里定义的参数类型，Angular 的控制反转和依赖注入就是依靠这实现的。这为我们提供了一些可以想象的思路，当然本质上它只能解决编码上的便利性，组件的层级和复杂度并没有因此降下来。 当前前后端通讯主要靠两种方式 首屏页面内 script 注入初始数据 AJAX 接口 阅读站新的接口优先考虑 GraphQL，GraphQL 是一种面向领域模型的非常好的查询语言，我们不再需要多次往返前后端通讯获得更多数据，或者是重复定义各种 build_xxx_entity，只需要一次定义，任何用到单个字段的地方都只用写字段名就可以使用，可以说极大地降低了边际成本，而且越用收益越高。当然有同学会问那如果大批量查询的问题呢？Facebook 给出了 DataLoader 的方案，但我们的 peewee 版本以及早期的 hack 写法限制了我们真正将 ORM &lt;==&gt; GraphQL 的过程，现在其实是手动 ORM &lt;==&gt; 字段，带缓存的字段 &lt;==&gt; GraphQL。 当后端和接口都做到了尽量少耦合业务逻辑时，业务逻辑就大量堆积在表单 POST 接口和前端展示逻辑上，又因为表单校验因 js 和 python 没法互通，需要前后端分别实现，而展示逻辑则是大多硬编码在组件内。这点其实很吓人。表单方面有 JSON Schema 的方案，但因为 Python 这种胶水语言快读开发的节奏每每难以落地，只是可惜展示上没法脱离业务组件进行编码，之前有过在 App 上设计根据 type 来组合 widget 的展示形式，但一旦需求变动代码就变得非常臃肿。 一种现有的整理业务逻辑的形式是把 Business Logic 存到数据库中 …… 简单来说，如果数据库可以方便地表达因果关系，或许这是一种可行的方案。还有就是很通用的配置文件方式，也是我们搭建开发环境的方式，通过脚本配置在环境初始化时载入一系列的变量最终构建出符合业务需要的开发环境。 理想的情形可能是，前端只提供组件库和组件间的组合逻辑，后端只提供数据的存储和加工工具，业务逻辑由第三方提供配置，设置极限值和用户可选值，用户可以在享有最多自主权的情形下使用 web 产品，当然这也只是一种美好的愿望……毕竟当下都是想把产品做到尽善尽美，只给用户一种最好的选择，可这是不是用户想要的呢？做得越多也许越错呢？没有人真的会去想，大家都是假装想想罢了。","link":"/blog/2020/01/17/%E5%86%8D%E8%B0%88%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/"},{"title":"媒介即是信息","text":"Twitter 决定了信息的载体只有 140 个字与 9 张图片，大部分人的思维方式也就停留在此，但抖音等短视频跳了出来，表示 15 秒钟的短视频能传递更准确的信息。","link":"/blog/2019/03/09/%E5%AA%92%E4%BB%8B%E5%8D%B3%E6%98%AF%E4%BF%A1%E6%81%AF/"},{"title":"并行化密集型计算","text":"稍早前对 terser 压缩代码进行优化时将执行过程的代码从 Python 迁移到了 Node.js，准确地说是试图用 gulp stream 来批量压缩，用了一个比较老的包（gulp-terser），已经很久不维护了。与原先相比，底层都是 terser，只是为了在 Node.js 的镜像下使用而统一了文件的提取（glob）和批处理过程（Python Pool &amp; subprocess -&gt; gulp stream）。 但这样处理了以后发现压缩处理时长变长了很多，差不多慢了 1 分钟，研究了一下 gulp 的处理机制，发现虽然 gulp 号称流式处理，但文件依然是按个通过 pipe 的，前一个处理完下一个才能进入，但通过 parallel-transform 也能实现同时处理多个文件，可是实际操作中以 parallel-transform 替代 through2 并不能提升处理效率。笔者并未实际深究其原因，大致读了下 parallel-transform 的实现，它依然是围绕着 event-loop 做文章，设想成一个水池，干涸了就加水，满了就停止并等待处理完毕抬高基准线。 笔者甚至使用了 RxJS 来控制并发 …… 但事实证明还是自己太年轻了，这种密集型计算根本无法通过 event-loop 来优化，它和 ajax 或者 IO 操作不一样，处理数据的仍是这个进程，怎么办？那就多进程/多线程！ 问题就变得简单了起来，第一步把文件列表拿到，第二步把它们分发到其他进程/线程处理。 首先想到的是 gulp.src 接受的是数组，而 glob 接收的是字符串，实现肯定不一样，事实证明果然相差甚远。想想看还是需要先拿到本着能不造轮子就不造轮子的思路，去网上搜搜代码，首先想到的是已废弃的 gulp-util。一看里面有个 buffer 符合我们的需要，直接抄来，只不过需要注意一下这里有个 cb 需要塞到 fn 的回调里去，这样才能准确得到 task 的总共执行时间。 123456789var end = function(cb) { this.push(buf); --- cb(); --- if(fn) {fn(null, buf); +++ if (fn) { +++ fn(null, buf).then(cb) +++ } }}; fn 是个耗时的操作，必须再它完成后再 cb 然后按照 terser 和 child_process 的关键词找到了 @bazel/rules_nodejs - terser 这个包，简直是宝藏 …… 一顿大抄特抄，写死了 terser 执行参数，加了个 Promise 的返回值。上 pre 跑了一下，功德圆满！ 为啥这么快？看了下 CPU 数量，我惊呆了！ 顺便看了下 issue 里也有试图引入 works_thread，不过 child_process 已经足够香了！ 不过 web 上毕竟一个 page 只有一个进程，所以要有 Web Worker 来让密集计算在主线程之外运行，而可预计到的是 Web Worker 和 work_thread 的关系就好比 wasm 和 wasi，激动人心的进展！","link":"/blog/2020/05/28/%E5%B9%B6%E8%A1%8C%E5%8C%96%E5%AF%86%E9%9B%86%E5%9E%8B%E8%AE%A1%E7%AE%97/"},{"title":"排序","text":"算法中的排序算是老生常谈的问题了，不过我的问题是生活中真的有那么简单只需要按照一个值从小到大排列的需求吗？ 如下图在 App 端变成了这样 显然这些已注销用户是在不同时间关注的，web 上将他们混排了，App 上则是单列在最后，前一种强调了关注顺序，后一种强调了社交性（注销账号当然再也没有了社交价值）。并且 App 理论上不太会有用户真的去翻到最后一条，Elastic Search 默认最大条数是 10000，恐怕意义也是如此。 当然排序在程序上而言也就一行代码的区别，不过在产品上区别可是很大，是在从一个笔记本在向电话簿转变。 这一切是否预示着我们每个人之间的关系都是从路人成为朋友，然而最终将深埋通讯录底不见天日，直到天人永隔。 谁都只能陪谁走一段路，但这条路毕竟是要靠自己走完。 行色秋将晚，交情老更亲。","link":"/blog/2019/03/19/%E6%8E%92%E5%BA%8F/"},{"title":"时滞效应","text":"在股市的朋友一般都知道「K 线图」这个东西，简单说来就是包含四个数据，即开盘价、最高价、最低价、收盘价，所有的 K 线都是围绕这四个数据展开，反映大势的状况和价格信息。我的姨夫号称一代股神，开一次张可以吃三年，特别崇拜这个图。我个人是有些不以为然的，因为 T + 1 制度的存在杜绝了超短线投机。任何时刻的交易都是基于前一时刻的交易，如果这种方式是靠谱的，那也只是扒下了边际效益的薄薄一层皮而已。如果要做超短线就是期货了，曾有个笑话说炒期货的要尿个尿都要把手上的先抛掉才敢去尿。这就是时滞效应。 当前华夏大地处在一片新型肺炎疫情的阴霾笼罩之下，时隔 1 – 14 天不等的发病周期，让防疫工作困难重重。一旦某个小区发现感染病例，整个小区都会被隔离。我们可以看下下面这张疫情趋势图，图中可见疑似病例一开始是低于确诊病例的，但年初二之后突然呈井喷般上升趋势，但幸好当下已经逐渐趋于平稳。 没有疑似病例意味着什么，意味着毫无病例筛查。疑似病例井喷说明什么，说明堆积了足够多的样本上报。量变引发质变，足够多的病例将导致疾病向着失控的方向蔓延，而这一切在确诊病例上是延时的，不确切的。所以需要更多的筛查渠道和病毒检测盒，而现在更可怕的是病毒会“伪装”自己，在感染的前 10 天并无法检查出阳性，这样就给医学意义上的密切接触者数量更提升了一个数量级。 而反观政府现在在做什么？隔离，对，隔离是必要的。区域自治，区域封锁，假期延长，将蔓延的机会降到最低。另外一点，隔离使得城市面临生活必需品保障短缺的问题，各级政府苦心经营的第三产业在疫情面前已经濒临瘫痪，第二产业随着机器人的大量应用其实已经实现了自治，但第一产业 —— 农业，依然是需要保障的重中之重，农产品需要从城市就近通过内部交通网络输送到各家各户，而这些都是都市人口已经很久很久没有考虑过的了。 所以说，这次疫情之类最应当做的两个工作是： 深化医疗行业的规范改革，切实保障一线医务工作者的安全以及避免就诊患者交叉感染。 大力发展现代农牧业，例如屋顶大棚果蔬养殖和人工智能养猪等等，保障危急时刻群众吃饭问题。 都市人已经习惯了吃饭了叫个外卖，生病了挂个号慢慢排队的日子，这次疫情让人体会到时间的宝贵，不珍惜时间就会浪费更多的时间（假期）来弥补时间的亏空。在商业软件开发中也是一样，不尊重用户的日常需求，用户切实反馈的问题得不到解决，用户的怨言就会堆积起来，最终导致用户流失。而对于自身而言，每天投资自己一点点，自己变好一点点，就是增强一点点今后的抗风险能力。","link":"/blog/2020/01/28/%E6%97%B6%E6%BB%9E%E6%95%88%E5%BA%94/"},{"title":"混合开发最小接口","text":"2020 年目前在做的最复杂的项目是将基于 Draft.js 深度定制开发的 web 编辑器适配到移动端，因为数据上牵涉到很多转换过程 native 端要从头开发的话成本过高，并且发现 web 并不能很正常地识别虚拟键盘弹出与否，于是将下图所示的工具栏通过 native 端单独进行开发与 web 集成，以获得更好的使用体验。 简单介绍下 web – native 通讯方式，ark_editor_native 是 native webview 注入到 window 对象上的一系列方法简称 AEN，ark_editor_web 则是 web 编辑器挂载成功后写入到 window 对象上供 native 调用的一系列方法简称 AEW，每次 editor 有任何更新，通过 AEN.syncState 传递给 native 一个 JSON 字符串，客户端需要自行反序列化成 JSON 对象，称为 syncState。 syncState 名称 值 inline_styles { &quot;BOLD&quot;: false, \\n&quot;CODE&quot;: false, &quot;ITALIC&quot;: false, &quot;STRIKETHROUGH&quot;: false }, block_type “unstyled” alignment “left” disabled_buttons [ “BOLD”, “unstyled”, “header-one”, …] undo_disabled true redo_disabled false 操作栏 行为 value disabled toggle insert update remove native 帮帮我 交给你了 web 加粗 ‘BOLD’ ‘BOLD’ in syncState.disabled_buttons AEW.toggleInlineStyle(‘BOLD’) 楷体 ‘ITALIC’ ‘ITALIC’ in syncState.disabled_buttons AEW.toggleInlineStyle(‘ITALIC’) 删除线 ‘STRIKETHROUGH’ ‘STRIKETHROUGH’ in syncState.disabled_buttons AEW.toggleInlineStyle(‘STRIKETHROUGH’) 行内代码 ‘CODE’ ‘CODE’ in syncState.disabled_buttons AEW.toggleInlineStyle(‘CODE’) 链接 ‘LINK’ ‘LINK’ in syncState.disabled_buttons AEW.toggleLink() AEW.insertLink(url) AEW.updateLink(entityKey, url) AEW.removeLink() AEN.showLinkEditor(entityKey, url) 注释 ‘FOOTNOTE’ ‘FOOTNOTE’ in syncState.disabled_buttons AEW.insertFootnote(content) AEW.updateFootnote(entityKey, content) AEN.showFootnoteEditor(entityKey, content) 标题（ 总称，无实际意义） ‘headlines’ ‘headlines’ in syncState.disabled_buttons 一级标题 ‘header-one’ ‘header-one’ in syncState.disabled_buttons AEW.toggleBlockType(‘header-one’) 二级标题 ‘header-two’ ‘header-two’ in syncState.disabled_buttons AEW.toggleBlockType(‘header-two’) 三级标题 ‘header-three’ ‘header-three’ in syncState.disabled_buttons AEW.toggleBlockType(‘header-three’) 四级标题 ‘header-four’ ‘header-four’ in syncState.disabled_buttons AEW.toggleBlockType(‘header-four’) 五级标题 ‘header-five’ ‘header-five’ in syncState.disabled_buttons AEW.toggleBlockType(‘header-five’) 六级标题 ‘header-six’ ‘header-six’ in syncState.disabled_buttons AEW.toggleBlockType(‘header-six’) 默认文字块 ‘unstyled’ ‘unstyled’ in syncState.disabled_buttons AEW.toggleBlockType(‘unstyled’) 对齐 ‘alignments’ ‘alignments’ in syncState.disabled_buttons AEW.toggleAlignment(‘left’|’center’|’right’) 有序列表 ‘ordered-list-item’ ‘ordered-list-item’ in syncState.disabled_buttons AEW.toggleBlockType(‘ordered-list-item’) 无序列表 ‘unordered-list-item’ ‘unordered-list-item’ in syncState.disabled_buttons AEW.toggleBlockType(‘unordered-list-item’) 引用 ‘blockquote’ ‘blockquote’ in syncState.disabled_buttons AEW.toggleBlockType(‘blockquote’) 图片 ‘FIGURE’ ‘atomic’ in syncState.disabled_buttons AEW.selectImage() 代码块 ‘code-block’ ‘code-block’ in syncState.disabled_buttons AEW.insertCodeBlock() 分割线 ‘PAGEBREAK’ ‘ atomic’ in syncState.disabled_buttons AEW.insertPagebreak() 分行 ‘ atomic’ in syncState.disabled_buttons AEW.insertSoftNewLine() 撤销 syncState.undo_disabled AEW.undo() 重做 syncState.redo_disabled AEW.redo() 清除行内样式 AEW.removeFormat() 优先级原则： 先判断是不是 disabled toggle &gt; native 帮我 &gt; 交给你了 web &gt; insert/update/remove 上面就是编辑器跨端通讯的基本形式了，简单来说 web 端每次 React componentDidUpdate 会把状态同步给 native 端，保证工具栏的及时性。当用户点击工具栏中可用按钮时，首先判断是不是需要和 web 进行状态判断，毕竟前一步只是判断能不能触发，触发以后的行为需要结合更具体的数据状态。然后是如果发现需要更多用户输入（比如弹窗输入框或勾选项等等）就需要唤起 native 的方法（native 帮帮我），如果没有这一步就可能是 web 专享操作，无关更多状态，比如上传图片或者撤销重做等等，这种情况就全权交给 web 了。最后则是 native 端二次调用 web 的方法，通常是关掉弹窗以后传递数据去改变 web 的状态。 体会： 原本通过 React props 保证的数据实时性需要手动同步给 native 端 native 和 web 互相暴露方法需要考虑实现的最小集 需要找到优雅的 debug 方式，出现过直接传 JS Object，native 端得到 undefined 异步操作可能需要加锁 当然现在开发还在对接联调期，包括保存等功能还没有加上，与从零开始的搭建也不可同日而语。编辑器和阅读器都是电子阅读产品的重头戏，之前则是看了这篇《Visual Studio Code有哪些工程方面的亮点》，对编辑器的开发充满了崇敬的心情。VS Code 也是我们现在开发的主力工具，包括其丰富的插件体系、LSP 和宛如神器的 Remote 模式，都使我惊叹于其良好的实现。不说了，去下单《设计模式》了。","link":"/blog/2020/02/28/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3/"},{"title":"程序员应该写出怎样的代码","text":"虽说老板和产品经理都不会太关心代码质量，所求无非是美观可用效率高等等，但作为一个略有追求的程序员在严酷的需求排期和反复推翻修改的生存环境之下，面对前人挖下的坑和自己几个月前寥寥草草写出的 adhoc 代码，总会望洋兴叹一番，痛定思痛想要写出一些拯救苍生（几个月后的自己）的传世代码。 然鹅面对一堆静态动态模板混杂、数个参数可变返回数据可变的异步嵌套接口加上鬼都不认识的 model/view 继承堆积起来意大利面条一般的代码，更别说还有不知哪里引用的全局样式给兴高采烈调完所有组件的你温柔一刀。怎么办？ 首先从简单的样式部分着手，CSS Module 或 styled component 完美解决了局部样式的问题，SSR 解决了前后端模板的一致性。这些都是社区提供的通用方案，剩下的基本就是如何组织 model 以及接口了，即前后端数据同步问题。 我们知道 Python 和 JavaScript 都是动态语言，而动态语言最臭名昭著的就是“动态一时爽，重构火葬场”，基本一个数据倒上那么三四次手之后就变得亲妈不认了。类型是一定要加的，我们用 TypeScript！ 具体的好处前面已经提到过了，这里想说明的是类型定义不仅保证了代码逻辑的正确性，也给予阅读时良好的体验，有了类型以后相当一部分关于变量的说明都可以挪到 type 和 interface 上，代码更容易实现“自解释”。其实 ES Module 很大程度上已经完善了代码的引用逻辑，但相比之下类型定义具有更强的约束（字段级别）和更灵活的配置（interface 鸭子类型），所以都 0202 年了，还不上 TypeScript 真的都没法说自己是工程化的前端项目。 但 TypeScript 只是解决了前端的代码一致性，JavaScript 总还是要在 web 这个容器内运行的，目前边缘计算还不够成熟，以服务器为数据源和计算存储中心的 C/S 架构仍是未来一段时间的主流，所以接口相对于前端的重要性是不言而喻的（插一句，往后想想，与设备的连接接口以后会不会成为前端的新方向呢？这就成了边缘计算）。而对于 HTTP 请求而言，RESTful 是曾经统治一时的事实标准，非常 CRUD，但也非常不灵活。 我们需要的是一种组织更加灵活、分层结构、高度复用、最好实现“自文档”的接口，这就是 GraphQL。虽然它也存在嵌套查询时会拖慢数据库，参数传递不清晰等毛病，但瑕不掩瑜，它确实是目前前端对于结构化数据查询最好的方式，更为出众的是它支持自定义返回字段，不多不少刚刚好是前端想要的那些，这简直太香了。 如果不考虑性能和异步并发，这些已经足以一个前端掌控 95% 的开发任务了，但往往那 5% 的事儿占据了 95% 的开发时间，后面会写写对于 Web Assembly 和 Reactive Programming 的理解，长远来看，当前围绕 html 进行的框架或者语言升级将告一段落，往后会转入多语言及范式涌入 web 开发领域碰撞并融合，浏览器正式成为继 iOS 和 Android 之后的第三大移动操作平台，更为可贵的是 web 的普适性使它几乎没有什么前置使用成本。","link":"/blog/2020/05/11/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E5%86%99%E5%87%BA%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BB%A3%E7%A0%81/"},{"title":"类型定义即是量纲","text":"2019 年阅读的前端项目终于吃上了 TypeScript，群众纷纷反映真香！ 我在思考，类型定义对于程序语言来说究竟算是什么呢？我们大家都知道编译型语言类型检查不通过是会编译失败的，返回一个错误信息，那么我们为什么要保证变量类型呢？我不想先谈那些内存结构啊，指针之类的，我想说的是类型定义就好比物理学里的“量纲”。 我们会说 1 立方米的木头，1 吨的木头，都是可以的。但我们不会说 1 安培的木头，或者 1 摄氏度的木头。因为这些量纲没法衡量木头的多少，或者说即使确实有 1 安培电流通过的木头，表面温度为 1 摄氏度的木头，我们也没法了解它到底意味着什么（能换多少钱，需要多少辆车才能拉动？）。 计算机程序是简单的，每个变量，每个函数，他们都只会做两件事，那就是被写入内存和从内存读取，量纲是他们在内存里分配的形式，u32 和 i64 就是不同的变量，长得不一样，功能也不一样。 JavaScript 是弱类型的语言，它容忍隐式类型转换。但 TypeScript 不允许这样做。我们不能把 string 类型的变量传给一个接受 number 类型参数的函数，就好像我们没法把木头接到灯泡上指望它发光一样（好吧，如果这是一段带点的木头就当我在放屁），尤其是你接到的还是一段看起来很像电池的木头，比如名为 battery，但类型是 wood。 另外，保证量纲被定义的好处是我们拥有了更好的接口提示，即使之前就有 document comment，但我们依然只能通过 description 来辨识变量类型和猜测该用的参数，有 TypeScript 以后 …… 最后，我想说的是，即使 TypeScript 给开发过程带来了巨大的便利，但我们仍应该清楚地认识到它只是一门 JavaScript 的预处理语言，运行时仍是那个不带类型检查的玩具语言（？），当 API 接口返回的数据不同于类型定义的 Interface 怎么办？ Runtime Type Check一种方案是 WebAssembly，在 Rust 代码里用 Serde 之类的序列化工具来整理 JSON 数据，如果遇到不存在的属性会直接报错 另一种就是 JS 方式：invariant 1234567var invariant = require('invariant');invariant(someTruthyVal, 'This will not throw');// No errorsinvariant(someFalseyVal, 'This will throw an error with this message');// Error: Invariant Violation: This will throw an error with this message","link":"/blog/2019/12/29/%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%8D%B3%E6%98%AF%E9%87%8F%E7%BA%B2/"},{"title":"通用设计","text":"我们知道页面是 web 设计中单次呈现给用户的一个功能整体，但功能的粒度随着 AJAX 的出现不仅仅限于表单即 form 与服务器的单次交互，变成了 XMLHTTPRequest 或 fetch 甚至 WebSocket 的多次往返，这样而言单一页面也可以承载更多的用户交互行为。与之同时带来的问题是如何有效划分功能区域以便实现最大程度的组件化，增强复用性和可维护性？ 签约与填写身份信息分离以某次产品设计为例，产品需要将 签署合同 和 填写身份信息 作为一个步骤页面放到拉力赛作品的创建流程里，原先的页面长成下图这样。 产品的想法是直接复用这个页面，作为前端当即表达了反对：这个页面包含了签协议和填信息两种操作，但却共用一个接口，不利于今后业务逻辑更为复杂时拆分（当下就已经属于过度耦合了），建议将 填写身份信息 放到单独的页面去。但产品随即表达了反对，认为用户的操作流程不应该多一个页面跳转。这怎么办呢？ 用弹窗啊！ 弹窗作为一种全局模态框可以在不修改整体页面流式布局的基础上让用户看到额外信息，甚至进行交互操作。弹窗内的组件可以被复用，因为是动态挂载到页面上的，一般对页面已有数据的依赖较小。 在实际代码构建时为了便于使用，将整个弹窗加上作者身份数据的获取、存储与更新逻辑整体封装到了一个 hook 中： 1const { agentInfo, loaded, showAgentInfoFormDialog } = useAgentInfo(agentId) 这样将数据和方法返回给调用方，将代码的侵入性做到最低。如果以后有只需要身份信息而不需要修改弹窗的使用情形，也可以尽情复用。 更通用的标签筛选一日接到了一个增加筛选器筛选条件的需求（筛选器是一个巨大的，有着上百个 CheckBox，相比各种电商筛选条件毫不逊色的怪物👹）。 作为一个凡是遇到需求不杠一杠就不开心的开发，我理直气壮地提出了自己的看法：这种一次性使用的需求，会在文件里留下谜一样的代码，而且根本不可能实现复用，如果要重构或者迁移都会是巨大的沉没成本。 随后根据下图的需求来源项 提取出了可以重复利用的「标签输入框」 有人会问，这样经常需要输入特定标签会不会不方便呢？早就想过啦，可以使用「加入书签」功能 会映射成形如 /admin/editorial_service?tags=亲密关系+轻装上场 的 url 存储在 localStorage 中，方便下次使用。大功告成！ 总结通用设计可以提供组件的复用能力，尽可能做到少暴露接口给外界，毕竟多一行代码就多一分风险和维护的成本，同时通用性足够好的情形下也能促进产品往更高效的方向发展，而不是拘泥于小而美的自我天地。","link":"/blog/2020/03/13/%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1/"},{"title":"过度包装","text":"疫情期间每天都是自己做饭吃，隔两三天就要买一次菜，每次买菜光是拆包装盒就要耗费非常多的心力，更别提清洗食材和锅碗，切菜淘米调配料，蒸炒炖炸等工序了，难怪说疫情期间分手的情侣、离婚的夫妻比比皆是，敢情大家平时都是装作很会生活的样子，一旦没了外卖快递都退回到了饮毛汝血的状态。 正如做饭 1 小时，吃饭 10 分钟，洗碗半小时所说的那样，吃这样一个动作在当前都会有无穷的副作用，可以说现代都市生活真的是建立在非常完善的 O2O 服务行业之下的，要吃饭线上下个单线下送来，要保洁自如下个单线下保洁员上门，要 ml 都有 165/90 32C 的家政服务人员上门服务。人的生活变成了只需处理工作，其他时间都可以用钱买到，这样 WFH 所带来的工作时长延长对社畜的身心打击几乎到了极致。扯远了。 网上买菜或者超市买菜，相比于菜市场买菜最大的区别是包装。垃圾桶里丢掉的绝大部分是塑料包装而不是切掉的边角料菜或者剩饭剩菜。就像软件开发里，动辄几十上百层的封装之下，真正工作的是那么一两行代码。 public js submit works manage components header-actions PriceActions PriceActions.tsx -&gt; StartPromotionButton.tsx -&gt; StartPromotionForm.tsx 一个页面上小小的组件，被封装在 9 层目录之下，同目录平级之间还有嵌套关系。当然组件化分治思想也是 React 一直火到现在的根本原因，但有时也会想想这种扁平化的目录结构是否真的合适项目的发展，或者说在业务需求猛增前提下如何科学组织目录结构以便修改维护也是门学问了，当然最好的方式是：不组织。根据实际发展来让文件自行组织，见 destiny。 拉扯这么多包装的弊端，但包装实际上是一项很重要的工序，因为不包装带来的风险，往往是看不见的：小吕去年写了个活动页的接口，因为是第一次办这种活动，小吕本着以产品需求为约束的理念写好了无届数限制的 API 接口，然后前端同学以此接口封装了一个组件给页面加了上去。转眼间一年过去了，活动办了第二届，产品要求有新功能，小吕又哼哧哼哧写了一个第二届活动的 API，但这时候出分歧了：前端觉得接口应该稳定，如果每做一届都要回溯一遍做过的接口映射，太累且容易出错；而后端觉得分离 API 有助于更清晰地业务逻辑。大家说的都没错，怎么办呢？包装一下接口吧！ 可以看出是适当的包装有助于分清业务界限，明确各端职责是非常值得提倡的。 但为什么实践中经常分不清这些呢？因为 Python 本质是一个胶水语言，更多起黏合剂作用，而 JavaScript 更想火柴棍，可以飞速搭原型，但两者都不是拥有持续集成性和可维护性的代表。个人以为类型系统以及所有权（或者说内存锁）是一个合格的工业级语言必备的，一个保障 AOT 安全，一个保障 JIT 安全，任何业务逻辑都是对这两个基本原则的封装。","link":"/blog/2020/04/08/%E8%BF%87%E5%BA%A6%E5%8C%85%E8%A3%85/"},{"title":"注册表与文件关联","text":"注册表可能是 Windows 最愚蠢同时又是最伟大的发明之一。相较于 *nix 系统汗牛充栋的 *rc 文件，Windows 一直依赖于注册表这样一个中心化的注册服务来提供各种系统功能及样式的配置。与此同时带来的就是各种复杂的软件依赖关系，甚至各大厂商都深陷其中，不得不依赖第三方软件来对注册表里塞满的无用键值进行清理。对于这样一个令人头疼的领域，这篇文章将简单介绍一下如何将应用程序关联文件管理器中特定后缀名的文件右键菜单，让用户方便地使用你开发的程序对文件进行操作。所用的语言为 NSIS Script，语法指南可参考这个链接。 通用注册表修改卸载方式关联如果只是一个 Portable 文件，那么其实不需要卸载这个过程，直接删除文件即可。但既然我们需要一个稳定、位置可知的程序来处理我们的文件，这里必须将程序注册到系统菜单中。安装过程因各个安装引导程序而已，作者这里是用的 NSIS 安装器。这里简单介绍一下 Windows 里如何将我们自己的程序注册到程序功能列表，以便用户哪天不爽了把程序卸载掉。 这里将程序注册到了 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall 下，这里就是卸载程序的大本营了。 123456WriteRegStr HKLM &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\ExampleApp&quot; &quot;DisplayName&quot; &quot;示例程序&quot;WriteRegStr HKLM &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\ExampleApp&quot; &quot;DisplayIcon&quot; &quot;$INSTDIR\\Example.exe&quot;WriteRegStr HKLM &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\ExampleApp&quot; &quot;UninstallString&quot; &quot;$INSTDIR\\Uninstall Example.exe&quot;WriteRegStr HKLM &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\ExampleApp&quot; &quot;InstallLocation&quot; &quot;$INSTDIR&quot;WriteRegDWORD HKLM &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\ExampleApp&quot; &quot;EstimatedSize&quot; &quot;${ESTIMATED_SIZE}&quot;WriteRegStr HKLM &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\ExampleApp&quot; &quot;DisplayVersion&quot; &quot;${VERSION}&quot; $INSTDIR 是表示程序安装目录的变量，类似于 C:\\Program Files\\ExampleApp。 注册为软件分类前一步里我们简单地将程序挂载到了可卸载列表里，这一步我们将其注册成软件分类。有人可能要问了，为啥不直接将软件绑定到文件后缀名呢？事实上那样做是可以的，如果你在右键选择其他程序打开则会直接往该后缀名里直接添加一个程序路径，类似 C:\\Program Files\\ExampleApp\\ExampleApp.exe 的样子。 但这样做有个问题，如果一个程序有修改安装路径或者是卸载时，就需要一个个去各个后缀名下面修改或者删除，我们肯定想要一个比较稳定的 key 来依赖。所以我们选择将程序注册到 计算机\\HKEY_CURRENT_USER\\SOFTWARE\\Classes 下面，这样它就能被其他地方所引用了。 12345WriteRegStr HKCU &quot;SOFTWARE\\Classes\\ExampleApp&quot; &quot;&quot; &quot;示例程序&quot;WriteRegStr HKCU &quot;SOFTWARE\\Classes\\ExampleApp\\\\DefaultIcon&quot; &quot;&quot; &quot;$INSTDIR\\ExampleApp.exe,0&quot;WriteRegStr HKCU &quot;SOFTWARE\\Classes\\ExampleApp\\\\shell&quot; &quot;&quot; &quot;open&quot;WriteRegStr HKCU &quot;SOFTWARE\\Classes\\ExampleApp\\\\shell\\\\open&quot; &quot;FriendlyAppName&quot; &quot;示例程序&quot;WriteRegStr HKCU &quot;SOFTWARE\\Classes\\ExampleApp\\\\shell\\\\open\\\\command&quot; &quot;&quot; &quot;$INSTDIR\\ExampleApp.exe $\\&quot;%1$\\&quot;&quot; 到这一步完成，我们的程序就算正式被系统所承认了，盖上了检疫合格的章子。 特定文件后缀名关联我们将进行两步关联，最后的效果是分别在一级菜单和打开方式的二级菜单同时注册我们的程序，并且使他们具有不同的操作。 右键菜单最粗暴的方式是直接写入 计算机\\HKEY_CLASSES_ROOT\\*\\shell 下，这样所有的文件都会带上我们的程序，但用户可能会发现打开之后啥反应都没？所以我们应该只给我们支持的程序进行关联，比如我们要给 pptx 文件进行关联，则需要如下设置： 1234567!macro BIND_SHELL_COMMAND EXT WriteRegStr HKLM &quot;SOFTWARE\\Classes\\SystemFileAssociations\\${EXT}\\shell\\ExampleApp.Import&quot; &quot;&quot; &quot;Import with ExampleApp&quot; WriteRegStr HKLM &quot;SOFTWARE\\Classes\\SystemFileAssociations\\${EXT}\\shell\\ExampleApp.Import&quot; &quot;Icon&quot; '&quot;$INSTDIR\\ExampleApp.exe&quot;' WriteRegStr HKLM &quot;SOFTWARE\\Classes\\SystemFileAssociations\\${EXT}\\shell\\ExampleApp.Import\\command&quot; &quot;&quot; '&quot;$INSTDIR\\ExampleApp.exe&quot; &quot;-import-file=%1&quot;'!macroend!insertmacro BIND_SHELL_COMMAND &quot;.pptx&quot; 这里解释一下，BIND_SHELL_COMMAND 是一个宏，它会在编译期进行展开，NSIS 也有 Call &amp; Func 和 Section 的写法，但它们不支持多个参数，所以使用 macro 成了唯一的办法。这里会在 pptx 文件的右键菜单里增加一个 Import with ExampleApp 的选项，一点之后就会执行 ExampleApp.exe -import-file=xxx.pptx 后面的工作就交给 ExampleApp.exe 自己去完成了。 打开方式上一种关联方式比较粗暴，且没有办法与系统做更多交互了。我们可能想要我们的程序直接成为该种后缀名文件的默认打开程序，这样就会让用户形成路径依赖。 直接抢占默认打开方式存在诸多不确定性，比如用户安装了 Office 或者 WPS，结果安装完你的程序，发现所有 Office 文件都被你抢了，实际并不能正常使用，这就很尴尬了。 所以我们采用比较温和的添加为可选执行程序的方式，将程序添加到 计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.pptx\\OpenWithProgids 里去，这样就能在右键打开方式里占有一席之地。 1WriteRegStr HKCU &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.pptx\\OpenWithProgids&quot; &quot;ExampleApp&quot; &quot;&quot; 看似已经大功告成了，但我们一关联上，如果用户真的没有装别的打开 pptx 的软件，就会惊奇地发现所有的 pptx 文件都变成了你的软件图标。 用户：中毒了，你的程序有毒！！！ 真是比窦娥还冤。为了避免这种情况，我们需要给这些文件依次设置它们应有的图标，同样通过设置 计算机\\HKEY_CURRENT_USER\\SOFTWARE\\Classes 来达成我们的目的。 1234567891011121314!macro BindExtname InstallDir Ext Description !insertmacro CLEAN_LEGACY &quot;${Ext}&quot; WriteRegStr HKCU &quot;SOFTWARE\\Classes\\ExampleApp.${Ext}&quot; &quot;&quot; &quot;${Description}&quot; WriteRegStr HKCU &quot;SOFTWARE\\Classes\\ExampleApp.${Ext}\\\\DefaultIcon&quot; &quot;&quot; &quot;${InstallDir}\\resources\\${Ext}.ico&quot; WriteRegStr HKCU &quot;SOFTWARE\\Classes\\ExampleApp.${Ext}\\\\shell&quot; &quot;&quot; &quot;open&quot; WriteRegStr HKCU &quot;SOFTWARE\\Classes\\ExampleApp.${Ext}\\\\shell\\\\open&quot; &quot;FriendlyAppName&quot; &quot;示例程序&quot; WriteRegStr HKCU &quot;SOFTWARE\\Classes\\ExampleApp.${Ext}\\\\shell\\\\open\\\\command&quot; &quot;&quot; &quot;${InstallDir}\\ExampleApp.exe $\\&quot;%1$\\&quot;&quot; WriteRegStr HKCU &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.${Ext}\\OpenWithProgids&quot; &quot;&quot; &quot;&quot; WriteRegStr HKCU &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.${Ext}\\OpenWithProgids&quot; &quot;ExampleApp.${Ext}&quot; &quot;&quot;!macroend!insertmacro BindExtname $INSTDIR &quot;pptx&quot; &quot;Microsoft PowerPoint 演示文稿&quot; 如上设置之后，我们就成功地让所有 pptx 文件都拥有了一个可选的 ExampleApp 打开方式，如果用户将其设为默认程序，则会用 ${InstallDir}\\resources\\pptx.ico 作为其图标，而文档类型则保持为”Microsoft PowerPoint 演示文稿”。 看起来非常完美！ 改动前：改动后： 清理 自己挖的坑，自己要填。 拒绝注册表垃圾，从我做起。 12345678!macro UNBIND_SHELL_COMMAND Ext DeleteRegKey HKCU &quot;SOFTWARE\\Classes\\ExampleApp.${Ext}&quot; DeleteRegValue HKCU &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.${Ext}\\OpenWithProgids&quot; &quot;ExampleApp.${Ext}&quot; DeleteRegKey HKLM &quot;SOFTWARE\\Classes\\SystemFileAssociations\\${EXT}\\shell\\ExampleApp.Import&quot;!macroendDeleteRegKey HKCU &quot;SOFTWARE\\Classes\\ExampleApp&quot;!insertmacro UNBIND_SHELL_COMMAND &quot;pptx&quot;","link":"/blog/2023/04/28/regedit-file-association/"},{"title":"Electron 应用整洁架构","text":"框架特性 依赖反转 路由模式 装饰器（Decorator） HTTP 类 自定义类 中间件（Middleware） 数据管理 简单 JSON 内容 数据库 跨进程共享数据（preload） 会话隔离 Session 持久化 Session 事件 业务特性 插件机制 内置插件 第三方插件 插件依赖 窗口 UI KISS 命令式修改 中心化状态 原则 防呆设计 保持功能独立 一个好的架构是具有良好用户体验的 App 的必备素质，反而言之，一个差劲体验的 App 一定是架构混乱甚至没有架构的。一坨一坨互相依赖，单例漫天飞的代码，足以让任何一个开发满嘴跑 F**K。 什么是好的架构？众说纷纭，但至少类似洋葱模型的中心化组织形式比较符合心智模型。设想一下，每天睁开眼睛，第一件映入脑海的事可能是下列这些问题： 我是谁？我是一个程序员，我每天需要写代码赚钱…… 这是哪？这是我家，租来的房子，离公司骑车 15 分钟，所以我得赶紧起床了 看看今天有啥新鲜事？拿起手机，把通知和各个 IM 应用点一遍 开始新的一天吧？打开水龙头洗漱，出门扔垃圾，扫共享单车去上班 而这些想法和行为正好对应了 Clean Architecture 里的 Entities、Use Cases、Interface Adapters、Frameworks and Drivers。我是实体，我每天根据情景有要做的事，我接受的信息有原始的自然信息（如鸟鸣虫叫）也有经过加工的人工信息（明星八卦、国际局势），最后和社会的水电交通等公共设施打交道。任何一种好的架构都应该符合普通人的基本认知才能绵延不息。 光说不练假把式，同样以 Electron 框架为例子。为啥总要举它作为栗子呢？因为 Electron 天生具有 C/S 架构，同时又是客户端应用，可以说在单个体上参杂了前端、后端和客户端三种不同关注点的开发视角，所以大多数 Electron 应用往往都是一个大窗口套一个 web，主进程简单做了个数据层就完事。这种情况下既不需要架构，也不需要优化，只需要把代码堆积起来就完事了。 但时间一长，各种问题就粗来了： class 没有统一初始化的地方，基本是直接 export new 或者单例模式 功能堆砌纯线性组织，一条长长的 main 函数把所有的功能都包含了 preload 脚本需要 ipcRenderer.sendSync 通讯，同时 ipc 可能遇到跨 frame 通讯问题 单元测试困难，Electron 模块随处可见，需要多次 mock 没办法，不想脱裤跑路就重构呗。天不生 Nest.js，Electron 架构万古如长夜！经过近两年的苦苦摸索，在尝试了至少三种框架的基础上，终于提炼出了用 Nest.js 框架良好组织 Electron 应用的方法，且听我缓缓道来。 框架特性每个框架都会把自己的杀手锏特性都排在官网最前面，比如 React 是组件式，Vue 是渐进式，Angular 是让你有信心交付 web app，Svelte 是消失的框架（无运行时 lib），而 Nest.js 几乎是把渐进式、可靠性、扩展性等等都包圆了。实际使用下来，可以说是跟 Angular 一样的总包框架，可以管理一个 App 从启动到关闭整个生命周期。同时它也借鉴了 Angular 很多的创新点，比如依赖反转注入，装饰器模块，五花八门的中继器，以及强大的可扩展性，这也是我们得以将其应用到 Electron 项目的关键。 对于纯命令行程序，我们可以直接一个函数从头执行到尾再退出 App，而对于任何 GUI 程序，通常的解决方案都是以事件循环阻塞整个进程直至收到退出 SIGNAL，但这带来一个问题，如果进程被阻塞了，后续所有操作都无法得到响应。Node.js 的异步事件循环完美地解决了这个问题，在此基础上设计了基于消息的一系列运行机制，很好地处理了成千上万的请求。既然作为服务器都顶得住，那单机应用区区几个请求的并发更是不在话下。 我们设想这样一个应用： 它具有处理自定义请求事件的能力 它支持中继并更改请求，也就是中间件的能力 它可以分析模块依赖并自动按序加载 它可以加载外部网页并与之通讯，同时也可以与宿主机的其他应用通讯 这是一个跨端的带界面的服务器。 依赖反转 这个特性可太重要了，可以说没有它就没有后续所有的模块设计。每个上古项目都有一堆不明所以的头文件或者配置文件，或者不知从哪引入的构建脚本，又或是一串 token 或密码，这些东西都应该被管理起来。 我们需要一个简单的心智模型，所有第三方内容都是输入资源，不管是代码还是配置，webpack 就是把所有的内容都当作资源对待。但 webpack 在打包时也支持给 import 加参数，比如指定图片内嵌为 base64 的最大体积。支持输入参数也是我们的模块建设目标之一。 同时，webpack 也支持拆分模块，延迟至使用时加载，这一点更是杀手锏。因为客户端的生命周期一般比网页要长得多，但对体积相对不敏感，使用一些 preload 技术可以不在影响用户正常使用的情况下在快速响应页面和保证功能随时可用间达到平衡。使用 Nest.js 的 useFactory 可以轻松将模块变为 import(...) 延迟加载并且在使用时只需从 constructor 进行注入，避免全局的 lazy import 污染。 模块存在的意义就是复用，虽然 web 上各种框架的教条都是不要复用组件，多用组合而不是嵌套继承，但实际上数据和 UI 就是不同的组织形式。我们可以精确定义每个模块的使用究竟是全局唯一，每次实例化使用一个新的，还是每次调用就直接新建一个。 参考： Custom providers Injection scopes 路由模式组件是前端的组织方式，而路由则是后端的组织方式。 路由模式和消息监听机制很像，区别是路由是编译时即唯一确定的，而消息监听则往往是运行时动态注册。这里动态注册的消息机制带来了两个严重的问题： 首次加载时无法确定消息处理的顺序，往往需要等待一个消息监听器绑定之后再触发事件，要是没监听上就丢失了。 消息监听可以放在全局，或者跟随模块。前者污染了全局环境，后者层层嵌套之后难以确认依赖层级。 既然消息机制具有如此多的不稳定性，我们还是更倾向于跟服务器一样一次性注册所有路由。 不管是 HTTP 还是 IPC，甚至系统菜单，都可以作为路由端点。我们也可以用自带的 EventEmitter 在应用间不同路由间穿梭。下面这段代码就演示了一个简单的创建或更新对象的路由端点，可以看到路由的组件由装饰器标识，在函数参数里通过装饰器来捕获不同的参数，经过 this 上的数据库及 logger 对象，完成了数据的持久化和日志功能，最后把创建结果以 JSON 格式返回。 1234567891011121314151617181920212223@Post('/:id')public async upsert( @Param('id') id: string, @Param('name') name: string @WebContents() webContents: WebContents,) { this.logger.log(`Got message from webContents-${webContents?.id}`); const db = this.database; try { const doc = await db.get(id); return db.put({ _id: id, _rev: doc._rev, name, }); } catch (err) { this.logger.error(err); return db.put({ _id: id, name, }); }} 装饰器（Decorator）大家肯定也看到上面代码中四个大大的 @，这就是 JavaScript 中的装饰器语法。只是可惜的是 parameter decorator 最终没有进入 stage 3，也就意味着 Typescript 以后肯定会对这个调用方式进行更改，不过这件事还没有尘埃落定，加上这么大一个框架，根本不用担心。 让我们庖丁解牛一下“装饰器”究竟是个什么东西？装饰器的重点自然是在装饰上，也就是给被装饰的类、函数方法、参数等实现一个不同的外观，从而在程序运行起来时以指定的方式调用/生成被装饰的对象。这句话读起来还是很别扭，实际上装饰器是元编程的一种形式，也就是不改变代码结构的前提下给代码走不同路径的方式，可以理解成打补丁。 举几个例子，比如常见的 debounce 和 throttle 方法，它们接受一个函数，返回防抖和节流后的函数版本。 12345678910111213141516171819202122function debounce(fn, timeout) { let timer = null return function(...args) { if (timer) { clearTimeout(timer) timer = null } timer = setTimeout(() =&gt; { fn.apply(this, args) timer = null }, timeout) }}function log(data) { console.log(data)}class Logger { debounceLog = debounce(log, 1000)} 无装饰器版本 123456789101112131415161718192021222324const debounce = (timeout: number) =&gt; (value: any, context: ClassMethodDecoratorContext&lt;any&gt;) =&gt; { let timer: undefined | NodeJS.Timeout = undefined context.addInitializer(function () { const fn = this[context.name] this[context.name] = (...args: any[]) =&gt; { if (timer) { clearTimeout(timer) timer = undefined } timer = setTimeout(() =&gt; { fn.apply(this, args) timer = undefined }, timeout) }; });}class Logger { @debounce(1000) log(data: any) { console.log(data) }} 装饰器版本 可以看到装饰器版本将业务逻辑内聚成了一个函数，而不是必须要用函数套函数的方式。让代码分层有助于隔离关注部分，我们通常会把路由的执行逻辑和路由的路径给绑定在一起，但又不想变成每个路由端点都是一个类，这就是装饰器常见的应用场景了。 HTTP 类Nest.js 自带了很多 HTTP 服务的默认装饰器，对于绝大多数场景而言已经足够了。支持 HTTP 不同的请求类型，从请求中获取数据，并最终将内容用模版拼合并返回。 路由：@Get / @Post / @Sse 参数：@Param / @Header 响应：@Render 自定义类 获取参数：@WebContents 装饰路由：@IpcHandle, @IpcOn 除了 HTTP，Electron 应用还内置了一种消息通讯机制，就是客户端熟知的 IPC（Interprocess Communications）。它的实现可以有很多方式，不同平台也会有不同的实现，但 Electron 的特殊点在于 IPC 两端绑定的不是进程或者 socket 连接，而是 web 页面。 Web 页面承载了实际展示给用户的 UI 内容，它本身存在于一个个渲染进程里，主进程里可以认为只是它的一个替身，但实际运用中往往需要拿到这个替身的各种状态。 既然是统一了 HTTP 和 IPC 通讯方式的框架，我们将会用装饰器抹平两者的差别，开发时可以自由选择通讯方式的同时也能支持拿到相应的请求源对象。 通讯方式 优点 劣势 HTTP 无需向 web 注入代码 无法自然获得 web 页面句柄 IPC 传输 JSON 无需序列化 需要向 web 注入对象 这里面会分别用到 Nest.js 的 Custom Transport，以及 Electron 的 WebRequest 模块。 Step 1: 通过 @nestjs/microservices 的 EventPattern, MessagePattern 组合出 IpcInvoke 和 IpcEvent 装饰器（给路由用） Step 2: 通过 session.protocol.registerSchemesAsPrivileged 放通自定义 SCHEME Step 3: 在 WebRequest 拦截自定义 SCHEME（HTTP）请求头注入 webContentsId Step 4: 在 CustomTransportStrategy 绑定所有 Step.1 装饰过的路由响应 IPC listener，并在 handler 中传入 event 对象作为 data Step 5: 创建 WebContents 装饰器。通过 @nestjs/common 的 createParamDecorator，根据 ctx.getType == ‘http’ || ‘rpc’ 来返回位于 req.headers 和 RpcArgumentsHost.getData 中的 webContents 12345678910111213141516import { HandlerType } from '~/common/constants/meta';import { applyDecorators } from '@nestjs/common';import { EventPattern, MessagePattern } from '@nestjs/microservices';export const IpcInvoke = (channel: string) =&gt; { return applyDecorators( MessagePattern(channel, { handlerType: HandlerType.InvokeMessage }), );};export const IpcEvent = (channel: string) =&gt; { return applyDecorators( EventPattern(channel, { handlerType: HandlerType.Event }), );}; 1234567891011121314import { IRequest } from '~/common/interfaces/electron/request';import { ExecutionContext, createParamDecorator } from '@nestjs/common';export const WebContent = createParamDecorator( (data: unknown, ctx: ExecutionContext) =&gt; { if (ctx.getType() === 'http') { const request = ctx.switchToHttp().getRequest&lt;IRequest&gt;(); return request.webContents; } else if (ctx.getType() === 'rpc') { return ctx.switchToRpc().getData().event.sender; } },); 使用装饰器可以让我们更轻松地将不同的路由与 Electron 框架进行交互，不管是注册事件监听模拟路由还是从请求中解出需要的源数据，都很方便。 中间件（Middleware）如果说装饰器是完成了路由的网状组织最后一块拼图的话，那中间件就是为数据的流动接上了一长条管道。 Nest.js 中的中间件有三种，Middleware，Interceptor 和 Exception filters，甚至 Pipes 和 Guards 也可以算作中间件。它们本质都是对请求和响应作一定的处理，来满足包括鉴权，错误处理，数据转换等等功能。 这是 Stackoverflow 上对不同中间件的总结。https://stackoverflow.com/questions/54863655/whats-the-difference-between-interceptor-vs-middleware-vs-filter-in-nest-js 这张图很好地展示出了不同中间件在一个请求的生命周期中的作用。 简单实现一个针对特殊路由对 JSON 路由返回结果，将 data 包了一层再返回的中间件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import { Observable, tap } from 'rxjs';import { CallHandler, ExecutionContext, Injectable, NestInterceptor,} from '@nestjs/common';import { Reflector } from '@nestjs/core';@Injectable()export class RequestInterceptor implements NestInterceptor { constructor(private reflector: Reflector) {} intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; { return next.handle().pipe( map((data) =&gt; { const handler = context.getHandler(); const isJSON = this.reflector.get('json', handler); if (isJSON) { return { res: 0, data, } } return data }), ); }}import { SetMetadata, Post, Param,} from '@nestjs/common/decorators';class Controller { @Post('create') @SetMetaData('json', true) create(@Param('name') name) { return this.db.create({ name }) }} Web 后端服务直接将端口暴露在网络上往往需要很多的安全校验以及错误处理，实际上客户端代码是自主维护的，风险相对可控，所以不会需要太多的校验工作，只是对一些涉及到 C++ 调用时，因为数据类型需要转换，比如只接受整数，传入浮点数会导致类型转换失败甚至程序崩溃。中间件一些应用场景如下： 给 request、context 统一加上指定参数，例如 request.user 在请求处理完毕返回前继续调用别的路由端点 数据管理简单 JSON 内容数据库跨进程共享数据（preload）会话隔离Session 持久化Session 事件例如自定义下载行为，针对特定协议进行重定向。 业务特性插件机制内置插件第三方插件插件依赖插件一多，就跟模块一样存在互相依赖的问题。内置插件还好说，毕竟在同一个仓库里维护，第三方插件完全是脱离控制的存在。 一种简单的办法，插件具有版本，互相引用需要带版本号进行关联，但很明显这是种不经济的做法。况且为了不强依赖于某个版本，大家都会心照不宣地做成向上兼容模式，这时候一个实习生发了 x.x.n+1 的版本，但实际废除了一个重要 API，画面太美不敢想象。事实上没有一颗避免循环版本依赖的银弹，业界通常做法是深度遍历之后在遍历到一定层数，返回循环依赖的报错。 这时候就不得不提一种脱离 RestFul 的查询语言：GraphQL。用它进行查询时，所有的层级都必须显式注明，无法进行无限嵌套查询。这有点像加上了 SQL 的 RestFul 接口，并且它还支持动态 join。 我们可以设计一种生命周期，插件安装完成后根据一系列钩子获取到插件系统的状态，同时将输入输出连接到插件系统，这样任何的行为表现都交给了系统。比如插件 A 需要插件 B 的数据，它会试图先询问系统在存储空间内有没有插件 B 写入的数据，得知不存在时请求调用插件 B 的功能，得知插件 B 不存在时唤起插件系统的下载功能对插件 B 进行加载。 窗口 UIKISS不要动原生对象！不要动原生对象！不要动原生对象！ 重要的事说三遍。 命令式修改中心化状态原则防呆设计虽然只是一个很小的点，但实际操作中还是很容易被忽略，那就是没有一个用户会 100% 按照你的预期来使用你的产品。例如给用户一个删除按钮时，用户会毫不犹豫地点下它，然后等待确认删除的弹窗弹出来。什么？直接把文件删除了？你们这是欺诈消费者。所以业界共识都是删除往往都是只标记数据为已删除而不是真正删除，实际在磁盘清理或是存储服务缩容时才会丢弃这部分数据。但不符合用户预期的行为一定会带来用户的困惑，所以一定需要反复确认这种反人性但必要的功能。 另一个小点，用户的数据是我们第一优先级要保障的内容。撇开上面用户主动要删除资源的情形，如果遇到不可抗力，比如网络错误，或者数据格式解析失败，第一步也是尽可能备份用户的数据并提示用户自行转移，而不是失败了提示刷新页面，用户一点，咣的一声数据就没了。这就是为什么危险操作往往用红色标识，但一种趋势是：用户甚至不关心你在表达啥，他只是想把这个该死的弹窗给 × 掉。所以 Windows 更新才会以那么粗暴且不可取消的方式抢占用户的操作。 保持功能独立没有什么比功能耦合更折磨程序员了，简单的小功能往往最后变得不可收拾，这通常是产品 feature 没有被良好地拆解消化，也可能是 DDL 倒排导致的赶工。总之，连 Chrome 都只能用多进程来解决不同网页的内存泄漏问题，就更不用说我们这些仓促写就的代码了。保持功能独立主要有以下几点： 数据的唯一性，参数的正交性。这个可以参见我之前的一篇文章掌控前端数据流，响应式编程让你看得更远，只有做到数据独立，才能最大程度减少错误状态给整体带来的危害。 对于外部 API/SDK 足够的不信任。也就是说任何未经严格测试的第三方内容都需要加兜底处理，以防击穿层层防护使应用崩溃。 组合优于继承。虽然这是句老生常谈的话，但实际运用中，加一个 if else 或是添加一个类似命名的方法都是在进行继承操作。如果有那么一点成本上的可能，我们甚至应该对每时每刻每分每秒的代码都部署一个版本，这样我们总能在漫漫时间长河里找到能用的那个版本。","link":"/blog/2023/06/19/clean-electron-architecture/"},{"title":"浅谈仿 Chrome 标签页退出未保存弹窗机制","text":"设计一个仿 Chrome 的标签页是有多难？","link":"/blog/2022/05/31/warn-before-quit/"}],"tags":[{"name":"解谜","slug":"解谜","link":"/blog/tags/%E8%A7%A3%E8%B0%9C/"},{"name":"逻辑","slug":"逻辑","link":"/blog/tags/%E9%80%BB%E8%BE%91/"},{"name":"Rust","slug":"Rust","link":"/blog/tags/Rust/"},{"name":"App","slug":"App","link":"/blog/tags/App/"},{"name":"electron","slug":"electron","link":"/blog/tags/electron/"},{"name":"web","slug":"web","link":"/blog/tags/web/"},{"name":"Electron","slug":"Electron","link":"/blog/tags/Electron/"},{"name":"客户端","slug":"客户端","link":"/blog/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"nodejs","slug":"nodejs","link":"/blog/tags/nodejs/"},{"name":"gulp","slug":"gulp","link":"/blog/tags/gulp/"},{"name":"webpack","slug":"webpack","link":"/blog/tags/webpack/"},{"name":"多线程","slug":"多线程","link":"/blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"前端","slug":"前端","link":"/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","link":"/blog/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Node.js","slug":"Node-js","link":"/blog/tags/Node-js/"},{"name":"C++","slug":"C","link":"/blog/tags/C/"},{"name":"React","slug":"React","link":"/blog/tags/React/"},{"name":"UI","slug":"UI","link":"/blog/tags/UI/"},{"name":"旅行","slug":"旅行","link":"/blog/tags/%E6%97%85%E8%A1%8C/"},{"name":"风景","slug":"风景","link":"/blog/tags/%E9%A3%8E%E6%99%AF/"},{"name":"rollup","slug":"rollup","link":"/blog/tags/rollup/"},{"name":"node","slug":"node","link":"/blog/tags/node/"},{"name":"rxjs","slug":"rxjs","link":"/blog/tags/rxjs/"},{"name":"data-flow","slug":"data-flow","link":"/blog/tags/data-flow/"},{"name":"electron-builder","slug":"electron-builder","link":"/blog/tags/electron-builder/"},{"name":"编程","slug":"编程","link":"/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Windows","slug":"Windows","link":"/blog/tags/Windows/"},{"name":"注册表","slug":"注册表","link":"/blog/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"},{"name":"Chrome","slug":"Chrome","link":"/blog/tags/Chrome/"}],"categories":[{"name":"想法","slug":"想法","link":"/blog/categories/%E6%83%B3%E6%B3%95/"},{"name":"GUI","slug":"GUI","link":"/blog/categories/GUI/"},{"name":"web","slug":"web","link":"/blog/categories/web/"},{"name":"app","slug":"web/app","link":"/blog/categories/web/app/"},{"name":"生活","slug":"生活","link":"/blog/categories/%E7%94%9F%E6%B4%BB/"},{"name":"Windows","slug":"Windows","link":"/blog/categories/Windows/"},{"name":"app","slug":"app","link":"/blog/categories/app/"}]}