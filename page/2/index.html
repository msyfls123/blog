<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>马猴烧酒</title><link rel="manifest" href="/blog/manifest.json"><meta name="application-name" content="马猴烧酒"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="马猴烧酒"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="现在站在你面前的我 并不是幻影呀"><meta property="og:type" content="website"><meta property="og:title" content="马猴烧酒"><meta property="og:url" content="https://msyfls123.github.io/blog"><meta property="og:site_name" content="马猴烧酒"><meta property="og:description" content="现在站在你面前的我 并不是幻影呀"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://msyfls123.github.io/blog/img/og_image.png"><meta property="article:author" content="msyfls123"><meta property="article:tag" content="前端 感悟 技术"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/blog/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://msyfls123.github.io/blog"},"headline":"马猴烧酒","image":["https://msyfls123.github.io/blog/img/og_image.png"],"author":{"@type":"Person","name":"msyfls123"},"publisher":{"@type":"Organization","name":"马猴烧酒","logo":{"@type":"ImageObject","url":"https://msyfls123.github.io/images/logo.jpg"}},"description":"现在站在你面前的我 并不是幻影呀"}</script><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/vs2015.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/blog/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/blog/"><img src="/blog/images/logo.jpg" alt="马猴烧酒" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/blog/">Home</a><a class="navbar-item" href="/blog/archives">Archives</a><a class="navbar-item" href="/blog/categories">Categories</a><a class="navbar-item" href="/blog/tags">Tags</a><a class="navbar-item" href="/blog/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-09T16:08:58.000Z" title="2022/2/10 00:08:58">2022-02-10</time>发表</span><span class="level-item"><time dateTime="2022-08-18T07:53:40.399Z" title="2022/8/18 15:53:40">2022-08-18</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/web/">web</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/2022/02/10/from-f2e-to-client/">如何从前端到客户端</a></h1><div class="content"><p>我是如何从一个工作全部内容只是 HTML + CSS + JavaScript 的前端，转为一个依然基本靠着前端三板斧技能工作，但支撑起了”横跨三大操作系统 + 各种处理器架构 + 保持 web 同步迭代周期 + 复用了 web 95% 以上功能的桌面端产品“的伪客户端工程师？</p>
<p>首先当仁不让地要祭出 Electron 这件大杀器，现在开发一个桌面端最最行之有效的方式仍然是 web 套壳，让 web 代码几乎不用改就可以直接运行在一个窗口里。如果采用别的技术方案，我曾不止一次地在前同事和当下 leader 等口中听到拿 C++/OC/Swift 之类的写界面要吐血三升之类的话语，理解各种 Window、Dialog、Layout、Signal &amp; Slot 就足够一个前端喝一壶了，而这些技术细节在 Electron 下都可以化繁为简成一个个普通的 Chrome 窗口，以及与之相关联的 Node.js 胶水逻辑。</p>
<p><img src="/blog/images/from-f2e-to-client/Untitled.png" alt="Electron 更接近于 Hybrid 应用"></p>
<p>Electron 更接近于 Hybrid 应用</p>
<p>虽然把页面展示出来只是客户端面临的众多问题之一，但这恰好是客户端做 UI 最复杂的那一部分。</p>
<p>使用 Electron 就是说我可以在<strong>不改变主要工作语言的前提下，尽可能快且大地延展自己的作业范围，以较低成本快速搭建起原型</strong>，这是前端选择其他语言或者框架进行客户端开发无法企及的优势。</p>
<p>那是不是只要上了 Electron，把 web 页面一封装就万事大吉了呢？倒也不是，客户端开发上接网络通讯、界面渲染，下至系统特性 API，它这个逻辑不是后端来一个 request 返回一个 response（简化模型），也不是前端从一个页面加载到脚本执行后进入等待 UI 交互的过程就结束了。客户端需要同时处理多个页面的展示、管理前后台进程、与服务器做通讯、主动存取数据至文件等。</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>替身</th>
</tr>
</thead>
<tbody><tr>
<td>后端</td>
<td>收银员/会计</td>
</tr>
<tr>
<td>前端</td>
<td>导购/客服</td>
</tr>
<tr>
<td>客户端</td>
<td>客户经理/维修人员</td>
</tr>
</tbody></table>
<p>我更偏向从角色和现实生活中的替身角度认识各个端的分工，这个分工不是绝对的，彼此之间有交集。前端主要负责 UI 的展现，像是一个商店的导购小姐，根据用户喜欢安排不同的商品；客户端则是客户经理，向已经对此感兴趣的用户进一步演示商品的功能，并分析深层次用户需求；后端则是收银员兼会计，这时候用户已经拍板下单了，如何收钱，如何签订协议，如何发货和三保。之后可能还会有进一步交互，比如用户发现商品出了问题，继续通过网页上反馈过来，然后客户端需要更新版本，相当于以旧换新，完成持续交付。</p>
<p>下面我将从四个角度来阐述我对客户端开发的理解：</p>
<h2 id="技术应用"><a href="#技术应用" class="headerlink" title="技术应用"></a>技术应用</h2><p>抛开具体使用的语言或者框架，不同的职位或者开发方向在解决用户需求和技术问题上有着不同的纵深，意味着“术业有专攻”。这一点很多时候属于给用户一把锤子，他就看啥都像钉子一样，由不得你，甚至还会倒逼你去一步步提升体验。</p>
<h3 id="剪贴板"><a href="#剪贴板" class="headerlink" title="剪贴板"></a>剪贴板</h3><p>既然都上了客户端，想必用户需要频繁操作的了，这就免不了要和键盘及鼠标事件打交道。常见的输入方式还好，就跟浏览器基本一致，只是遇到过 Mac 上无法通过快捷键复制粘贴的问题。说来都离谱，作为一个文本编辑软件，发布出去时竟然无法使用快捷键 <code>Ctrl + C</code> + <code>Ctrl +Ｖ</code>！还好我们很快就发布了版本修复了这个问题。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/44797324/shortcuts-in-electron-on-mac">Shortcuts in Electron on Mac</a></p>
<p>而后我们又发现了右键菜单也得自己实现，不由感叹浏览器真是个复杂且贴心的玩意，给前端实现了如此多的功能。右键菜单部分同样是由 Electron 封装好了大量具体系统的 API，只需 JS 调用即可。</p>
<p>这些可能还是看得见的部分，看不见的部分，比如系统的剪贴板？如果我们想要模仿手机上长按复制文本至 App 内识别链接并打开对应页面的功能该如何操作呢？</p>
<p>因为各系统的剪贴板实现都是不同的，Web 上早期使用 <code>execCommand</code> 来与剪贴板交互，现在则有 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Clipboard">Clipboard API</a>。看起来很美好，只是致命的是 <code>clipboardchange</code> 事件尚未被 Chrome 实现 …… 这里陷入了前端的盲区。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/67473023/async-clipboard-api-clipboardchange-event-not-fired">Async Clipboard API - clipboardchange event not fired</a></p>
<p>从前端角度走不通，可以看一看 Electron。Electron 本身自带了一个 Clipboard API，上面有各种读取文本、富文本数据、图像的方法。同时，发起检查剪贴板的请求倒是容易，再不济也可以用轮询。做得细一点可以用 RxJS 来订阅一个<strong>根据鼠标聚焦窗口事件 + 剪贴板文字 + 去重 + 抢占式</strong>的调度模型：</p>
<p><a href="https://msyfls123.github.io/blog/2021/04/11/use-rxjs-to-handle-data-flows/">使用 RxJS 处理前端数据流</a></p>
<p>这里有个问题：当用户<strong>重复复制同一段文本</strong>进入到我们的客户端时如何判断出来呢？文本比较肯定是失效了，系统层面前面也了解过没有一致的剪贴板改变事件，所以只剩一条路，就是标记这段文本。</p>
<p><img src="/blog/images/from-f2e-to-client/Untitled%201.png" alt="Untitled"></p>
<p>因为绝大部分程序只读 bookmark 里的 url 而不会去读 title，可以用 title 来标记这段文本已经被我们的客户端识别过了，当用户再次从任意地方复制了文本时会清除掉这个 bookmark，也就达到了我们标识<strong>已经过 App 识别链接的文本</strong>的目的了。</p>
<p>到这里我们发现，客户端的开发与前端正在趋同，两者都会深入系统提供的功能，又期望第三方库或者浏览器能提供标准的接口。</p>
<h3 id="安装与更新"><a href="#安装与更新" class="headerlink" title="安装与更新"></a>安装与更新</h3><p>作为前端开发，页面关闭或刷新时，整个页面所有的元素都被销毁了，重新载入就是一张全新的白纸。而客户端不一样，下载下来就在硬盘占据了几百 MB 的空间，那可是战战兢兢，指不定哪一天用户嫌体积大就给卸载了。怎么办？当然是与时俱进，网页的优势在于刷新就是新版本，而客户端就只能老老实实做一键安装与自动更新了。</p>
<p>本着用户价值最大化的原则，现在软件大多抛弃了争奇斗艳的安装界面，反正做得越花哨越像流氓软件，Electron 社区标配 electron-builder 打包时提供的默认安装功能就挺好。只不过有时候要考虑旧版本的卸载问题，因为客户端技术更新换代，总有技术断层的阶段，旧版本无法正常自动更新到新版。像 Mac 上软件都进到了全局唯一的软件目录，安装时可以由系统来提示，玩 Linux 的也都是大神，安装不上也会自己手动 remove，但最广大的 Windows 用户迫切需要一键卸载旧版本的功能。我找到了 electron-builder 所依赖的 <a target="_blank" rel="noopener" href="https://nsis.sourceforge.io/Main_Page">NSIS</a> 安装器，定制了其安装脚本，在检测到旧版本的卸载程序存在于注册表时，会直接调用这个卸载程序，并等待它成功返回后进行新版本的安装过程。</p>
<p>作为互联网产品，诱骗，啊不是，引导用户安装上客户端不是终点，需要推陈出新、高效迭代，这就需要自动更新了。自动更新的目的在于<strong>及时让用户用上新版本</strong>，仿佛是一句废话。但鉴于大部分用户都是既嫌你更新太勤，又嫌你下载耗费流量，还盼着你能给他一天天地带来体验优化的主，这个开发思路还就是和网页前端不一样。</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>CPU 架构</th>
<th>安装包</th>
<th>自动更新包</th>
</tr>
</thead>
<tbody><tr>
<td>Windows</td>
<td>x32 / x64 / arm64</td>
<td>exe</td>
<td>exe</td>
</tr>
<tr>
<td>macOS</td>
<td>x64 / arm64</td>
<td>dmg / pkg</td>
<td>zip</td>
</tr>
<tr>
<td>Linux</td>
<td>x64 / arm64</td>
<td>deb / rpm</td>
<td>-</td>
</tr>
</tbody></table>
<p>首先不同的系统当然是不同的包，而根据 CPU 架构及包的用途，就能打出 10 多个不同的安装包来，总大小甚至超过了 2G …… 这在前端的角度看来真有些不可思议，究其原因还是因为 Electron 打包了 Chromium，这个东西就占据了每个安装包中至少 70% 的空间，而这一切都是为了能保证在不同机型上都有一致的浏览体验。</p>
<p>由于一开始开发时没有意料到 CPU 架构竟会如此迅速地扩展，所以现在只得以新版本逐渐刷量的方式来逐步替换成独立架构的客户端。这样做的好处是，后续更新时只需要下载对应架构的文件即可。</p>
<p><img src="/blog/images/from-f2e-to-client/Untitled%202.png" alt="Untitled"></p>
<p>关于自动更新还有如何进行灰度配置下发更新信息，通过 CDN 进行版本管理，App 内如何完成更新等，可参见之前的文章：</p>
<p><a href="https://msyfls123.github.io/blog/2021/09/16/electron-update/">Electron 客户端自动更新</a></p>
<p>这还未到终点，更新一整个客户端接近 100M 的体积仍是过重了，还可以将 Electron 内核和不怎么修改的数据库部分都抽离出来，这样只需要与网页一样更新静态资源即可。</p>
<p><img src="/blog/images/from-f2e-to-client/Untitled%203.png" alt="Untitled"></p>
<h3 id="离线使用"><a href="#离线使用" class="headerlink" title="离线使用"></a>离线使用</h3><p>本身 Electron 就是可以离线使用的，只是加上了在线网页之后就需要网络才能工作。一种方案是和移动端一样拦截 HTTP 请求并转发到本地离线资源，但这样带来的问题是需要定义非常繁复的拦截规则，以及如何更新离线资源等。</p>
<p>我们可以将离线的数据和资源分离，数据可以同移动端走一套数据库接口，只不过需要将数据库编译成不同的平台的动态链接库。</p>
<p><a href="https://msyfls123.github.io/blog/2021/12/05/node-native-addons/">初探 Node.js 原生扩展模块</a></p>
<p>然后是资源离线使用，或许很多人已经猜到了，那就是被称为 Electron 杀手的 PWA。</p>
<p><img src="/blog/images/from-f2e-to-client/Untitled%204.png" alt="Untitled"></p>
<p>在看过了 PWA 所列出的种种好处后，我们发现其不可避免地仍是一个 web 应用。所以，一个大胆的假设，用 PWA 来加载客户端所需要的页面！这样既拥有了网页的便利，又拥有了可触达系统本身 API 的能力，可谓一石二鸟之计。</p>
<p><img src="/blog/images/from-f2e-to-client/Untitled%205.png" alt="Untitled"></p>
<p>目前我们的腾讯文档桌面端离线功能正在紧锣密鼓地攻坚中，很快将于大家正式见面。</p>
<h3 id="浏览器体验"><a href="#浏览器体验" class="headerlink" title="浏览器体验"></a>浏览器体验</h3><p>作为一个名为客户端，实际上是定制版 Chrome 的软件，向 Chrome 看齐永远是对的。</p>
<p>用户说页面字体太小，看不清，那就给他加缩放快捷键。</p>
<p>用户又说缩放了看不到当前比例很慌，那就给他加缩放比例的 tips。</p>
<p><img src="/blog/images/from-f2e-to-client/Untitled%206.png" alt="Untitled"></p>
<p>这个用户满意了，那个用户说，哎呀我导出来了文档放在电脑上记不住了呀。</p>
<p>给他抄个 Chrome 的下载记录页面！</p>
<p><img src="/blog/images/from-f2e-to-client/Untitled%207.png" alt="Untitled"></p>
<p>如何存取页面缩放比例？如何在不同窗口间切换时共享一个 tips？鼠标悬浮移入移出 tips 显隐规则是怎样的？</p>
<p>导出记录该如何跟文档一一对应？有很多天记录时该怎么设计数据结构？本地文档被删除了怎么办？</p>
<p>不做不知道，一做吓一跳。原来一个浏览器不止看到的网页部分，周围的配套功能也有很多门道。</p>
<p>作为追赶者，有个好处是毕竟前方一直有领军者，永远有追赶的目标，但也总得想着如何积攒自己的优势，在属于自己的赛道上滑出自己的风采。</p>
<h2 id="角色扮演"><a href="#角色扮演" class="headerlink" title="角色扮演"></a>角色扮演</h2><p>前面提到的都是用户需要什么功能，但作为开发不仅仅是写出代码交给用户就完事了，同样重要的是进行多方合作，齐心协力将产品做好。这时就需要发挥主观能动性，在不同的情景下扮演不同的角色了。</p>
<h3 id="测试者"><a href="#测试者" class="headerlink" title="测试者"></a>测试者</h3><p>前面提到过，前端页面往往是单个页面完成单个任务，随用随走，所以其测试也主要针对在线数据。但客户端与之不同的在于有本地数据和系统 API 的差异，这也就决定了如果按照传统的人工测试，其成本是很高的。从效能上讲，如果只是编写的代码虽然可以在不同系统运行，但有多少系统就需要测多少遍，是不够经济的，同时测试人员也不一定完全理解设计意图。答案是得用自动化的测试进行覆盖，这就要求开发人员同时扮演测试者的角色。</p>
<p>如何改进呢？首先从技术上讲，应该把测试行为左移。</p>
<p><img src="/blog/images/from-f2e-to-client/Untitled%208.png" alt="Untitled"></p>
<p>从设计阶段就应该埋入测试所需的常量或者数据，比如可供 UI 测试获取元素用的 CSS 选择器，一些数据的 mock 可以直接放在类型定义旁边，方便测试时直接引入。</p>
<p>而在编写代码时，则应注意拆分可测试的单元。如果一个功能很复杂，那可以分成若干个子模块来进行编写，同样的，如果一个模块无法便捷地被测试，那它也可以被拆成若干个可测试单元，这样可以在一旦出现问题时通过一系列测试用例，准确定位到具体的单元，而不是一遍遍运行完整的模块测试以查找蛛丝马迹。</p>
<p>在编写测试用例时，区分平台特性是很重要的，例如快捷键或是菜单，这是 mac 和 Windows 存在显著差异的部分，又或者说只支持某个平台的用例，这时就得将不同系统的用例集用不同的机器运行。</p>
<p>到了运行测试时，因为客户端测试往往需要漫长的启动初始化，运行测试，处理异常情况、退出销毁测试环境等过程，在将测试自动化的过程中仍需要缓存一些数据，以供多次运行测试，降低边际成本。</p>
<h3 id="合作方"><a href="#合作方" class="headerlink" title="合作方"></a>合作方</h3><p>作为客户端，前端和后端都是你的爸爸。为啥这么说呢？因为页面出了问题，得找前端修，接口出了问题，得找后端修，仿佛变成了 bug 路由器。</p>
<p>想要克服这些问题，需要做到两点：</p>
<ol>
<li>做好日志<br>当用户发现问题，找到你这边，如何优雅地甩锅 …… 哦不是 …… 定位问题呢？那就是在各种用户行为及接口返回时都做好日志以及进行参数校验，遵循宽入严出的准则。所谓害人之心不可有，防人之心不可无，把任何第三方业务都当成是不可信来源进行防范。同时日志也可以还原出用户操作轨迹，有时候出错的点并不是问题的根源，前几页日志里一行不起眼的 warning 才是真正的问题所在。</li>
<li>明确职责<br>虽然仍然是直面用户的那一端，但团队协作讲究的是分工明确，不逾矩不代劳。客户端本来就是中枢站，如果把前后端的功能都挪到端上实现，必将牵一发而动全身，这就是重构原则里的“发散式变化”。笔者之前接受登录模块，模块里甚至直接存了用户的 token，这是非常敏感的数据，如果不经良好的加密手段，可能造成用户权限被盗用。如何解决这一点呢？答案是不要重复发明轮子，而要善于利用标准轮子。登录相关的标准存储轮子就是 cookie 了，而 cookie 是由 Chrome 直接管辖的，我们只需交给 Chrome 来鉴权，并且自己维护一个非敏感的用户登录状态即可。<br>如果一段程序不知道其作用范围，那就不要写。</li>
</ol>
<h3 id="客服"><a href="#客服" class="headerlink" title="客服"></a>客服</h3><p>记得我刚毕业实习时问当时 leader，我们会有直面用户的机会吗？leader 微微一笑，肯定会有的。后来我发现，原来不用和用户打交道、安心写代码的日子，才是非常弥足珍贵的……</p>
<p>有人说客服是性子最好的，因为需要每天应对用户各种刁难职责而不变色。当用户找上门来，通常都是丢失了数据、或者打不开应用闪退之类的问题，仿佛落水之人看到了救命稻草。这种情况下，如果不能给用户解决问题，是有很大心理压力的，而人有压力时就容易犯错。</p>
<p>如何降低犯错的概率和风险呢？一种方式是尽量减少操作的步骤。俗话说，less is more，能让用户一键完成的操作就不要让他点两次。</p>
<p><img src="/blog/images/from-f2e-to-client/Untitled%209.png" alt="Untitled"></p>
<p>上图是一个打开崩溃日志目录的按钮，用户需要手动把该目录里的 log 文件提供给开发（因为没找到司内相关 native 日志服务）。在没有这个按钮之前，用户需要手动打开终端，输入一长串地址，然后才能到这个目录下，而这中间任何一步都可能阻塞住用户。只有最简单的操作流程，才能高效地解决问题。</p>
<p>但很多时候，用户的问题并不那么简单。看似是 A 除了问题，对比日志后发现 B 也有问题，在 debug B 的过程中发现其依赖于 C。甚至到最后发现这些统统都不是问题所在，用户使用的根本不是你这个软件！这里就陷入了用户给你制造的黑盒。怎么办呢？在现有工具无法保证筛选出正常的反馈时，就得通过作业流程来保证各种类型的 bug 在每个阶段就被精准定位并消灭了。</p>
<p>中医有望闻问切四种基本诊察疾病方法，在针对用户反馈时也可以这么做：</p>
<ol>
<li>望：根据用户描述，大致判断问题是否属于所属产品，是网络问题还是应用问题。</li>
<li>闻：故障截图、上报日志，分析可能出错的模块，如若遇到误报情形，在这一步即可排除。</li>
<li>问：让用户参与调试，通过改变设置项、清理缓存等步骤以期快速恢复。</li>
<li>切：直接给用户换一个版本（客户端就这点好，不同用户可以用着不同版本），相当于做移植手术了。可以植入更多自定义日志上报功能，更全面地分析用户使用状态，以便根治问题。</li>
</ol>
<h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>前面讲到了技术应用方向和自我角色扮演，它们都属于外功，也就是技能部分，下面要讲的可说是内功心法。读过武侠小说的人都知道，内外兼修，德才兼备，方可成为一代大师。技巧永远是层出不穷的，只有透过日复一日，年复一年的基础积累，感受技术背后的脉搏，才能融会贯通，成为优秀的开发者。</p>
<p>IPC</p>
<p>Node.js addons</p>
<p>CI 流水线：蓝盾 Stream CI</p>
<p>WebAssembly</p>
<p>模式：图、pub/sub</p>
<p>Windows 注册表</p>
<h2 id="心理建设"><a href="#心理建设" class="headerlink" title="心理建设"></a>心理建设</h2><p>采用最通用的技术，延长更迭周期</p>
<p>控制技术的复杂度</p>
<p>学习新技术的恐慌</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-05T04:21:01.000Z" title="2021/12/5 12:21:01">2021-12-05</time>发表</span><span class="level-item"><time dateTime="2022-08-18T08:15:36.004Z" title="2022/8/18 16:15:36">2022-08-18</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/web/">web</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/2021/12/05/node-native-addons/">初探 Node.js 原生扩展模块</a></h1><div class="content"><p>最近因项目需要开始研究 Node.js 原生模块的实现，并尝试接入自研 C++ 模块。Node.js 因其具有良好的跨平台适配性和非阻塞事件循环的特点，受到了服务端开发者的关注，但 JavaScript 毕竟基于 GC 实现的数据结构，在高性能计算上有所不足；而且很多老代码或者扩展库都以 C++ 书写，也给移植编译带来了一定的困难。如何在性能、兼容性和开发效率上取得平衡，为了解决这些个问题，让我们开始书写第一个 Node.js C++ addon 吧！</p>
<h1 id="C-addons-的原理"><a href="#C-addons-的原理" class="headerlink" title="C++ addons 的原理"></a>C++ addons 的原理</h1><p>不管你看哪个教程（其实中文书也就一本，就是死月这本<a target="_blank" rel="noopener" href="https://book.douban.com/subject/30247892/">《Node.js：来一打 C++ 扩展》</a>），提到 Node.js 一上来就是 V8 Isolate, Context, Handle,  Scope 讲一堆，看完这两百页头已经晕了。这些都是非常基础的 V8 知识，但离实际运用还隔了很远。为了写出 C++ addons，我们只要抓住一点 ———— “JavaScript 对象就是一个个 V8 C++ 对象的映射”。</p>
<h2 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h2><p><img src="/blog/images/node-native-addons/20-57-34.png" alt="String 类型的继承链"></p>
<p>上图是 JS 里一个简单 String 的继承关系，如何创建一个简单的字符串呢？<code>String::NewFromUtf8(isolate, &quot;hello&quot;).ToLocalChecked()</code>，是不是看了有些头大？如果告诉你这种继承关系随着 V8 的升级经常发生变化，是不是感觉血压都高了？</p>
<p>没错，这就是上古时期 Node.js C++ addons 的开发方式，需要指定 Node.js 的版本进行编译，只有在指定 ABI 的版本下才能运行。</p>
<p><a target="_blank" rel="noopener" href="https://nodejs.org/api/addons.html#hello-world">https://nodejs.org/api/addons.html#hello-world</a> ，有兴趣的读者可以阅读下 Node.js 官网对于 C++ addons 的简易劝退教程，里面展示了不少早期 Node.js 开发者与 C++ 对象搏斗的真实记录。</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>在经历了刀耕火种的日子后，盼星星盼月亮终于迎来了 Node.js 的原生抽象 —— N-API。它利用宏封装了不同 V8 版本之间的 API 差异，统一暴露了多种识别、创建、修改 JS 对象的方法。让我们来看看如何创建一个字符串呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node_api.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">napi_value js_str;</span><br><span class="line"><span class="built_in">napi_create_string_utf8</span>(env, <span class="string">&quot;hello&quot;</span>, NAPI_AUTO_LENGTH, &amp;js_str);</span><br></pre></td></tr></table></figure>

<p>哎~ 怎么看起来也不是很简单嘛？。。。</p>
<p>别骂了，别骂了，要知道 Node.js 为了兼容不同版本付出了多大的努力吗？相对来说上述的 API 调用算是很简单的了，最重要的是它很稳定，基本不随着 Node.js 和 V8 的版本更迭而变化。<code>env</code> 是执行的上下文，<code>js_str</code> 是创建出来的 JS 字符串，<code>NAPI_AUTO_LENGTH</code> 是自动计算的长度，这里还隐含了一个变量，就是 <code>napi_create_string_utf8</code> 的返回值 <code>napi_status</code>，这个值一般平平无奇，但万一要是出了 bug 就得靠它来甄别各处调用是否成功了。</p>
<h1 id="C-addons-实战"><a href="#C-addons-实战" class="headerlink" title="C++ addons 实战"></a>C++ addons 实战</h1><p>前情铺垫结束，让我们拥抱改变吧。下面将带大家以一个简单的 Defer 模块的实现为例，走马观花式感受 C++ addons 的开发过程。</p>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>首先你得有个 Node.js，版本呢最好能到 14、16 以上，因为 N-API 有些部分在 14 的时候才加入或者稳定下来。</p>
<p>然后你得准备个 C++ 编译环境，下面简单介绍下各个系统下是如何操作的。</p>
<ul>
<li>macOS: <code>xcode-select --install</code> 基本可以解决，后面会用 llvm 进行编译。</li>
<li>Windows: 啥都别说了，VS 大法好。推荐装 2019 Community 即可，然后记得把 v142 工具集装了就成。因为 node-gyp 会写死 VS 的版本号，所以如果出了问题就使用 VS installer 继续安装缺失的组件即可。</li>
<li>Linux: <code>apt-get install gcc</code>.</li>
</ul>
<p>这样就准备好正式编译我们的 C++ addons 了。</p>
<h3 id="node-gyp"><a href="#node-gyp" class="headerlink" title="node-gyp"></a>node-gyp</h3><p>通常情况下编译并链接 C++ 库是一件非常吃力不讨好的事，<code>cmake</code> 等工具的出现就是为了解决这个问题，而到了 Node.js 这一边，官方提供了同样的工具 <code>node-gyp</code>。只需 <code>npm i node-gyp -g</code> 即可，后续我们都将在 <code>node-gyp</code> 下操作。</p>
<h3 id="VS-Code-相关设置"><a href="#VS-Code-相关设置" class="headerlink" title="VS Code 相关设置"></a>VS Code 相关设置</h3><p>我们可以在 VS Code 中设置 C++ 环境，这会给开发带来不少的体验提升。<br><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/languages/cpp">https://code.visualstudio.com/docs/languages/cpp</a><br><img src="/blog/images/node-native-addons/23-22-13.png"></p>
<p>这里是一份可参考的 <code>.vscode/c_cpp_properties.json</code> 示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Mac&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/usr/local/include/node&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;defines&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;macFrameworkPath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/System/Library/Frameworks&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/Library/Frameworks&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/clang&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span>: <span class="string">&quot;c17&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++14&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;macos-clang-x63&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Win32&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;C:\\Users\\kimi\\AppData\\Local\\node-gyp\\Cache\\16.6.0\\include\\node&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;defines&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span>,</span><br><span class="line">                <span class="string">&quot;UNICODE&quot;</span>,</span><br><span class="line">                <span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;windowsSdkVersion&quot;</span>: <span class="string">&quot;10.0.17763.0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span>: <span class="string">&quot;C:/Program Files (x86)/Microsoft Visual Studio/2017/Community/VC/Tools/MSVC/14.16.27023/bin/Hostx64/x64/cl.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span>: <span class="string">&quot;c17&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++14&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;windows-msvc-x64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段 JSON 最重要的就是要指向 node 头文件的 <code>includePath</code>，上面分别提供了当前 Node.js 安装版本和 node-gyp 缓存的路径，以供参考。</p>
<h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><p>凡事怎么少得了 <code>hello world</code> 呢？这里假设你已经装好了 <code>node-gyp</code> 了。</p>
<p>先创建一个 <code>main.cpp</code>，写入以下内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node_api.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">napi_value <span class="title">Init</span><span class="params">(napi_env env, napi_value exports)</span></span>&#123;</span><br><span class="line">  napi_value hello_str;</span><br><span class="line">  <span class="built_in">napi_create_string_utf8</span>(env, <span class="string">&quot;hello&quot;</span>, NAPI_AUTO_LENGTH, &amp;hello_str);</span><br><span class="line">  <span class="built_in">napi_set_property</span>(env, exports, hello_str, hello_str);</span><br><span class="line">  <span class="keyword">return</span> exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NAPI_MODULE</span>(NODE_GYP_MODULE_NAME, Init)</span><br></pre></td></tr></table></figure>

<p>创建一个 <code>binding.gyp</code>，写入以下内容。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;targets&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;target_name&quot;</span>: <span class="string">&quot;native&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sources&quot;</span>: [<span class="string">&quot;./main.cpp&quot;</span>],</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行 <code>npx node-gyp configure build</code>，不出意外的话会生成一个 <code>build</code> 目录，build/Release/native.node 就是我们所要的货了。</p>
<p><img src="/blog/images/node-native-addons/00-43-04.png" alt="生成的原生模块"></p>
<p>如何使用呢？很简单，打开 Node.js REPL，直接 <code>require</code> 就行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Node.js v16.6.0.</span><br><span class="line">Type <span class="string">&quot;.help&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt; require(<span class="string">&#x27;./build/Release/native&#x27;</span>).hello</span><br><span class="line">&lt; <span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>
<p>大功告成！</p>
<h2 id="小试牛刀：开发一个简单的-Defer-模块"><a href="#小试牛刀：开发一个简单的-Defer-模块" class="headerlink" title="小试牛刀：开发一个简单的 Defer 模块"></a>小试牛刀：开发一个简单的 Defer 模块</h2><p>在学习新知识点时，以熟悉的概念切入会更有学下去的动力。我们就小试牛刀，先实现一个非常非常简陋只支持一个 Promise 调用的 Defer 模块吧！</p>
<p>先让我们看一下最终需要的调用方式，从 JS 侧看就是加载一个 *.node 的原生模块，然后 new 了一个对象出来，最后调用一下它的 <code>run</code> 方法。可能 JS 写起来 10 行都不到，但这次的目标是将 C++ 与 JS 联动，这中间的过程就有点让人摸不着头脑了。</p>
<p><img src="/blog/images/node-native-addons/22-21-18.png" alt="简单的 Defer 模块"></p>
<p>别慌，遇事不决先确定接口类型，类型就是编程中的量纲，分析量纲就能得出解题思路。</p>
<h3 id="JS-接口类型定义"><a href="#JS-接口类型定义" class="headerlink" title="JS 接口类型定义"></a>JS 接口类型定义</h3><p>抛开语言的差异，来分析一下这个 Deferred 类，它的构造函数接受一个字符串进行初始化，然后有个 public 的 <code>run</code> 方法接受一个数字并返回一个 Promise，以这个数字所代表的毫秒数来延迟 resolve 所返回的 Promise。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deferred</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>)</span><br><span class="line">    <span class="title">public</span> <span class="title">run</span>(<span class="params">delay: <span class="built_in">number</span></span>): <span class="title">Promise</span>&lt;<span class="title">string</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咦，这么简单吗？是的，JS 本就为了开发效率而生，但事情整到 C++ 层面可就不那么简单了 …… 但天下大事，必作于细，良好的职责划分有利于用不同的工具切准要害，逐个突破，我们接着往下看。</p>
<h3 id="划分-C-与-JavaScript-职责"><a href="#划分-C-与-JavaScript-职责" class="headerlink" title="划分 C++ 与 JavaScript 职责"></a>划分 C++ 与 JavaScript 职责</h3><p><img src="/blog/images/node-native-addons/23-47-59.png" alt="JavaScript 与 C++ 各自的职责"></p>
<p>为了 OOP，我们将数据和行为都存放在一起，这会带来一些问题，就是数据该由谁持有？如果 JS 持有数据，将 C++ 作为一个无状态的服务，每次都将数据从 JS 传过来，计算完了传回去，但这样会造成序列化的开销。如果 C++ 持有数据，JS 侧就相当于一个代理，只是把用户请求代理到 C++ 这一边，计算完再转发给用户侧。</p>
<p>实际情况是，一旦涉及到原生调用，C++ 持有的数据很有可能是 JS 处理不了的不可序列化数据，比如二进制的文件，线程 / IO 信息等等，所以还是 C++ 做主导，JS 只做接口比较好。但这样就不可避免地要从 C++ CRUD 一些 JS 对象了，接着往下走。</p>
<h3 id="创建-C-类"><a href="#创建-C-类" class="headerlink" title="创建 C++ 类"></a>创建 C++ 类</h3><p>激动的心，颤抖的手，终于开始写 C++ 代码了 …… 老规矩，还是先定义一个 class 吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node_api.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeDeferred</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NativeDeferred</span>(<span class="keyword">char</span> *str);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> milliseconds, std::function&lt;<span class="keyword">void</span>(<span class="keyword">char</span> *str)&gt; complete)</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *_str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看起来和 JS 侧的代码也很像嘛，只不过换成了 callback 的方式。如何使它能在 JS 侧使用呢？</p>
<h3 id="创建-JS-class"><a href="#创建-JS-class" class="headerlink" title="创建 JS class"></a>创建 JS class</h3><p><img src="/blog/images/node-native-addons/01-14-19.png" alt="napi_define_class"></p>
<p>N-API 提供了各种直接创建 JS 对象的方法，包括字符串、数字、undefined 等基本量，也有函数和对象等等。擒贼先擒王，一上来就找到了用于创建 class 的 <a target="_blank" rel="noopener" href="https://nodejs.org/api/n-api.html#napi_define_class">napi_define_class</a>。读了一遍定义后，发现需要提供 <code>napi_callback constructor</code> 和 <code>const napi_property_descriptor* properties</code> 作为参数。又马不停蹄地找到了 <a target="_blank" rel="noopener" href="https://nodejs.org/api/n-api.html#napi_callback">napi_callback</a>，这个函数是我们后面会经常遇到的。</p>
<p><img src="/blog/images/node-native-addons/01-01-08.png" alt="napi_callback"></p>
<p><code>napi_callback</code> 接受一个 <code>napi_env</code> 和 <code>napi_callback_info</code>，前者是创建 JS 对象所必须的环境信息，而后者是 JS 传入的信息。</p>
<p>如何解读这些信息呢？有 <a target="_blank" rel="noopener" href="https://nodejs.org/api/n-api.html#napi_get_cb_info">napi_get_cb_info</a> 这个方法。通过它可以读出包括 <code>this</code> 和各种 ArrayLike 的参数。</p>
<p><img src="/blog/images/node-native-addons/01-17-07.png" alt="napi_get_cb_info"></p>
<p>我们在讨论如何创建一个 JS 的 class 啊，这是不是绕太远了？等等，你提到了 <code>this</code>？有的面试题里会考如何手写一个 Object.create，难道这就是那里面默认的 <code>this</code>？你猜对了，这个 <code>this</code> 在通过 Function 创建时，在构造器里是用 v8 的 <a target="_blank" rel="noopener" href="https://v8docs.nodesource.com/node-0.8/db/d5f/classv8_1_1_object_template.html">ObjectTemplate</a> 来实例化一个 instance 的。（PS: 如果 napi_callback 是从 JS 侧调用，那它就是 JS 的那个 <code>this</code>。）</p>
<p>从 JS class 创建对象的话，这个 <code>napi_callback</code> 就是 JS 定义的 <code>constructor</code>，执行完返回 <code>this</code> 就行了，但既然是深度融合 C++ 的功能，我们当然还有别的事要做。</p>
<h3 id="将-C-对象封装到-JS-instance-上"><a href="#将-C-对象封装到-JS-instance-上" class="headerlink" title="将 C++ 对象封装到 JS instance 上"></a>将 C++ 对象封装到 JS instance 上</h3><p>前面声明了一个非常简易的 C++ 对象 <code>NativeDeferred</code>，我们要将它封装到刚创建的 <code>this</code> 上，返回给 JS 侧。为啥要这样做？因为前面提到了，我们要用 C++ 对象持有一些数据和状态，这些不便于在 JS 和 C++ 来回传递的数据需要一个可追溯的容器来承载（即 NativeDeferred），我们可以假设这个容器有两种存储方式：</p>
<ol>
<li>全局对象，也就是 V8 里的 global，然后生成一个 key 给 JS instance。</li>
<li>挂到 JS instance 上（N-API 支持这种操作）。</li>
</ol>
<p>很明显第一种方法不仅污染了全局对象，也避免不了 JS instance 需要持有一个值，那还不如直接把 C++ 对象绑到它上面。</p>
<p><img src="/blog/images/node-native-addons/02-23-59.png" alt="从 napi_callback 中读出 C++ 对象"></p>
<p>取出 C++ 对象的过程形成了 napi_callback -&gt; JS Deferred(this) -&gt; unwrap C++ NativeDeferred 这样一个线路，需要用到 <a target="_blank" rel="noopener" href="https://nodejs.org/api/n-api.html#napi_wrap">napi_wrap</a> 和 <a target="_blank" rel="noopener" href="https://nodejs.org/api/n-api.html#napi_unwrap">napi_unwrap</a> 方法。</p>
<p><img src="/blog/images/node-native-addons/02-08-06.png" alt="napi_wrap"></p>
<p>这里又有个坑，<code>finalize_cb</code> 是必须要赋值的，而且它应该去调用 NativeDeferred 的析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Destructor</span><span class="params">(napi_env env, <span class="keyword">void</span> *instance_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">void</span> * <span class="comment">/*finalize_hint*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">reinterpret_cast</span>&lt;NativeDeferred *&gt;(instance_ptr)-&gt;~<span class="built_in">NativeDeferred</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">napi_value <span class="title">js_constructor</span><span class="params">(napi_env env, napi_callback_info info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 中间省略了获取 js_this 和 name 的步骤</span></span><br><span class="line">    NativeDeferred *deferred = <span class="keyword">new</span> <span class="built_in">NativeDeferred</span>(name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">napi_wrap</span>(env, js_this, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(deferred),</span><br><span class="line">            Destructor, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> js_this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就设置好了一个在 constructor 里会生成并自动绑定 C++ 对象的 JS class。</p>
<h3 id="设置-JS-class-上的调用方法"><a href="#设置-JS-class-上的调用方法" class="headerlink" title="设置 JS class 上的调用方法"></a>设置 JS class 上的调用方法</h3><p>数据只有实际被使用才能发挥其价值，对应到 JS Deferred 上面，就是要让 JS 侧 run 方法顺利地调用到 C++ 侧的 run，这里面又要经历前面所说的从 <code>napi_callback</code> 一直到拿到原生 NativeDeferred 的过程，但如何让这个 <code>napi_callback</code> 可以被 Deferred 实例后的对象应用呢？</p>
<p>聪明的读者已经猜到了，就是将它设到 Deferred 这个类的原型链上，具体来说就是前面 <code>napi_define_class</code> 时的 <code>const napi_property_descriptor* properties</code>，我们来看一下它的定义。</p>
<p><img src="/blog/images/node-native-addons/12-32-23.png" alt="napi_property_descriptor"></p>
<p><a target="_blank" rel="noopener" href="https://nodejs.org/api/n-api.html#napi_property_descriptor">napi_property_descriptor</a> 上其他属性都比较常见，似乎跟 <code>Object.defineProperty</code> 有些相似，但 <code>enumerable</code> 和 <code>configurable</code> 这些值呢？。我们注意到了 <a target="_blank" rel="noopener" href="https://nodejs.org/api/n-api.html#napi_property_attributes">napi_property_attributes</a> 这个参数，</p>
<p><img src="/blog/images/node-native-addons/12-37-58.png" alt="napi_property_attributes"></p>
<p>找到了找到了，这就是我们需要的属性了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;node_api.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">napi_property_descriptor runDesc = &#123;<span class="string">&quot;run&quot;</span>, <span class="number">0</span>, js_run,           <span class="number">0</span>,</span><br><span class="line">                                    <span class="number">0</span>,     <span class="number">0</span>, napi_default_method, <span class="number">0</span>&#125;;</span><br><span class="line">napi_value js_class;</span><br><span class="line">napi_property_descriptor descs[<span class="number">1</span>] = &#123;runDesc&#125;;</span><br><span class="line"><span class="built_in">napi_define_class</span>(env, <span class="string">&quot;Deferrered&quot;</span>, NAPI_AUTO_LENGTH, js_constructor,</span><br><span class="line">                  <span class="literal">nullptr</span>, <span class="number">1</span>, descs,</span><br><span class="line">                  &amp;js_class);</span><br></pre></td></tr></table></figure>
<p>*<code>js_run</code> 会在下一节实现。</p>
<p>上面的 <code>js_class</code> 就是我们一开始定义的 JS Deferred 了，将他 <code>napi_set_property</code> 到 hello world 中的 exports 上就能被 Node.js 访问啦。</p>
<p>这里还有个坑，<code>napi_default_method</code> 有些版本下是被定义在 if 里的，需要我们预先 define <code>NAPI_VERSION</code> 或者 <code>NAPI_EXPERIMENTAL</code>。<br><img src="/blog/images/node-native-addons/12-58-36.png" alt="NAPI_VERSION 需要 8 以上"></p>
<p>让我们打开 <code>binding.gyp</code>，在 target 里加入以下内容，就可以啦。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;defines&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;NAPI_EXPERIMENTAL&quot;</span>,</span><br><span class="line">        <span class="string">&quot;NAPI_VERSION=8&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-回调-JS-callback"><a href="#C-回调-JS-callback" class="headerlink" title="C++ 回调 JS callback"></a>C++ 回调 JS callback</h3><p>到现在我们已经实现了一个 class 所需要的一切能力，但有个小问题：这些方法都是单向的从 JS 侧传递给 C++ 侧，或者反之，没有双向交互的部分。可以想一想怎样算是“双向交互”呢？就是 Node.js 常见的 callback 啊，我们还没有涉及到如何从 C++ 调用 JS 函数。<a target="_blank" rel="noopener" href="https://nodejs.org/api/n-api.html#napi_call_function">napi_call_function</a>这个函数就是 napi_get_cb_info 的逆操作了，把参数按个数和数组传递给函数指针。</p>
<p><img src="/blog/images/node-native-addons/20-46-09.png" alt="napi_call_function"></p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将这个函数 export 出去，使用时会以传入的第一个参数 args[0]，判定其为函数传入 42 作为唯一参数进行调用</span></span><br><span class="line"><span class="function">napi_value <span class="title">fire_js_callback</span><span class="params">(napi_env env, napi_callback_info info)</span> </span>&#123;</span><br><span class="line">    napi_value js_this;</span><br><span class="line">    napi_value args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">size_t</span> argc = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">napi_get_cb_info</span>(env, info, &amp;argc, args, &amp;js_this, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    napi_value num;</span><br><span class="line">    <span class="built_in">napi_create_int32</span>(env, <span class="number">42</span>, &amp;num);</span><br><span class="line">    napi_value res[<span class="number">1</span>] = &#123; num &#125;;</span><br><span class="line">    <span class="built_in">napi_call_function</span>(env, js_this, args[<span class="number">0</span>], <span class="number">1</span>, res, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，我们目前总共实现了以下的 C++ addon 能力。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td>创建 JS class</td>
<td>✅</td>
</tr>
<tr>
<td>给 JS class 添加 method</td>
<td>✅</td>
</tr>
<tr>
<td>将 C++ 对象封装到 JS 对象上</td>
<td>✅</td>
</tr>
<tr>
<td>调用 JS 函数</td>
<td>✅</td>
</tr>
</tbody></table>
<h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><p>读到这里的朋友可能发现了，前面提到的 Deferred 还有一环没有实现，就是延时调用。来想一下 C++ 里如何能延时呢？可以另外启动一个线程，将它 sleep，可以简单写下代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node_api.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_run</span><span class="params">(std::function&lt;<span class="keyword">void</span>()&gt; complete)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    <span class="built_in">complete</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">napi_value <span class="title">fire_js_callback</span><span class="params">(napi_env env, napi_callback_info info)</span> </span>&#123;</span><br><span class="line">    napi_value js_this;</span><br><span class="line">    napi_value args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">size_t</span> argc = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">napi_get_cb_info</span>(env, info, &amp;argc, args, &amp;js_this, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    napi_value num;</span><br><span class="line">    <span class="built_in">napi_create_int32</span>(env, <span class="number">42</span>, &amp;num);</span><br><span class="line">    napi_value res[<span class="number">1</span>] = &#123; num &#125;;</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; complete = [=]() &#123;</span><br><span class="line">        <span class="built_in">napi_call_function</span>(env, js_this, args[<span class="number">0</span>], <span class="number">1</span>, res, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">runner</span><span class="params">(thread_run, complete)</span></span>;</span><br><span class="line">    runner.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但实际调用时，等了很久也没有触发，这是为什么呢？</p>
<blockquote>
<p>JavaScript functions can normally only be called from a native addon’s main thread. If an addon creates additional threads, then Node-API functions that require a napi_env, napi_value, or napi_ref must not be called from those threads.</p>
<p>When an addon has additional threads and JavaScript functions need to be invoked based on the processing completed by those threads, those threads must communicate with the addon’s main thread so that the main thread can invoke the JavaScript function on their behalf. The thread-safe function APIs provide an easy way to do this.</p>
<p><a target="_blank" rel="noopener" href="https://nodejs.org/api/n-api.html#asynchronous-thread-safe-function-calls">Asynchronous thread-safe function calls</a></p>
</blockquote>
<p>原来跨线程之后 napi_env 就不是原来的那个它了，我们需要按照 N-API 的方式来包装一下异步调用的函数。</p>
<h3 id="线程安全调用"><a href="#线程安全调用" class="headerlink" title="线程安全调用"></a>线程安全调用</h3><p>写到这里，笔者发现自己的功力已经不足以解释我所看到的文档了，直接上代码吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node_api.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_run</span><span class="params">(std::function&lt;<span class="keyword">void</span>()&gt; complete)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    <span class="built_in">complete</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_callback</span><span class="params">(napi_env env, napi_value js_callback, <span class="keyword">void</span>* context, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    napi_value js_this = <span class="keyword">reinterpret_cast</span>&lt;napi_value&gt;(context);</span><br><span class="line"></span><br><span class="line">    napi_value num;</span><br><span class="line">    <span class="built_in">napi_create_int32</span>(env, <span class="number">42</span>, &amp;num);</span><br><span class="line">    napi_value res[<span class="number">1</span>] = &#123; num &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">napi_call_function</span>(env, js_this, js_callback, <span class="number">1</span>, res, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">napi_value <span class="title">fire_js_callback</span><span class="params">(napi_env env, napi_callback_info info)</span> </span>&#123;</span><br><span class="line">    napi_value js_this;</span><br><span class="line">    napi_value args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">size_t</span> argc = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">napi_get_cb_info</span>(env, info, &amp;argc, args, &amp;js_this, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    napi_value async_resource_name;</span><br><span class="line">    <span class="built_in">napi_create_string_utf8</span>(env, <span class="string">&quot;foobar&quot;</span>, NAPI_AUTO_LENGTH,</span><br><span class="line">                          &amp;async_resource_name);</span><br><span class="line">    napi_threadsafe_function thread_complete;</span><br><span class="line">    <span class="comment">// 将 js 传来的 callback 调谐函数 thread_callback 一起传入生成线程安全的回调</span></span><br><span class="line">    <span class="built_in">napi_create_threadsafe_function</span>(</span><br><span class="line">      env, args[<span class="number">0</span>], <span class="literal">nullptr</span>, async_resource_name, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>,</span><br><span class="line">      js_this, thread_callback, &amp;thread_complete);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将线程安全的回调再包装成闭包</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; complete = [=]() &#123;</span><br><span class="line">        <span class="built_in">napi_call_threadsafe_function</span>(thread_complete, <span class="literal">nullptr</span>, napi_tsfn_blocking);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 真正放到另一个线程去执行</span></span><br><span class="line">    <span class="function">std::thread <span class="title">runner</span><span class="params">(thread_run, complete)</span></span>;</span><br><span class="line">    runner.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> js_this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">napi_value <span class="title">Init</span><span class="params">(napi_env env, napi_value exports)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  napi_value fire_str;</span><br><span class="line">  <span class="built_in">napi_create_string_utf8</span>(env, <span class="string">&quot;fire&quot;</span>, NAPI_AUTO_LENGTH, &amp;fire_str);</span><br><span class="line">  napi_value fire;</span><br><span class="line">  <span class="built_in">napi_create_function</span>(env, <span class="string">&quot;fire&quot;</span>, NAPI_AUTO_LENGTH, fire_js_callback, <span class="literal">nullptr</span>, &amp;fire);</span><br><span class="line">  <span class="built_in">napi_set_property</span>(env, exports, fire_str, fire);</span><br><span class="line">  <span class="keyword">return</span> exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NAPI_MODULE</span>(NODE_GYP_MODULE_NAME, Init)</span><br></pre></td></tr></table></figure>

<p>经过一番眼花缭乱的操作后，终于成功触发了 <code>args[0]</code> 处的 JS callback 函数，这就是简化版本的 <code>js_run</code> 了。</p>
<h3 id="Promise-的实现"><a href="#Promise-的实现" class="headerlink" title="Promise 的实现"></a>Promise 的实现</h3><p>既然实现了异步回调，我们再努力一把，实现 Promise 的返回值，这就比较简单了，N-API 将 <a target="_blank" rel="noopener" href="https://nodejs.org/api/n-api.html#napi_create_promise">napi_create_promise</a> 设计为生成 <code>napi_deferred* deferred</code> 和 <code>napi_value* promise</code>，一式两份，一份直接返回给 JS，一份则留着在异步调用中将其 resolve。<br>我们只需稍微改写一下前面的代码即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_callback</span><span class="params">(napi_env env, napi_value js_callback, <span class="keyword">void</span>* context, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    napi_deferred deferred = <span class="keyword">reinterpret_cast</span>&lt;napi_deferred&gt;(data);</span><br><span class="line"></span><br><span class="line">    napi_value num;</span><br><span class="line">    <span class="built_in">napi_create_int32</span>(env, <span class="number">42</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">napi_resolve_deferred</span>(env, deferred, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">napi_value <span class="title">fire_js_callback</span><span class="params">(napi_env env, napi_callback_info info)</span> </span>&#123;</span><br><span class="line">    napi_value js_this;</span><br><span class="line">    <span class="keyword">size_t</span> argc = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">napi_get_cb_info</span>(env, info, &amp;argc, <span class="literal">nullptr</span>, &amp;js_this, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    napi_value async_resource_name;</span><br><span class="line">    <span class="built_in">napi_create_string_utf8</span>(env, <span class="string">&quot;foobar&quot;</span>, NAPI_AUTO_LENGTH,</span><br><span class="line">                          &amp;async_resource_name);</span><br><span class="line">    napi_threadsafe_function thread_complete;</span><br><span class="line">    <span class="comment">// 将 js 传来的 callback 调谐函数 thread_callback 一起传入生成线程安全的回调</span></span><br><span class="line">    <span class="built_in">napi_create_threadsafe_function</span>(</span><br><span class="line">      env, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, async_resource_name, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>,</span><br><span class="line">      <span class="literal">nullptr</span>, thread_callback, &amp;thread_complete);</span><br><span class="line"></span><br><span class="line">    napi_value promise;</span><br><span class="line">    napi_deferred deferred;</span><br><span class="line">    <span class="built_in">napi_create_promise</span>(env, &amp;deferred, &amp;promise);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将线程安全的回调再包装成闭包</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; complete = [=]() &#123;</span><br><span class="line">        <span class="built_in">napi_call_threadsafe_function</span>(thread_complete, deferred, napi_tsfn_blocking);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 真正放到另一个线程去执行</span></span><br><span class="line">    <span class="function">std::thread <span class="title">runner</span><span class="params">(thread_run, complete)</span></span>;</span><br><span class="line">    runner.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>篇幅起见，只贴出关键的两个函数了。</p>
<h3 id="完工"><a href="#完工" class="headerlink" title="完工"></a>完工</h3><p>事已至此，与 Deferred 这个类相关的代码已经基本介绍完了，完整的代码可以参见这个仓库：<br><a target="_blank" rel="noopener" href="https://github.com/msyfls123/basin">https://github.com/msyfls123/basin</a></p>
<p>启动工程应该只需要：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br><span class="line">npm run configure</span><br><span class="line">npx node-gyp rebuild --debug</span><br><span class="line">npm run basin</span><br></pre></td></tr></table></figure>

<h1 id="C-addons-调试与构建"><a href="#C-addons-调试与构建" class="headerlink" title="C++ addons 调试与构建"></a>C++ addons 调试与构建</h1><p>别看前面洋洋洒洒一堆操作，只写出了百来行代码，基本每行代码都踩过坑。这时候强有效的调试工具就显得非常重要了。</p>
<h2 id="VSCode-CodeLLDB-调试"><a href="#VSCode-CodeLLDB-调试" class="headerlink" title="VSCode CodeLLDB 调试"></a>VSCode CodeLLDB 调试</h2><p>推荐大杀器 <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a>，配合 launch.json 食用，可在 VSCode 中左侧 Run and Debug 里对 C++ 代码断点并显示变量信息。</p>
<p><img src="/blog/images/node-native-addons/23-44-43.png" alt="CodeLLDB"></p>
<p>简易 launch.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;debug with build&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;lldb&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;npm: build&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;$&#123;workspaceFolder&#125;/index.js&quot;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/node-native-addons/23-43-38.png" alt="断点信息"></p>
<h2 id="prebuildify-预构建包"><a href="#prebuildify-预构建包" class="headerlink" title="prebuildify 预构建包"></a>prebuildify 预构建包</h2><p>前面都是开发模式，如果是服务端使用的话，加上入口 js 文件后已经可以作为 npm 包发布了，安装时会自动执行 <code>node-gyp rebuild</code> 重新构建的。<br>但如果是嵌入到某个 App，比如腾讯文档桌面端，或是 QQ 之类的客户端应用里，那就需要根据不同的系统和架构进行跨平台编译了。</p>
<p>常见架构有：</p>
<ul>
<li>Linux: x64, armv6, armv7, arm64</li>
<li>Windows: x32, x64, arm64</li>
<li>macOS: x64, arm64</li>
</ul>
<p>竟然有这么多 …… 还好社区提供了跨平台编译的解决方案 ———— prebuild，但它需要在安装时下载对应的包，所以还需要将这些构建产物发布到服务器上，不与 npm 包放在一起。虽然在包体积很大的情况下的确有必要，这显然不是我们所追求的一键下载。</p>
<p>然后我就找到了 <a target="_blank" rel="noopener" href="https://github.com/prebuild/prebuildify">prebuildify</a>。它是这么说的：</p>
<blockquote>
<p>With prebuildify, all prebuilt binaries are shipped inside the package that is published to npm, which means there’s no need for a separate download step like you find in prebuild. The irony of this approach is that it is faster to download all prebuilt binaries for every platform when they are bundled than it is to download a single prebuilt binary as an install script.</p>
<p>Always use prebuildify –@mafintosh</p>
</blockquote>
<p>有没有成功案例呢？有，那就是 Google 出品的 <a target="_blank" rel="noopener" href="https://github.com/Level/leveldown/blob/master/package.json#L20-L25">LevelDB 的 js 封装</a>就是它做的，</p>
<p><img src="/blog/images/node-native-addons/00-05-41.png" alt="prebuildify 直接应用在 npm scripts"></p>
<p>我们项目里也应用了这个方案，参见 <a target="_blank" rel="noopener" href="https://github.com/msyfls123/basin/blob/main/package.json#L16-L18%E3%80%82">https://github.com/msyfls123/basin/blob/main/package.json#L16-L18。</a></p>
<h2 id="与-CI-集成"><a href="#与-CI-集成" class="headerlink" title="与 CI 集成"></a>与 CI 集成</h2><p>可是这虽然可以只在三个系统各执行一遍进行编译，但每次发布都得登录三台机器来执行吗？no, no, no, 我们当然可以将这一切集成到 CI 中自动运行。</p>
<p>这里展示一下业界标杆 ———— GitHub Actions 的配置:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.platform.runner</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">CXX:</span> <span class="string">g++</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">platform:</span></span><br><span class="line">          [</span><br><span class="line">            &#123; <span class="attr">runner:</span> <span class="string">&quot;windows-latest&quot;</span>, <span class="attr">command:</span> <span class="string">&quot;build:windows&quot;</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">runner:</span> <span class="string">&quot;macos-latest&quot;</span>, <span class="attr">command:</span> <span class="string">&quot;build:mac&quot;</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">runner:</span> <span class="string">&quot;ubuntu-latest&quot;</span>, <span class="attr">command:</span> <span class="string">&quot;build:linux&quot;</span> &#125;,</span><br><span class="line">          ]</span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Check</span> <span class="string">out</span> <span class="string">Git</span> <span class="string">repository</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">GCC</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">egor-tensin/setup-gcc@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">version:</span> <span class="string">latest</span></span><br><span class="line">          <span class="attr">platform:</span> <span class="string">x64</span></span><br><span class="line">        <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.platform.runner</span> <span class="string">==</span> <span class="string">&#x27;ubuntu-latest&#x27;</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Node.js,</span> <span class="string">NPM</span> <span class="string">and</span> <span class="string">Yarn</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;16.6.1&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm i --ignore-scripts</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Compile</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm run configure</span></span><br><span class="line"><span class="string">          npm run $&#123;&#123; matrix.platform.command &#125;&#125;</span></span><br><span class="line"><span class="string"></span>    </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Archive</span> <span class="string">debug</span> <span class="string">artifacts</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">build</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            index.js</span></span><br><span class="line"><span class="string">            index.d.ts</span></span><br><span class="line"><span class="string">            package.json</span></span><br><span class="line"><span class="string">            prebuilds/</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/node-native-addons/00-12-03.png" alt="GitHub Actions"></p>
<!-- 而在厂内则是采用了新出的 [Stream CI](https://iwiki.woa.com/pages/viewpage.action?pageId=673026981)，主要原因时它支持所有平台，同时又可以 pipeline as code。
![蓝盾新出品的 Stream CI](/blog/images/node-native-addons/00-09-48.png) -->

<h1 id="C-addons-的展望"><a href="#C-addons-的展望" class="headerlink" title="C++ addons 的展望"></a>C++ addons 的展望</h1><p>至此，本文也要进入尾声了，期望能对想要提升 Node.js 程序性能或是拓展应用场景的你带来一些帮助！最后提两点展望吧：</p>
<h2 id="无痛集成第三方库"><a href="#无痛集成第三方库" class="headerlink" title="无痛集成第三方库"></a>无痛集成第三方库</h2><p>笔者看到项目里大部分第三方 C++ 库都是以源码形式引入的 …… 对于习惯 <code>npm i</code> 的人来说这肯定是像狗皮膏药一样贴在心上。听说 bazel 挺香，但其语法令人望而却步，似乎也不是一个依赖管理工具，这时有个叫 <a target="_blank" rel="noopener" href="https://conan.io/">Conan</a> 的货映入眼帘。</p>
<p>这里有篇文章讲述如何将 Conan 和你的 Node.js addons 结合，笔者试了一下确实可行，甚至都不需要 python 的 virtualenv，只是 <code>libraries</code> 需要小小的调整下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;libraries&#x27;: [</span><br><span class="line">    <span class="string">&quot;-Wl,-rpath,@loader_path/&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="编译目标：WebAssembly-Interface？"><a href="#编译目标：WebAssembly-Interface？" class="headerlink" title="编译目标：WebAssembly Interface？"></a>编译目标：WebAssembly Interface？</h2><p>居安思危，笔者也思考了下 Node.js addons 的局限性，需要每个平台都编译一遍还是有点麻烦的，有没有什么办法可以 <code>compile once, run everywhere</code> 呢？</p>
<p>有！那就是 <code>WebAssembly</code>，“那你为啥不用呢？”，这是个好问题。LevelDB 仓库内也有过类似的<a target="_blank" rel="noopener" href="https://github.com/Level/community/issues/63">讨论</a>，最后问题落到了性能和文件系统上，如果涉及到异步线程问题的话，会更复杂一点，因为 <code>emcc</code> 的 <code>pthread</code> 是基于 Web Worker 提供的，不清楚 Node.js 侧是否有 polyfill，以及在不同 Worker 运行，各种同步原语、Arc、Mutex 等是否都得到了支持，这些都是未知的。所以遇到一坨祖传下来打满了补丁的 C++ 代码，我们选择的稳妥方式依然是悄悄关上门，然后建座桥，把路直接修到它门口就跑，真刺激啊……</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-16T03:49:17.000Z" title="2021/9/16 11:49:17">2021-09-16</time>发表</span><span class="level-item"><time dateTime="2022-08-18T07:53:40.398Z" title="2022/8/18 15:53:40">2022-08-18</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/web/">web</a><span> / </span><a class="link-muted" href="/blog/categories/web/app/">app</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/2021/09/16/electron-update/">Electron 客户端自动更新</a></h1><div class="content"><p>随着科技的进步，啊不，是网络通信技术的提升，客户端用户不再受限于拨号上网那样的小水管，百兆宽带触手可达，随时随地自动更新版本成为了标配。作为跨端框架的翘楚，Electron 自然也是内置了自动更新功能，但查阅其官网发现其提供的 <a target="_blank" rel="noopener" href="https://www.electronjs.org/docs/latest/api/auto-updater/">autoUpdater</a> 并无明确的操作路径可言，读完仍是一头雾水，尤其是还需要私有 CDN 部署时更是两眼一抹黑。</p>
<p><img src="/blog/images/electron-update/21-41-04.png" alt="漫漫更新路"></p>
<p>让我们从零开始，更新逻辑其实很简单，每次发版时将更新文件分发到 CDN 上，客户端通过检查 CDN 上有无更新文件继而下载文件并安装即可完成更新。抛开上传下载这种技术问题不谈，要解决两点：</p>
<ul>
<li><strong>什么版本可以更新</strong></li>
<li><strong>可以更新到什么版本</strong></li>
</ul>
<p>说人话就是从哪儿来，要到哪儿去。本文将要为你解答的就是如何通过一系列配置服务及本地设置，完成包含灰度更新、强制更新、静默更新以及 GUI 更新过程展示在内的可操纵动态更新策略。</p>
<h1 id="发布与更新"><a href="#发布与更新" class="headerlink" title="发布与更新"></a>发布与更新</h1><p>首先确定一点，我们依然用的是 Electron 提供的更新功能，但主要用了 electron-builder 封装后的 <a target="_blank" rel="noopener" href="https://www.electron.build/auto-update">electron-updater</a>。这里的文档和 Electron 官方文档比较类似，有点啰嗦，下面就使用自定义 CDN 这条路提纲挈领地给大家梳理关键步骤。</p>
<h2 id="生成制品信息"><a href="#生成制品信息" class="headerlink" title="生成制品信息"></a>生成制品信息</h2><p>这里假定你一定是通过 electron-builder 进行打包了，需要在 electron-builder-config 中加入如下字段（<a target="_blank" rel="noopener" href="https://www.electron.build/configuration/publish">详细字段配置</a>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    ...others,</span><br><span class="line">    <span class="attr">publish</span>: &#123;</span><br><span class="line">        <span class="attr">provider</span>: <span class="string">&#x27;generic&#x27;</span>,</span><br><span class="line">        <span class="attr">channel</span>: <span class="string">&#x27;latest-win32&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;https://your.cdn/update-path&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里假设你的更新文件会被放在 <code>https://your.cdn/update-path</code> 目录下，通过这个配置打出来的安装文件就会多出一个 <code>latest-win32.yml</code> 文件，这个文件长下面这样子。</p>
<p><img src="/blog/images/electron-update/22-21-14.png" alt="制品信息"></p>
<p>这里面主要包含了版本号、更新资源文件的文件名及校验 hash 及发布日期等关键信息，对于后续步骤最重要的就是资源的文件名了。</p>
<p>将安装包与 yml 文件一起上传到 CDN 的 <code>https://your.cdn/update-path</code> 目录下就完成了生成制品信息的这一步。<br><img src="/blog/images/electron-update/22-34-19.png"></p>
<h2 id="配置自动更新信息"><a href="#配置自动更新信息" class="headerlink" title="配置自动更新信息"></a>配置自动更新信息</h2><p>来到这一步需要保证 <code>https://your.cdn/update-path/latest-win32.yml</code> 已经是可以访问到的了，后面就是如何在端内把 electron-updater 支棱起来。</p>
<p>首先安装 electron-updater: <code>npm i electron-updater</code>。<br><strong>这里作者实操中有个问题，electron-updater 打包后失效了，暂未明确原因，故在 webpack 中将其设为 externals 并在最终由 electron-builder 打包的目录 projectDir 里安装了 electron-updater。</strong></p>
<p>接下来，为了开发调试我们需要做一点骚操作，在下图所示目录中有 <code>app-update.yml</code> 文件。<br><img src="/blog/images/electron-update/22-36-06.png" alt="mac app-update.yml"><br><img src="/blog/images/electron-update/22-37-11.png" alt="windows app-update.yml"><br>这个文件里面内容是这样的，将它复制到项目根目录下并改名叫 <code>dev-app-update.yml</code>，后面就能调试更新了。<br><img src="/blog/images/electron-update/22-40-35.png"></p>
<p><strong>需要说明的是，macOS 上自动更新只有在签名后的 App 上才能进行，在后续步骤的退出并安装前会校验签名，校验失败时会报错。</strong></p>
<h2 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h2><p>进入激动人心的代码环节！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; autoUpdater &#125; <span class="keyword">from</span> <span class="string">&#x27;electron-updater&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为指定发布版本，以防错读为 Electron 版本</span></span><br><span class="line">autoUpdater.currentVersion = APP_VERSION;</span><br><span class="line">autoUpdater.setFeedURL(&#123;</span><br><span class="line">    <span class="attr">provider</span>: <span class="string">&#x27;generic&#x27;</span>,</span><br><span class="line">    <span class="attr">channel</span>: os.platform() === <span class="string">&#x27;darwin&#x27;</span> ? <span class="string">&#x27;latest&#x27;</span> : <span class="string">&#x27;latest-win32&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">`https://your.cdn/update-path`</span>,</span><br><span class="line">&#125;);</span><br><span class="line">autoUpdater.checkForUpdates();</span><br><span class="line">autoUpdater.on(<span class="string">&#x27;update-downloaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    autoUpdater.quitAndInstall();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>对，就是这么简单，一旦下载更新完成立即以迅雷不及掩耳之势退出 App 进行更新并重启。这是不是太快了点？都没留给用户反应的时间了。别着急，可以通过 autoUpdater 上的各种事件，参考这篇文章做一个漂亮的更新界面出来。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Wonder233/article/details/80563236">https://blog.csdn.net/Wonder233/article/details/80563236</a></p>
<p>autoUpdater 事件：</p>
<ul>
<li>error</li>
<li>checking-for-update</li>
<li>update-available</li>
<li>update-not-available</li>
<li>download-progress</li>
<li>update-downloaded</li>
</ul>
<h1 id="精细化更新"><a href="#精细化更新" class="headerlink" title="精细化更新"></a>精细化更新</h1><h2 id="静默更新"><a href="#静默更新" class="headerlink" title="静默更新"></a>静默更新</h2><p>如果把上面的退出更新步骤去掉，离静默更新就只差一步了。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ autoUpdater.autoInstallOnAppQuit = true;</span></span><br><span class="line"><span class="deletion">- autoUpdater.on(&#x27;update-downloaded&#x27;, () =&gt; &#123;</span></span><br><span class="line"><span class="deletion">-     autoUpdater.quitAndInstall();</span></span><br><span class="line"><span class="deletion">- &#125;);</span></span><br></pre></td></tr></table></figure>

<p>至这一步为止，你已经做完了一个不断更新到最新版本的 Electron App 所需要的一切了。</p>
<h2 id="强制更新"><a href="#强制更新" class="headerlink" title="强制更新"></a>强制更新</h2><p>即使你设置了每次都会自动更新，依然免不了有用户不肯买账，或者说会在各种网络差的情况下没法及时更新到最新版本，我们可以通过下发一个配置文件，来控制一些有废弃 API 或者有严重 bug 的版本被继续使用。</p>
<p>例如在配置系统上生成一个如下的配置，其中 <code>force_update_version_list</code> 就是一串 semver 规范的版本范围。<br><img src="/blog/images/electron-update/23-27-57.png" alt="配置字段"></p>
<p>在使用时只需要判断一下 APP_VERSION 是否在这些个区间内即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> semver <span class="keyword">from</span> <span class="string">&#x27;semver&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = <span class="keyword">await</span> fetchUpdateConfig(key);</span><br><span class="line"><span class="keyword">const</span> forceUpdateVersions = config.force_update_version_list;</span><br><span class="line"><span class="keyword">const</span> shouldForceUpdate = forceUpdateVersions.length &amp;&amp;</span><br><span class="line">    semver.satisfies(APP_VERSION, forceUpdateVersions.join(<span class="string">&#x27;||&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>这里在发出拉取更新配置请求时出现了一个 <code>key</code>，这个 <code>key</code> 提供了本地去决定使用哪个配置组的能力，比如测试就填 Test，线上默认为 Production，方便测试。</p>
<h2 id="灰度更新"><a href="#灰度更新" class="headerlink" title="灰度更新"></a>灰度更新</h2><p>强制更新解决了哪些版本必须更新的问题，如果我们只想让某些版本或是用户更新到指定版本呢？这也就是通常所说的金丝雀发布、A/B 测试之类的了。同样可以用从网络拉取一个配置文件来解决，正好内网配置平台也满足我们的这种需要。</p>
<h3 id="配置下发"><a href="#配置下发" class="headerlink" title="配置下发"></a>配置下发</h3><p>首先配置系统支持根据 uin、ip 等进行灰度发布，我们选择了将 uid 后两位截取为 uin 上传到灰度名单，配置系统拿到上传的 uin 后根据灰度规则（上图配的是 30% 的比例）下发最新更改的配置项。</p>
<p><img src="/blog/images/electron-update/23-53-15.png" alt="逐天放开灰度比例"></p>
<p>直至 100% 比例后，可以进一步替换官网链接，完成全量发布。</p>
<h3 id="更新路径划分"><a href="#更新路径划分" class="headerlink" title="更新路径划分"></a>更新路径划分</h3><p>聪明的读者已经发现了，在<a href="#%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0">发布与更新</a>中，我们设置了统一的更新目录 <code>https://your.cdn/update-path</code>，如果有不同的更新版本，我们就需要设置不同的文件或是目录来控制。该用哪一种呢？</p>
<table>
<thead>
<tr>
<th>版本排布方式</th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td>按目录</td>
<td>一个目录一个版本</td>
<td>无统一更新地址</td>
</tr>
<tr>
<td>按文件</td>
<td>目录层级扁平</td>
<td>文件混杂难分清</td>
</tr>
</tbody></table>
<p>综合考虑后，我们选择了按目录划分版本的方式。<br><img src="/blog/images/electron-update/00-07-14.png" alt="版本"><br><img src="/blog/images/electron-update/00-07-44.png" alt="文件"></p>
<p>在上面的自动更新代码中替换如下内容即可享受精细控制的灰度更新功能。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; autoUpdater &#125; from &#x27;electron-updater&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ const config = await fetchUpdateConfig(key);</span></span><br><span class="line"></span><br><span class="line">// 设置为指定发布版本，以防错读为 Electron 版本</span><br><span class="line">autoUpdater.currentVersion = APP_VERSION;</span><br><span class="line">autoUpdater.setFeedURL(&#123;</span><br><span class="line">    provider: &#x27;generic&#x27;,</span><br><span class="line">    channel: os.platform() <span class="comment">=== &#x27;darwin&#x27; ? &#x27;latest&#x27; : &#x27;latest-win32&#x27;,</span></span><br><span class="line"><span class="deletion">-   url: `https://your.cdn/update-path`,</span></span><br><span class="line"><span class="addition">+   url: `https://your.cdn/update-path/$&#123;config.version&#125;`,</span></span><br><span class="line">&#125;);</span><br><span class="line">autoUpdater.checkForUpdates();</span><br><span class="line">autoUpdater.on(&#x27;update-downloaded&#x27;, () =&gt; &#123;</span><br><span class="line">    autoUpdater.quitAndInstall();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><h2 id="按渠道分发"><a href="#按渠道分发" class="headerlink" title="按渠道分发"></a>按渠道分发</h2><p>更新和下载一样是为了分发，当我们有了更多渠道时也可能需要考虑渠道间的差异性。渠道包可以通过配置文件进行区分，更新时只更新资源而不更新配置文件，这样就可以做到不同的安装渠道在同一更新下保持自身渠道特殊性。</p>
<h2 id="永远递增你的版本号"><a href="#永远递增你的版本号" class="headerlink" title="永远递增你的版本号"></a>永远递增你的版本号</h2><p>The lastest, the best.</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/blog/">上一页</a></div><div class="pagination-next"><a href="/blog/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/blog/">1</a></li><li><a class="pagination-link is-current" href="/blog/page/2/">2</a></li><li><a class="pagination-link" href="/blog/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/blog/page/10/">10</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://www.gravatar.com/avatar/ec56b0250e1a422107277db28a26e7ef?s=128" alt="Kimi Ma"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Kimi Ma</p><p class="is-size-6 is-block">F2E Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/blog/archives"><p class="title">29</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/blog/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/blog/tags"><p class="title">29</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="http://github.com/msyfls123" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="http://github.com/msyfls123"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://www.facebook.com/profile.php?id=100002470633349"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/msyfls123"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/blog/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://douban.com/people/kimimama" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Douban</span></span><span class="level-right"><span class="level-item tag">douban.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/blog/categories/GUI/"><span class="level-start"><span class="level-item">GUI</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/app/"><span class="level-start"><span class="level-item">app</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/web/"><span class="level-start"><span class="level-item">web</span></span><span class="level-end"><span class="level-item tag">16</span></span></a><ul><li><a class="level is-mobile" href="/blog/categories/web/app/"><span class="level-start"><span class="level-item">app</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/blog/categories/%E6%83%B3%E6%B3%95/"><span class="level-start"><span class="level-item">想法</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/%E7%94%9F%E6%B4%BB/"><span class="level-start"><span class="level-item">生活</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/blog/tags/App/"><span class="tag">App</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Chrome/"><span class="tag">Chrome</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Electron/"><span class="tag">Electron</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Node-js/"><span class="tag">Node.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/React/"><span class="tag">React</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Rust/"><span class="tag">Rust</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/UI/"><span class="tag">UI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Windows/"><span class="tag">Windows</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/data-flow/"><span class="tag">data-flow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/electron/"><span class="tag">electron</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/electron-builder/"><span class="tag">electron-builder</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/gulp/"><span class="tag">gulp</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/node/"><span class="tag">node</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/nodejs/"><span class="tag">nodejs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/rollup/"><span class="tag">rollup</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/rxjs/"><span class="tag">rxjs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/web/"><span class="tag">web</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/webpack/"><span class="tag">webpack</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"><span class="tag">客户端</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E6%97%85%E8%A1%8C/"><span class="tag">旅行</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"><span class="tag">注册表</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E8%A7%A3%E8%B0%9C/"><span class="tag">解谜</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E9%80%BB%E8%BE%91/"><span class="tag">逻辑</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E9%9D%A2%E8%AF%95/"><span class="tag">面试</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E9%A3%8E%E6%99%AF/"><span class="tag">风景</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/blog/2023/06/19/clean-electron-architecture/"><img src="https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExeXptbHFpcTZmaHFvODFtc3hqMzd5dDFwcWJtMDF1Z2ptcG84cGd4dSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/h2NxCschQ81ltiL9HV/giphy.gif" alt="Electron 应用整洁架构"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-06-19T06:20:00.000Z">2023-06-19</time></p><p class="title"><a href="/blog/2023/06/19/clean-electron-architecture/">Electron 应用整洁架构</a></p><p class="categories"><a href="/blog/categories/app/">app</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/blog/2023/04/28/regedit-file-association/"><img src="/blog/images/regedit-file-association/16-41-14.png" alt="注册表与文件关联"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-04-28T08:33:42.000Z">2023-04-28</time></p><p class="title"><a href="/blog/2023/04/28/regedit-file-association/">注册表与文件关联</a></p><p class="categories"><a href="/blog/categories/Windows/">Windows</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/blog/2022/05/31/warn-before-quit/"><img src="/blog/images/warn-before-quit/23-30-54.png" alt="浅谈仿 Chrome 标签页退出未保存弹窗机制"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-05-31T12:05:35.000Z">2022-05-31</time></p><p class="title"><a href="/blog/2022/05/31/warn-before-quit/">浅谈仿 Chrome 标签页退出未保存弹窗机制</a></p><p class="categories"><a href="/blog/categories/GUI/">GUI</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-09T16:08:58.000Z">2022-02-10</time></p><p class="title"><a href="/blog/2022/02/10/from-f2e-to-client/">如何从前端到客户端</a></p><p class="categories"><a href="/blog/categories/web/">web</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-05T04:21:01.000Z">2021-12-05</time></p><p class="title"><a href="/blog/2021/12/05/node-native-addons/">初探 Node.js 原生扩展模块</a></p><p class="categories"><a href="/blog/categories/web/">web</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/blog/archives/2023/06/"><span class="level-start"><span class="level-item">六月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/blog/"><img src="/blog/images/logo.jpg" alt="马猴烧酒" height="28"></a><p class="is-size-7"><span>&copy; 2023 msyfls123</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="http://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/blog/js/column.js"></script><script src="/blog/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><script src="/blog/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/blog/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/blog/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>